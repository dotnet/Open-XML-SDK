// Copyright (c) Microsoft Open Technologies, Inc.  All rights reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.
// This source file is machine generated.  Please do not change the code manually.
using System;
using System.Collections.Generic;
using System.IO.Packaging;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml;
using DocumentFormat.OpenXml.Office2013.ExcelAc;
using DocumentFormat.OpenXml.Office2010.ExcelAc;
using DocumentFormat.OpenXml.Office2013.Excel;
using DocumentFormat.OpenXml.Office2010.Excel;
using DocumentFormat.OpenXml.Drawing.Spreadsheet;

namespace DocumentFormat.OpenXml.Spreadsheet
{
/// <summary>
/// <para>Extension.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Extension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11092;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Extension class.
    /// </summary>
    public Extension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Extension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Extension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Extension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Extension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Extension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Extension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    
    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Extension>(deep);
    }

   
}
/// <summary>
/// <para>Calculation Chain Info. The root element of CalculationChainPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calcChain.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculationCell &lt;x:c></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculationCell))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculationChain : OpenXmlPartRootElement
{
    private const string tagName = "calcChain";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11093;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// CalculationChain constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the CalculationChain.</param>
    internal CalculationChain(CalculationChainPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the CalculationChainPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(CalculationChainPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the CalculationChainPart associated with this element.
    /// </summary>
    public CalculationChainPart CalculationChainPart
    {
		get
		{
			return OpenXmlPart as CalculationChainPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the CalculationChain class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculationChain(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculationChain class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculationChain(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculationChain class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculationChain(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the CalculationChain class.
    /// </summary>
    public CalculationChain() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the CalculationChainPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(CalculationChainPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "c" == name)
    return new CalculationCell();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculationChain>(deep);
    }

}
/// <summary>
/// <para>Comments. The root element of WorksheetCommentsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:comments.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Authors &lt;x:authors></description></item>
///<item><description>CommentList &lt;x:commentList></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Authors))]
    [ChildElementInfo(typeof(CommentList))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Comments : OpenXmlPartRootElement
{
    private const string tagName = "comments";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11094;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Comments constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Comments.</param>
    internal Comments(WorksheetCommentsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorksheetCommentsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorksheetCommentsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorksheetCommentsPart associated with this element.
    /// </summary>
    public WorksheetCommentsPart WorksheetCommentsPart
    {
		get
		{
			return OpenXmlPart as WorksheetCommentsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Comments class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comments(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Comments class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comments(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Comments class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Comments(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Comments class.
    /// </summary>
    public Comments() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorksheetCommentsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorksheetCommentsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "authors" == name)
    return new Authors();
    
if( 22 == namespaceId && "commentList" == name)
    return new CommentList();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "authors","commentList","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Authors.</para>
    /// <para> Represents the following element tag in the schema: x:authors </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Authors Authors
    {
        get 
        {
            return GetElement<Authors>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> List of Comments.</para>
    /// <para> Represents the following element tag in the schema: x:commentList </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CommentList CommentList
    {
        get 
        {
            return GetElement<CommentList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Comments>(deep);
    }

}
/// <summary>
/// <para>XML Mapping. The root element of CustomXmlMappingsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:MapInfo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Schema &lt;x:Schema></description></item>
///<item><description>Map &lt;x:Map></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Schema))]
    [ChildElementInfo(typeof(Map))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MapInfo : OpenXmlPartRootElement
{
    private const string tagName = "MapInfo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11095;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "SelectionNamespaces" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Prefix Mappings for XPath Expressions.</para>
    /// <para>Represents the following attribute in the schema: SelectionNamespaces </para>
    /// </summary>
    [SchemaAttr(0, "SelectionNamespaces")]
    public StringValue SelectionNamespaces
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// MapInfo constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the MapInfo.</param>
    internal MapInfo(CustomXmlMappingsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the CustomXmlMappingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(CustomXmlMappingsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the CustomXmlMappingsPart associated with this element.
    /// </summary>
    public CustomXmlMappingsPart CustomXmlMappingsPart
    {
		get
		{
			return OpenXmlPart as CustomXmlMappingsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the MapInfo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MapInfo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MapInfo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MapInfo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MapInfo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MapInfo(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the MapInfo class.
    /// </summary>
    public MapInfo() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the CustomXmlMappingsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(CustomXmlMappingsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "Schema" == name)
    return new Schema();
    
if( 22 == namespaceId && "Map" == name)
    return new Map();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "SelectionNamespaces" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MapInfo>(deep);
    }

}
/// <summary>
/// <para>Connections. The root element of ConnectionsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:connections.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Connection &lt;x:connection></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Connection))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Connections : OpenXmlPartRootElement
{
    private const string tagName = "connections";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11096;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Connections constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Connections.</param>
    internal Connections(ConnectionsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the ConnectionsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(ConnectionsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the ConnectionsPart associated with this element.
    /// </summary>
    public ConnectionsPart ConnectionsPart
    {
		get
		{
			return OpenXmlPart as ConnectionsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Connections class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Connections(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Connections class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Connections(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Connections class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Connections(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Connections class.
    /// </summary>
    public Connections() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the ConnectionsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(ConnectionsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "connection" == name)
    return new Connection();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Connections>(deep);
    }

}
/// <summary>
/// <para>PivotCache Definition. The root element of PivotTableCacheDefinitionPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotCacheDefinition.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheSource &lt;x:cacheSource></description></item>
///<item><description>CacheFields &lt;x:cacheFields></description></item>
///<item><description>CacheHierarchies &lt;x:cacheHierarchies></description></item>
///<item><description>Kpis &lt;x:kpis></description></item>
///<item><description>TupleCache &lt;x:tupleCache></description></item>
///<item><description>CalculatedItems &lt;x:calculatedItems></description></item>
///<item><description>CalculatedMembers &lt;x:calculatedMembers></description></item>
///<item><description>Dimensions &lt;x:dimensions></description></item>
///<item><description>MeasureGroups &lt;x:measureGroups></description></item>
///<item><description>Maps &lt;x:maps></description></item>
///<item><description>PivotCacheDefinitionExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheSource))]
    [ChildElementInfo(typeof(CacheFields))]
    [ChildElementInfo(typeof(CacheHierarchies))]
    [ChildElementInfo(typeof(Kpis))]
    [ChildElementInfo(typeof(TupleCache))]
    [ChildElementInfo(typeof(CalculatedItems))]
    [ChildElementInfo(typeof(CalculatedMembers))]
    [ChildElementInfo(typeof(Dimensions))]
    [ChildElementInfo(typeof(MeasureGroups))]
    [ChildElementInfo(typeof(Maps))]
    [ChildElementInfo(typeof(PivotCacheDefinitionExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCacheDefinition : OpenXmlPartRootElement
{
    private const string tagName = "pivotCacheDefinition";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11097;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","invalid","saveData","refreshOnLoad","optimizeMemory","enableRefresh","refreshedBy","refreshedDateIso","refreshedDate","backgroundQuery","missingItemsLimit","createdVersion","refreshedVersion","minRefreshableVersion","recordCount","upgradeOnRefresh","tupleCache","supportSubquery","supportAdvancedDrill" };
    private static byte[] attributeNamespaceIds = { 19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> invalid.</para>
    /// <para>Represents the following attribute in the schema: invalid </para>
    /// </summary>
    [SchemaAttr(0, "invalid")]
    public BooleanValue Invalid
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> saveData.</para>
    /// <para>Represents the following attribute in the schema: saveData </para>
    /// </summary>
    [SchemaAttr(0, "saveData")]
    public BooleanValue SaveData
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> refreshOnLoad.</para>
    /// <para>Represents the following attribute in the schema: refreshOnLoad </para>
    /// </summary>
    [SchemaAttr(0, "refreshOnLoad")]
    public BooleanValue RefreshOnLoad
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> optimizeMemory.</para>
    /// <para>Represents the following attribute in the schema: optimizeMemory </para>
    /// </summary>
    [SchemaAttr(0, "optimizeMemory")]
    public BooleanValue OptimizeMemory
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> enableRefresh.</para>
    /// <para>Represents the following attribute in the schema: enableRefresh </para>
    /// </summary>
    [SchemaAttr(0, "enableRefresh")]
    public BooleanValue EnableRefresh
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> refreshedBy.</para>
    /// <para>Represents the following attribute in the schema: refreshedBy </para>
    /// </summary>
    [SchemaAttr(0, "refreshedBy")]
    public StringValue RefreshedBy
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> refreshedDateIso.</para>
    /// <para>Represents the following attribute in the schema: refreshedDateIso </para>
    /// </summary>
    [SchemaAttr(0, "refreshedDateIso")]
    public DateTimeValue LastRefreshedDateIso
    {
        get { return (DateTimeValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> refreshedDate.</para>
    /// <para>Represents the following attribute in the schema: refreshedDate </para>
    /// </summary>
    [SchemaAttr(0, "refreshedDate")]
    public DoubleValue RefreshedDate
    {
        get { return (DoubleValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> backgroundQuery.</para>
    /// <para>Represents the following attribute in the schema: backgroundQuery </para>
    /// </summary>
    [SchemaAttr(0, "backgroundQuery")]
    public BooleanValue BackgroundQuery
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> missingItemsLimit.</para>
    /// <para>Represents the following attribute in the schema: missingItemsLimit </para>
    /// </summary>
    [SchemaAttr(0, "missingItemsLimit")]
    public UInt32Value MissingItemsLimit
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> createdVersion.</para>
    /// <para>Represents the following attribute in the schema: createdVersion </para>
    /// </summary>
    [SchemaAttr(0, "createdVersion")]
    public ByteValue CreatedVersion
    {
        get { return (ByteValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> refreshedVersion.</para>
    /// <para>Represents the following attribute in the schema: refreshedVersion </para>
    /// </summary>
    [SchemaAttr(0, "refreshedVersion")]
    public ByteValue RefreshedVersion
    {
        get { return (ByteValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> minRefreshableVersion.</para>
    /// <para>Represents the following attribute in the schema: minRefreshableVersion </para>
    /// </summary>
    [SchemaAttr(0, "minRefreshableVersion")]
    public ByteValue MinRefreshableVersion
    {
        get { return (ByteValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> recordCount.</para>
    /// <para>Represents the following attribute in the schema: recordCount </para>
    /// </summary>
    [SchemaAttr(0, "recordCount")]
    public UInt32Value RecordCount
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> upgradeOnRefresh.</para>
    /// <para>Represents the following attribute in the schema: upgradeOnRefresh </para>
    /// </summary>
    [SchemaAttr(0, "upgradeOnRefresh")]
    public BooleanValue UpgradeOnRefresh
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> tupleCache.</para>
    /// <para>Represents the following attribute in the schema: tupleCache </para>
    /// </summary>
    [SchemaAttr(0, "tupleCache")]
    public BooleanValue IsTupleCache
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> supportSubquery.</para>
    /// <para>Represents the following attribute in the schema: supportSubquery </para>
    /// </summary>
    [SchemaAttr(0, "supportSubquery")]
    public BooleanValue SupportSubquery
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> supportAdvancedDrill.</para>
    /// <para>Represents the following attribute in the schema: supportAdvancedDrill </para>
    /// </summary>
    [SchemaAttr(0, "supportAdvancedDrill")]
    public BooleanValue SupportAdvancedDrill
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    
    /// <summary>
    /// PivotCacheDefinition constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the PivotCacheDefinition.</param>
    internal PivotCacheDefinition(PivotTableCacheDefinitionPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the PivotTableCacheDefinitionPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(PivotTableCacheDefinitionPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the PivotTableCacheDefinitionPart associated with this element.
    /// </summary>
    public PivotTableCacheDefinitionPart PivotTableCacheDefinitionPart
    {
		get
		{
			return OpenXmlPart as PivotTableCacheDefinitionPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the PivotCacheDefinition class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinition(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinition class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinition(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinition class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCacheDefinition(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinition class.
    /// </summary>
    public PivotCacheDefinition() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the PivotTableCacheDefinitionPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(PivotTableCacheDefinitionPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cacheSource" == name)
    return new CacheSource();
    
if( 22 == namespaceId && "cacheFields" == name)
    return new CacheFields();
    
if( 22 == namespaceId && "cacheHierarchies" == name)
    return new CacheHierarchies();
    
if( 22 == namespaceId && "kpis" == name)
    return new Kpis();
    
if( 22 == namespaceId && "tupleCache" == name)
    return new TupleCache();
    
if( 22 == namespaceId && "calculatedItems" == name)
    return new CalculatedItems();
    
if( 22 == namespaceId && "calculatedMembers" == name)
    return new CalculatedMembers();
    
if( 22 == namespaceId && "dimensions" == name)
    return new Dimensions();
    
if( 22 == namespaceId && "measureGroups" == name)
    return new MeasureGroups();
    
if( 22 == namespaceId && "maps" == name)
    return new Maps();
    
if( 22 == namespaceId && "extLst" == name)
    return new PivotCacheDefinitionExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "cacheSource","cacheFields","cacheHierarchies","kpis","tupleCache","calculatedItems","calculatedMembers","dimensions","measureGroups","maps","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> CacheSource.</para>
    /// <para> Represents the following element tag in the schema: x:cacheSource </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CacheSource CacheSource
    {
        get 
        {
            return GetElement<CacheSource>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> CacheFields.</para>
    /// <para> Represents the following element tag in the schema: x:cacheFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CacheFields CacheFields
    {
        get 
        {
            return GetElement<CacheFields>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> CacheHierarchies.</para>
    /// <para> Represents the following element tag in the schema: x:cacheHierarchies </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CacheHierarchies CacheHierarchies
    {
        get 
        {
            return GetElement<CacheHierarchies>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Kpis.</para>
    /// <para> Represents the following element tag in the schema: x:kpis </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Kpis Kpis
    {
        get 
        {
            return GetElement<Kpis>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> TupleCache.</para>
    /// <para> Represents the following element tag in the schema: x:tupleCache </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TupleCache TupleCache
    {
        get 
        {
            return GetElement<TupleCache>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> CalculatedItems.</para>
    /// <para> Represents the following element tag in the schema: x:calculatedItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CalculatedItems CalculatedItems
    {
        get 
        {
            return GetElement<CalculatedItems>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> CalculatedMembers.</para>
    /// <para> Represents the following element tag in the schema: x:calculatedMembers </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CalculatedMembers CalculatedMembers
    {
        get 
        {
            return GetElement<CalculatedMembers>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Dimensions.</para>
    /// <para> Represents the following element tag in the schema: x:dimensions </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Dimensions Dimensions
    {
        get 
        {
            return GetElement<Dimensions>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> MeasureGroups.</para>
    /// <para> Represents the following element tag in the schema: x:measureGroups </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MeasureGroups MeasureGroups
    {
        get 
        {
            return GetElement<MeasureGroups>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Maps.</para>
    /// <para> Represents the following element tag in the schema: x:maps </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Maps Maps
    {
        get 
        {
            return GetElement<Maps>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> PivotCacheDefinitionExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotCacheDefinitionExtensionList PivotCacheDefinitionExtensionList
    {
        get 
        {
            return GetElement<PivotCacheDefinitionExtensionList>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "invalid" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "saveData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refreshOnLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "optimizeMemory" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "enableRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refreshedBy" == name)
    return new StringValue();
    
if( 0 == namespaceId && "refreshedDateIso" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "refreshedDate" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "backgroundQuery" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "missingItemsLimit" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "createdVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "refreshedVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "minRefreshableVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "recordCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "upgradeOnRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "tupleCache" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "supportSubquery" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "supportAdvancedDrill" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCacheDefinition>(deep);
    }

}
/// <summary>
/// <para>PivotCache Records. The root element of PivotTableCacheRecordsPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotCacheRecords.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotCacheRecord &lt;x:r></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotCacheRecord))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCacheRecords : OpenXmlPartRootElement
{
    private const string tagName = "pivotCacheRecords";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11098;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> PivotCache Records Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// PivotCacheRecords constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the PivotCacheRecords.</param>
    internal PivotCacheRecords(PivotTableCacheRecordsPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the PivotTableCacheRecordsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(PivotTableCacheRecordsPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the PivotTableCacheRecordsPart associated with this element.
    /// </summary>
    public PivotTableCacheRecordsPart PivotTableCacheRecordsPart
    {
		get
		{
			return OpenXmlPart as PivotTableCacheRecordsPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the PivotCacheRecords class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheRecords(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecords class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheRecords(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecords class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCacheRecords(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecords class.
    /// </summary>
    public PivotCacheRecords() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the PivotTableCacheRecordsPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(PivotTableCacheRecordsPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "r" == name)
    return new PivotCacheRecord();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCacheRecords>(deep);
    }

}
/// <summary>
/// <para>PivotTable Definition. The root element of PivotTablePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotTableDefinition.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Location &lt;x:location></description></item>
///<item><description>PivotFields &lt;x:pivotFields></description></item>
///<item><description>RowFields &lt;x:rowFields></description></item>
///<item><description>RowItems &lt;x:rowItems></description></item>
///<item><description>ColumnFields &lt;x:colFields></description></item>
///<item><description>ColumnItems &lt;x:colItems></description></item>
///<item><description>PageFields &lt;x:pageFields></description></item>
///<item><description>DataFields &lt;x:dataFields></description></item>
///<item><description>Formats &lt;x:formats></description></item>
///<item><description>ConditionalFormats &lt;x:conditionalFormats></description></item>
///<item><description>ChartFormats &lt;x:chartFormats></description></item>
///<item><description>PivotHierarchies &lt;x:pivotHierarchies></description></item>
///<item><description>PivotTableStyle &lt;x:pivotTableStyleInfo></description></item>
///<item><description>PivotFilters &lt;x:filters></description></item>
///<item><description>RowHierarchiesUsage &lt;x:rowHierarchiesUsage></description></item>
///<item><description>ColumnHierarchiesUsage &lt;x:colHierarchiesUsage></description></item>
///<item><description>PivotTableDefinitionExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Location))]
    [ChildElementInfo(typeof(PivotFields))]
    [ChildElementInfo(typeof(RowFields))]
    [ChildElementInfo(typeof(RowItems))]
    [ChildElementInfo(typeof(ColumnFields))]
    [ChildElementInfo(typeof(ColumnItems))]
    [ChildElementInfo(typeof(PageFields))]
    [ChildElementInfo(typeof(DataFields))]
    [ChildElementInfo(typeof(Formats))]
    [ChildElementInfo(typeof(ConditionalFormats))]
    [ChildElementInfo(typeof(ChartFormats))]
    [ChildElementInfo(typeof(PivotHierarchies))]
    [ChildElementInfo(typeof(PivotTableStyle))]
    [ChildElementInfo(typeof(PivotFilters))]
    [ChildElementInfo(typeof(RowHierarchiesUsage))]
    [ChildElementInfo(typeof(ColumnHierarchiesUsage))]
    [ChildElementInfo(typeof(PivotTableDefinitionExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotTableDefinition : OpenXmlPartRootElement
{
    private const string tagName = "pivotTableDefinition";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11099;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","cacheId","dataOnRows","dataPosition","autoFormatId","applyNumberFormats","applyBorderFormats","applyFontFormats","applyPatternFormats","applyAlignmentFormats","applyWidthHeightFormats","dataCaption","grandTotalCaption","errorCaption","showError","missingCaption","showMissing","pageStyle","pivotTableStyle","vacatedStyle","tag","updatedVersion","minRefreshableVersion","asteriskTotals","showItems","editData","disableFieldList","showCalcMbrs","visualTotals","showMultipleLabel","showDataDropDown","showDrill","printDrill","showMemberPropertyTips","showDataTips","enableWizard","enableDrill","enableFieldProperties","preserveFormatting","useAutoFormatting","pageWrap","pageOverThenDown","subtotalHiddenItems","rowGrandTotals","colGrandTotals","fieldPrintTitles","itemPrintTitles","mergeItem","showDropZones","createdVersion","indent","showEmptyRow","showEmptyCol","showHeaders","compact","outline","outlineData","compactData","published","gridDropZones","immersive","multipleFieldFilters","chartFormat","rowHeaderCaption","colHeaderCaption","fieldListSortAscending","mdxSubqueries","customListSort" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> cacheId.</para>
    /// <para>Represents the following attribute in the schema: cacheId </para>
    /// </summary>
    [SchemaAttr(0, "cacheId")]
    public UInt32Value CacheId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> dataOnRows.</para>
    /// <para>Represents the following attribute in the schema: dataOnRows </para>
    /// </summary>
    [SchemaAttr(0, "dataOnRows")]
    public BooleanValue DataOnRows
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> dataPosition.</para>
    /// <para>Represents the following attribute in the schema: dataPosition </para>
    /// </summary>
    [SchemaAttr(0, "dataPosition")]
    public UInt32Value DataPosition
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Auto Format Id.</para>
    /// <para>Represents the following attribute in the schema: autoFormatId </para>
    /// </summary>
    [SchemaAttr(0, "autoFormatId")]
    public UInt32Value AutoFormatId
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Apply Number Formats.</para>
    /// <para>Represents the following attribute in the schema: applyNumberFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyNumberFormats")]
    public BooleanValue ApplyNumberFormats
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Apply Border Formats.</para>
    /// <para>Represents the following attribute in the schema: applyBorderFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyBorderFormats")]
    public BooleanValue ApplyBorderFormats
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Apply Font Formats.</para>
    /// <para>Represents the following attribute in the schema: applyFontFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyFontFormats")]
    public BooleanValue ApplyFontFormats
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Apply Pattern Formats.</para>
    /// <para>Represents the following attribute in the schema: applyPatternFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyPatternFormats")]
    public BooleanValue ApplyPatternFormats
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Apply Alignment Formats.</para>
    /// <para>Represents the following attribute in the schema: applyAlignmentFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyAlignmentFormats")]
    public BooleanValue ApplyAlignmentFormats
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Apply Width / Height Formats.</para>
    /// <para>Represents the following attribute in the schema: applyWidthHeightFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyWidthHeightFormats")]
    public BooleanValue ApplyWidthHeightFormats
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> dataCaption.</para>
    /// <para>Represents the following attribute in the schema: dataCaption </para>
    /// </summary>
    [SchemaAttr(0, "dataCaption")]
    public StringValue DataCaption
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> grandTotalCaption.</para>
    /// <para>Represents the following attribute in the schema: grandTotalCaption </para>
    /// </summary>
    [SchemaAttr(0, "grandTotalCaption")]
    public StringValue GrandTotalCaption
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> errorCaption.</para>
    /// <para>Represents the following attribute in the schema: errorCaption </para>
    /// </summary>
    [SchemaAttr(0, "errorCaption")]
    public StringValue ErrorCaption
    {
        get { return (StringValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> showError.</para>
    /// <para>Represents the following attribute in the schema: showError </para>
    /// </summary>
    [SchemaAttr(0, "showError")]
    public BooleanValue ShowError
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> missingCaption.</para>
    /// <para>Represents the following attribute in the schema: missingCaption </para>
    /// </summary>
    [SchemaAttr(0, "missingCaption")]
    public StringValue MissingCaption
    {
        get { return (StringValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> showMissing.</para>
    /// <para>Represents the following attribute in the schema: showMissing </para>
    /// </summary>
    [SchemaAttr(0, "showMissing")]
    public BooleanValue ShowMissing
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> pageStyle.</para>
    /// <para>Represents the following attribute in the schema: pageStyle </para>
    /// </summary>
    [SchemaAttr(0, "pageStyle")]
    public StringValue PageStyle
    {
        get { return (StringValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> pivotTableStyle.</para>
    /// <para>Represents the following attribute in the schema: pivotTableStyle </para>
    /// </summary>
    [SchemaAttr(0, "pivotTableStyle")]
    public StringValue PivotTableStyleName
    {
        get { return (StringValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> vacatedStyle.</para>
    /// <para>Represents the following attribute in the schema: vacatedStyle </para>
    /// </summary>
    [SchemaAttr(0, "vacatedStyle")]
    public StringValue VacatedStyle
    {
        get { return (StringValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> tag.</para>
    /// <para>Represents the following attribute in the schema: tag </para>
    /// </summary>
    [SchemaAttr(0, "tag")]
    public StringValue Tag
    {
        get { return (StringValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> updatedVersion.</para>
    /// <para>Represents the following attribute in the schema: updatedVersion </para>
    /// </summary>
    [SchemaAttr(0, "updatedVersion")]
    public ByteValue UpdatedVersion
    {
        get { return (ByteValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    
    /// <summary>
    /// <para> minRefreshableVersion.</para>
    /// <para>Represents the following attribute in the schema: minRefreshableVersion </para>
    /// </summary>
    [SchemaAttr(0, "minRefreshableVersion")]
    public ByteValue MinRefreshableVersion
    {
        get { return (ByteValue)Attributes[22]; }
        set { Attributes[22] = value; }
    }
    
    /// <summary>
    /// <para> asteriskTotals.</para>
    /// <para>Represents the following attribute in the schema: asteriskTotals </para>
    /// </summary>
    [SchemaAttr(0, "asteriskTotals")]
    public BooleanValue AsteriskTotals
    {
        get { return (BooleanValue)Attributes[23]; }
        set { Attributes[23] = value; }
    }
    
    /// <summary>
    /// <para> showItems.</para>
    /// <para>Represents the following attribute in the schema: showItems </para>
    /// </summary>
    [SchemaAttr(0, "showItems")]
    public BooleanValue ShowItems
    {
        get { return (BooleanValue)Attributes[24]; }
        set { Attributes[24] = value; }
    }
    
    /// <summary>
    /// <para> editData.</para>
    /// <para>Represents the following attribute in the schema: editData </para>
    /// </summary>
    [SchemaAttr(0, "editData")]
    public BooleanValue EditData
    {
        get { return (BooleanValue)Attributes[25]; }
        set { Attributes[25] = value; }
    }
    
    /// <summary>
    /// <para> disableFieldList.</para>
    /// <para>Represents the following attribute in the schema: disableFieldList </para>
    /// </summary>
    [SchemaAttr(0, "disableFieldList")]
    public BooleanValue DisableFieldList
    {
        get { return (BooleanValue)Attributes[26]; }
        set { Attributes[26] = value; }
    }
    
    /// <summary>
    /// <para> showCalcMbrs.</para>
    /// <para>Represents the following attribute in the schema: showCalcMbrs </para>
    /// </summary>
    [SchemaAttr(0, "showCalcMbrs")]
    public BooleanValue ShowCalculatedMembers
    {
        get { return (BooleanValue)Attributes[27]; }
        set { Attributes[27] = value; }
    }
    
    /// <summary>
    /// <para> visualTotals.</para>
    /// <para>Represents the following attribute in the schema: visualTotals </para>
    /// </summary>
    [SchemaAttr(0, "visualTotals")]
    public BooleanValue VisualTotals
    {
        get { return (BooleanValue)Attributes[28]; }
        set { Attributes[28] = value; }
    }
    
    /// <summary>
    /// <para> showMultipleLabel.</para>
    /// <para>Represents the following attribute in the schema: showMultipleLabel </para>
    /// </summary>
    [SchemaAttr(0, "showMultipleLabel")]
    public BooleanValue ShowMultipleLabel
    {
        get { return (BooleanValue)Attributes[29]; }
        set { Attributes[29] = value; }
    }
    
    /// <summary>
    /// <para> showDataDropDown.</para>
    /// <para>Represents the following attribute in the schema: showDataDropDown </para>
    /// </summary>
    [SchemaAttr(0, "showDataDropDown")]
    public BooleanValue ShowDataDropDown
    {
        get { return (BooleanValue)Attributes[30]; }
        set { Attributes[30] = value; }
    }
    
    /// <summary>
    /// <para> showDrill.</para>
    /// <para>Represents the following attribute in the schema: showDrill </para>
    /// </summary>
    [SchemaAttr(0, "showDrill")]
    public BooleanValue ShowDrill
    {
        get { return (BooleanValue)Attributes[31]; }
        set { Attributes[31] = value; }
    }
    
    /// <summary>
    /// <para> printDrill.</para>
    /// <para>Represents the following attribute in the schema: printDrill </para>
    /// </summary>
    [SchemaAttr(0, "printDrill")]
    public BooleanValue PrintDrill
    {
        get { return (BooleanValue)Attributes[32]; }
        set { Attributes[32] = value; }
    }
    
    /// <summary>
    /// <para> showMemberPropertyTips.</para>
    /// <para>Represents the following attribute in the schema: showMemberPropertyTips </para>
    /// </summary>
    [SchemaAttr(0, "showMemberPropertyTips")]
    public BooleanValue ShowMemberPropertyTips
    {
        get { return (BooleanValue)Attributes[33]; }
        set { Attributes[33] = value; }
    }
    
    /// <summary>
    /// <para> showDataTips.</para>
    /// <para>Represents the following attribute in the schema: showDataTips </para>
    /// </summary>
    [SchemaAttr(0, "showDataTips")]
    public BooleanValue ShowDataTips
    {
        get { return (BooleanValue)Attributes[34]; }
        set { Attributes[34] = value; }
    }
    
    /// <summary>
    /// <para> enableWizard.</para>
    /// <para>Represents the following attribute in the schema: enableWizard </para>
    /// </summary>
    [SchemaAttr(0, "enableWizard")]
    public BooleanValue EnableWizard
    {
        get { return (BooleanValue)Attributes[35]; }
        set { Attributes[35] = value; }
    }
    
    /// <summary>
    /// <para> enableDrill.</para>
    /// <para>Represents the following attribute in the schema: enableDrill </para>
    /// </summary>
    [SchemaAttr(0, "enableDrill")]
    public BooleanValue EnableDrill
    {
        get { return (BooleanValue)Attributes[36]; }
        set { Attributes[36] = value; }
    }
    
    /// <summary>
    /// <para> enableFieldProperties.</para>
    /// <para>Represents the following attribute in the schema: enableFieldProperties </para>
    /// </summary>
    [SchemaAttr(0, "enableFieldProperties")]
    public BooleanValue EnableFieldProperties
    {
        get { return (BooleanValue)Attributes[37]; }
        set { Attributes[37] = value; }
    }
    
    /// <summary>
    /// <para> preserveFormatting.</para>
    /// <para>Represents the following attribute in the schema: preserveFormatting </para>
    /// </summary>
    [SchemaAttr(0, "preserveFormatting")]
    public BooleanValue PreserveFormatting
    {
        get { return (BooleanValue)Attributes[38]; }
        set { Attributes[38] = value; }
    }
    
    /// <summary>
    /// <para> useAutoFormatting.</para>
    /// <para>Represents the following attribute in the schema: useAutoFormatting </para>
    /// </summary>
    [SchemaAttr(0, "useAutoFormatting")]
    public BooleanValue UseAutoFormatting
    {
        get { return (BooleanValue)Attributes[39]; }
        set { Attributes[39] = value; }
    }
    
    /// <summary>
    /// <para> pageWrap.</para>
    /// <para>Represents the following attribute in the schema: pageWrap </para>
    /// </summary>
    [SchemaAttr(0, "pageWrap")]
    public UInt32Value PageWrap
    {
        get { return (UInt32Value)Attributes[40]; }
        set { Attributes[40] = value; }
    }
    
    /// <summary>
    /// <para> pageOverThenDown.</para>
    /// <para>Represents the following attribute in the schema: pageOverThenDown </para>
    /// </summary>
    [SchemaAttr(0, "pageOverThenDown")]
    public BooleanValue PageOverThenDown
    {
        get { return (BooleanValue)Attributes[41]; }
        set { Attributes[41] = value; }
    }
    
    /// <summary>
    /// <para> subtotalHiddenItems.</para>
    /// <para>Represents the following attribute in the schema: subtotalHiddenItems </para>
    /// </summary>
    [SchemaAttr(0, "subtotalHiddenItems")]
    public BooleanValue SubtotalHiddenItems
    {
        get { return (BooleanValue)Attributes[42]; }
        set { Attributes[42] = value; }
    }
    
    /// <summary>
    /// <para> rowGrandTotals.</para>
    /// <para>Represents the following attribute in the schema: rowGrandTotals </para>
    /// </summary>
    [SchemaAttr(0, "rowGrandTotals")]
    public BooleanValue RowGrandTotals
    {
        get { return (BooleanValue)Attributes[43]; }
        set { Attributes[43] = value; }
    }
    
    /// <summary>
    /// <para> colGrandTotals.</para>
    /// <para>Represents the following attribute in the schema: colGrandTotals </para>
    /// </summary>
    [SchemaAttr(0, "colGrandTotals")]
    public BooleanValue ColumnGrandTotals
    {
        get { return (BooleanValue)Attributes[44]; }
        set { Attributes[44] = value; }
    }
    
    /// <summary>
    /// <para> fieldPrintTitles.</para>
    /// <para>Represents the following attribute in the schema: fieldPrintTitles </para>
    /// </summary>
    [SchemaAttr(0, "fieldPrintTitles")]
    public BooleanValue FieldPrintTitles
    {
        get { return (BooleanValue)Attributes[45]; }
        set { Attributes[45] = value; }
    }
    
    /// <summary>
    /// <para> itemPrintTitles.</para>
    /// <para>Represents the following attribute in the schema: itemPrintTitles </para>
    /// </summary>
    [SchemaAttr(0, "itemPrintTitles")]
    public BooleanValue ItemPrintTitles
    {
        get { return (BooleanValue)Attributes[46]; }
        set { Attributes[46] = value; }
    }
    
    /// <summary>
    /// <para> mergeItem.</para>
    /// <para>Represents the following attribute in the schema: mergeItem </para>
    /// </summary>
    [SchemaAttr(0, "mergeItem")]
    public BooleanValue MergeItem
    {
        get { return (BooleanValue)Attributes[47]; }
        set { Attributes[47] = value; }
    }
    
    /// <summary>
    /// <para> showDropZones.</para>
    /// <para>Represents the following attribute in the schema: showDropZones </para>
    /// </summary>
    [SchemaAttr(0, "showDropZones")]
    public BooleanValue ShowDropZones
    {
        get { return (BooleanValue)Attributes[48]; }
        set { Attributes[48] = value; }
    }
    
    /// <summary>
    /// <para> createdVersion.</para>
    /// <para>Represents the following attribute in the schema: createdVersion </para>
    /// </summary>
    [SchemaAttr(0, "createdVersion")]
    public ByteValue CreatedVersion
    {
        get { return (ByteValue)Attributes[49]; }
        set { Attributes[49] = value; }
    }
    
    /// <summary>
    /// <para> indent.</para>
    /// <para>Represents the following attribute in the schema: indent </para>
    /// </summary>
    [SchemaAttr(0, "indent")]
    public UInt32Value Indent
    {
        get { return (UInt32Value)Attributes[50]; }
        set { Attributes[50] = value; }
    }
    
    /// <summary>
    /// <para> showEmptyRow.</para>
    /// <para>Represents the following attribute in the schema: showEmptyRow </para>
    /// </summary>
    [SchemaAttr(0, "showEmptyRow")]
    public BooleanValue ShowEmptyRow
    {
        get { return (BooleanValue)Attributes[51]; }
        set { Attributes[51] = value; }
    }
    
    /// <summary>
    /// <para> showEmptyCol.</para>
    /// <para>Represents the following attribute in the schema: showEmptyCol </para>
    /// </summary>
    [SchemaAttr(0, "showEmptyCol")]
    public BooleanValue ShowEmptyColumn
    {
        get { return (BooleanValue)Attributes[52]; }
        set { Attributes[52] = value; }
    }
    
    /// <summary>
    /// <para> showHeaders.</para>
    /// <para>Represents the following attribute in the schema: showHeaders </para>
    /// </summary>
    [SchemaAttr(0, "showHeaders")]
    public BooleanValue ShowHeaders
    {
        get { return (BooleanValue)Attributes[53]; }
        set { Attributes[53] = value; }
    }
    
    /// <summary>
    /// <para> compact.</para>
    /// <para>Represents the following attribute in the schema: compact </para>
    /// </summary>
    [SchemaAttr(0, "compact")]
    public BooleanValue Compact
    {
        get { return (BooleanValue)Attributes[54]; }
        set { Attributes[54] = value; }
    }
    
    /// <summary>
    /// <para> outline.</para>
    /// <para>Represents the following attribute in the schema: outline </para>
    /// </summary>
    [SchemaAttr(0, "outline")]
    public BooleanValue Outline
    {
        get { return (BooleanValue)Attributes[55]; }
        set { Attributes[55] = value; }
    }
    
    /// <summary>
    /// <para> outlineData.</para>
    /// <para>Represents the following attribute in the schema: outlineData </para>
    /// </summary>
    [SchemaAttr(0, "outlineData")]
    public BooleanValue OutlineData
    {
        get { return (BooleanValue)Attributes[56]; }
        set { Attributes[56] = value; }
    }
    
    /// <summary>
    /// <para> compactData.</para>
    /// <para>Represents the following attribute in the schema: compactData </para>
    /// </summary>
    [SchemaAttr(0, "compactData")]
    public BooleanValue CompactData
    {
        get { return (BooleanValue)Attributes[57]; }
        set { Attributes[57] = value; }
    }
    
    /// <summary>
    /// <para> published.</para>
    /// <para>Represents the following attribute in the schema: published </para>
    /// </summary>
    [SchemaAttr(0, "published")]
    public BooleanValue Published
    {
        get { return (BooleanValue)Attributes[58]; }
        set { Attributes[58] = value; }
    }
    
    /// <summary>
    /// <para> gridDropZones.</para>
    /// <para>Represents the following attribute in the schema: gridDropZones </para>
    /// </summary>
    [SchemaAttr(0, "gridDropZones")]
    public BooleanValue GridDropZones
    {
        get { return (BooleanValue)Attributes[59]; }
        set { Attributes[59] = value; }
    }
    
    /// <summary>
    /// <para> immersive.</para>
    /// <para>Represents the following attribute in the schema: immersive </para>
    /// </summary>
    [SchemaAttr(0, "immersive")]
    public BooleanValue StopImmersiveUi
    {
        get { return (BooleanValue)Attributes[60]; }
        set { Attributes[60] = value; }
    }
    
    /// <summary>
    /// <para> multipleFieldFilters.</para>
    /// <para>Represents the following attribute in the schema: multipleFieldFilters </para>
    /// </summary>
    [SchemaAttr(0, "multipleFieldFilters")]
    public BooleanValue MultipleFieldFilters
    {
        get { return (BooleanValue)Attributes[61]; }
        set { Attributes[61] = value; }
    }
    
    /// <summary>
    /// <para> chartFormat.</para>
    /// <para>Represents the following attribute in the schema: chartFormat </para>
    /// </summary>
    [SchemaAttr(0, "chartFormat")]
    public UInt32Value ChartFormat
    {
        get { return (UInt32Value)Attributes[62]; }
        set { Attributes[62] = value; }
    }
    
    /// <summary>
    /// <para> rowHeaderCaption.</para>
    /// <para>Represents the following attribute in the schema: rowHeaderCaption </para>
    /// </summary>
    [SchemaAttr(0, "rowHeaderCaption")]
    public StringValue RowHeaderCaption
    {
        get { return (StringValue)Attributes[63]; }
        set { Attributes[63] = value; }
    }
    
    /// <summary>
    /// <para> colHeaderCaption.</para>
    /// <para>Represents the following attribute in the schema: colHeaderCaption </para>
    /// </summary>
    [SchemaAttr(0, "colHeaderCaption")]
    public StringValue ColumnHeaderCaption
    {
        get { return (StringValue)Attributes[64]; }
        set { Attributes[64] = value; }
    }
    
    /// <summary>
    /// <para> fieldListSortAscending.</para>
    /// <para>Represents the following attribute in the schema: fieldListSortAscending </para>
    /// </summary>
    [SchemaAttr(0, "fieldListSortAscending")]
    public BooleanValue FieldListSortAscending
    {
        get { return (BooleanValue)Attributes[65]; }
        set { Attributes[65] = value; }
    }
    
    /// <summary>
    /// <para> mdxSubqueries.</para>
    /// <para>Represents the following attribute in the schema: mdxSubqueries </para>
    /// </summary>
    [SchemaAttr(0, "mdxSubqueries")]
    public BooleanValue MdxSubqueries
    {
        get { return (BooleanValue)Attributes[66]; }
        set { Attributes[66] = value; }
    }
    
    /// <summary>
    /// <para> customListSort.</para>
    /// <para>Represents the following attribute in the schema: customListSort </para>
    /// </summary>
    [SchemaAttr(0, "customListSort")]
    public BooleanValue CustomListSort
    {
        get { return (BooleanValue)Attributes[67]; }
        set { Attributes[67] = value; }
    }
    

    
    /// <summary>
    /// PivotTableDefinition constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the PivotTableDefinition.</param>
    internal PivotTableDefinition(PivotTablePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the PivotTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(PivotTablePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the PivotTablePart associated with this element.
    /// </summary>
    public PivotTablePart PivotTablePart
    {
		get
		{
			return OpenXmlPart as PivotTablePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the PivotTableDefinition class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinition(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinition class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinition(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinition class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotTableDefinition(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinition class.
    /// </summary>
    public PivotTableDefinition() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the PivotTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(PivotTablePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "location" == name)
    return new Location();
    
if( 22 == namespaceId && "pivotFields" == name)
    return new PivotFields();
    
if( 22 == namespaceId && "rowFields" == name)
    return new RowFields();
    
if( 22 == namespaceId && "rowItems" == name)
    return new RowItems();
    
if( 22 == namespaceId && "colFields" == name)
    return new ColumnFields();
    
if( 22 == namespaceId && "colItems" == name)
    return new ColumnItems();
    
if( 22 == namespaceId && "pageFields" == name)
    return new PageFields();
    
if( 22 == namespaceId && "dataFields" == name)
    return new DataFields();
    
if( 22 == namespaceId && "formats" == name)
    return new Formats();
    
if( 22 == namespaceId && "conditionalFormats" == name)
    return new ConditionalFormats();
    
if( 22 == namespaceId && "chartFormats" == name)
    return new ChartFormats();
    
if( 22 == namespaceId && "pivotHierarchies" == name)
    return new PivotHierarchies();
    
if( 22 == namespaceId && "pivotTableStyleInfo" == name)
    return new PivotTableStyle();
    
if( 22 == namespaceId && "filters" == name)
    return new PivotFilters();
    
if( 22 == namespaceId && "rowHierarchiesUsage" == name)
    return new RowHierarchiesUsage();
    
if( 22 == namespaceId && "colHierarchiesUsage" == name)
    return new ColumnHierarchiesUsage();
    
if( 22 == namespaceId && "extLst" == name)
    return new PivotTableDefinitionExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "location","pivotFields","rowFields","rowItems","colFields","colItems","pageFields","dataFields","formats","conditionalFormats","chartFormats","pivotHierarchies","pivotTableStyleInfo","filters","rowHierarchiesUsage","colHierarchiesUsage","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Location.</para>
    /// <para> Represents the following element tag in the schema: x:location </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Location Location
    {
        get 
        {
            return GetElement<Location>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> PivotFields.</para>
    /// <para> Represents the following element tag in the schema: x:pivotFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotFields PivotFields
    {
        get 
        {
            return GetElement<PivotFields>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> RowFields.</para>
    /// <para> Represents the following element tag in the schema: x:rowFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RowFields RowFields
    {
        get 
        {
            return GetElement<RowFields>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> RowItems.</para>
    /// <para> Represents the following element tag in the schema: x:rowItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RowItems RowItems
    {
        get 
        {
            return GetElement<RowItems>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ColumnFields.</para>
    /// <para> Represents the following element tag in the schema: x:colFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ColumnFields ColumnFields
    {
        get 
        {
            return GetElement<ColumnFields>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> ColumnItems.</para>
    /// <para> Represents the following element tag in the schema: x:colItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ColumnItems ColumnItems
    {
        get 
        {
            return GetElement<ColumnItems>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> PageFields.</para>
    /// <para> Represents the following element tag in the schema: x:pageFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageFields PageFields
    {
        get 
        {
            return GetElement<PageFields>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> DataFields.</para>
    /// <para> Represents the following element tag in the schema: x:dataFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DataFields DataFields
    {
        get 
        {
            return GetElement<DataFields>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Formats.</para>
    /// <para> Represents the following element tag in the schema: x:formats </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Formats Formats
    {
        get 
        {
            return GetElement<Formats>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> ConditionalFormats.</para>
    /// <para> Represents the following element tag in the schema: x:conditionalFormats </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ConditionalFormats ConditionalFormats
    {
        get 
        {
            return GetElement<ConditionalFormats>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> ChartFormats.</para>
    /// <para> Represents the following element tag in the schema: x:chartFormats </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartFormats ChartFormats
    {
        get 
        {
            return GetElement<ChartFormats>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> PivotHierarchies.</para>
    /// <para> Represents the following element tag in the schema: x:pivotHierarchies </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotHierarchies PivotHierarchies
    {
        get 
        {
            return GetElement<PivotHierarchies>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> PivotTableStyle.</para>
    /// <para> Represents the following element tag in the schema: x:pivotTableStyleInfo </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotTableStyle PivotTableStyle
    {
        get 
        {
            return GetElement<PivotTableStyle>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> PivotFilters.</para>
    /// <para> Represents the following element tag in the schema: x:filters </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotFilters PivotFilters
    {
        get 
        {
            return GetElement<PivotFilters>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> RowHierarchiesUsage.</para>
    /// <para> Represents the following element tag in the schema: x:rowHierarchiesUsage </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RowHierarchiesUsage RowHierarchiesUsage
    {
        get 
        {
            return GetElement<RowHierarchiesUsage>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> ColumnHierarchiesUsage.</para>
    /// <para> Represents the following element tag in the schema: x:colHierarchiesUsage </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ColumnHierarchiesUsage ColumnHierarchiesUsage
    {
        get 
        {
            return GetElement<ColumnHierarchiesUsage>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }
    /// <summary>
    /// <para> PivotTableDefinitionExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotTableDefinitionExtensionList PivotTableDefinitionExtensionList
    {
        get 
        {
            return GetElement<PivotTableDefinitionExtensionList>(16);
        }
        set
        {
            SetElement(16, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cacheId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "dataOnRows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dataPosition" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "autoFormatId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "applyNumberFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyBorderFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyFontFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyPatternFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyAlignmentFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyWidthHeightFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dataCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "grandTotalCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "errorCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showError" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "missingCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showMissing" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pageStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "pivotTableStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "vacatedStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tag" == name)
    return new StringValue();
    
if( 0 == namespaceId && "updatedVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "minRefreshableVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "asteriskTotals" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showItems" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "editData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disableFieldList" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showCalcMbrs" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "visualTotals" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showMultipleLabel" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showDataDropDown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showDrill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "printDrill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showMemberPropertyTips" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showDataTips" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "enableWizard" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "enableDrill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "enableFieldProperties" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "preserveFormatting" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "useAutoFormatting" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pageWrap" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "pageOverThenDown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "subtotalHiddenItems" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowGrandTotals" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "colGrandTotals" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fieldPrintTitles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "itemPrintTitles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "mergeItem" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showDropZones" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "createdVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "indent" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "showEmptyRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showEmptyCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showHeaders" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "compact" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outline" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outlineData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "compactData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "published" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "gridDropZones" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "immersive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "multipleFieldFilters" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "chartFormat" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rowHeaderCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "colHeaderCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "fieldListSortAscending" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "mdxSubqueries" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customListSort" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotTableDefinition>(deep);
    }

}
/// <summary>
/// <para>Query Table. The root element of QueryTablePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryTable.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>QueryTableRefresh &lt;x:queryTableRefresh></description></item>
///<item><description>QueryTableExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(QueryTableRefresh))]
    [ChildElementInfo(typeof(QueryTableExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTable : OpenXmlPartRootElement
{
    private const string tagName = "queryTable";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11100;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","headers","rowNumbers","disableRefresh","backgroundRefresh","firstBackgroundRefresh","refreshOnLoad","growShrinkType","fillFormulas","removeDataOnSave","disableEdit","preserveFormatting","adjustColumnWidth","intermediate","connectionId","autoFormatId","applyNumberFormats","applyBorderFormats","applyFontFormats","applyPatternFormats","applyAlignmentFormats","applyWidthHeightFormats" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> headers.</para>
    /// <para>Represents the following attribute in the schema: headers </para>
    /// </summary>
    [SchemaAttr(0, "headers")]
    public BooleanValue Headers
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> rowNumbers.</para>
    /// <para>Represents the following attribute in the schema: rowNumbers </para>
    /// </summary>
    [SchemaAttr(0, "rowNumbers")]
    public BooleanValue RowNumbers
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> disableRefresh.</para>
    /// <para>Represents the following attribute in the schema: disableRefresh </para>
    /// </summary>
    [SchemaAttr(0, "disableRefresh")]
    public BooleanValue DisableRefresh
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> backgroundRefresh.</para>
    /// <para>Represents the following attribute in the schema: backgroundRefresh </para>
    /// </summary>
    [SchemaAttr(0, "backgroundRefresh")]
    public BooleanValue BackgroundRefresh
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> firstBackgroundRefresh.</para>
    /// <para>Represents the following attribute in the schema: firstBackgroundRefresh </para>
    /// </summary>
    [SchemaAttr(0, "firstBackgroundRefresh")]
    public BooleanValue FirstBackgroundRefresh
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> refreshOnLoad.</para>
    /// <para>Represents the following attribute in the schema: refreshOnLoad </para>
    /// </summary>
    [SchemaAttr(0, "refreshOnLoad")]
    public BooleanValue RefreshOnLoad
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> growShrinkType.</para>
    /// <para>Represents the following attribute in the schema: growShrinkType </para>
    /// </summary>
    [SchemaAttr(0, "growShrinkType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GrowShrinkValues> GrowShrinkType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.GrowShrinkValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> fillFormulas.</para>
    /// <para>Represents the following attribute in the schema: fillFormulas </para>
    /// </summary>
    [SchemaAttr(0, "fillFormulas")]
    public BooleanValue FillFormulas
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> removeDataOnSave.</para>
    /// <para>Represents the following attribute in the schema: removeDataOnSave </para>
    /// </summary>
    [SchemaAttr(0, "removeDataOnSave")]
    public BooleanValue RemoveDataOnSave
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> disableEdit.</para>
    /// <para>Represents the following attribute in the schema: disableEdit </para>
    /// </summary>
    [SchemaAttr(0, "disableEdit")]
    public BooleanValue DisableEdit
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> preserveFormatting.</para>
    /// <para>Represents the following attribute in the schema: preserveFormatting </para>
    /// </summary>
    [SchemaAttr(0, "preserveFormatting")]
    public BooleanValue PreserveFormatting
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> adjustColumnWidth.</para>
    /// <para>Represents the following attribute in the schema: adjustColumnWidth </para>
    /// </summary>
    [SchemaAttr(0, "adjustColumnWidth")]
    public BooleanValue AdjustColumnWidth
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> intermediate.</para>
    /// <para>Represents the following attribute in the schema: intermediate </para>
    /// </summary>
    [SchemaAttr(0, "intermediate")]
    public BooleanValue Intermediate
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> connectionId.</para>
    /// <para>Represents the following attribute in the schema: connectionId </para>
    /// </summary>
    [SchemaAttr(0, "connectionId")]
    public UInt32Value ConnectionId
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Auto Format Id.</para>
    /// <para>Represents the following attribute in the schema: autoFormatId </para>
    /// </summary>
    [SchemaAttr(0, "autoFormatId")]
    public UInt32Value AutoFormatId
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Apply Number Formats.</para>
    /// <para>Represents the following attribute in the schema: applyNumberFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyNumberFormats")]
    public BooleanValue ApplyNumberFormats
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Apply Border Formats.</para>
    /// <para>Represents the following attribute in the schema: applyBorderFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyBorderFormats")]
    public BooleanValue ApplyBorderFormats
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Apply Font Formats.</para>
    /// <para>Represents the following attribute in the schema: applyFontFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyFontFormats")]
    public BooleanValue ApplyFontFormats
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Apply Pattern Formats.</para>
    /// <para>Represents the following attribute in the schema: applyPatternFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyPatternFormats")]
    public BooleanValue ApplyPatternFormats
    {
        get { return (BooleanValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Apply Alignment Formats.</para>
    /// <para>Represents the following attribute in the schema: applyAlignmentFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyAlignmentFormats")]
    public BooleanValue ApplyAlignmentFormats
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Apply Width / Height Formats.</para>
    /// <para>Represents the following attribute in the schema: applyWidthHeightFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyWidthHeightFormats")]
    public BooleanValue ApplyWidthHeightFormats
    {
        get { return (BooleanValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    

    
    /// <summary>
    /// QueryTable constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the QueryTable.</param>
    internal QueryTable(QueryTablePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the QueryTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(QueryTablePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the QueryTablePart associated with this element.
    /// </summary>
    public QueryTablePart QueryTablePart
    {
		get
		{
			return OpenXmlPart as QueryTablePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the QueryTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTable(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTable(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTable class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTable(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the QueryTable class.
    /// </summary>
    public QueryTable() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the QueryTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(QueryTablePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "queryTableRefresh" == name)
    return new QueryTableRefresh();
    
if( 22 == namespaceId && "extLst" == name)
    return new QueryTableExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "queryTableRefresh","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> QueryTableRefresh.</para>
    /// <para> Represents the following element tag in the schema: x:queryTableRefresh </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public QueryTableRefresh QueryTableRefresh
    {
        get 
        {
            return GetElement<QueryTableRefresh>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> QueryTableExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public QueryTableExtensionList QueryTableExtensionList
    {
        get 
        {
            return GetElement<QueryTableExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "headers" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowNumbers" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disableRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "backgroundRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "firstBackgroundRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refreshOnLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "growShrinkType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.GrowShrinkValues>();
    
if( 0 == namespaceId && "fillFormulas" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "removeDataOnSave" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disableEdit" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "preserveFormatting" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "adjustColumnWidth" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "intermediate" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "connectionId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "autoFormatId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "applyNumberFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyBorderFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyFontFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyPatternFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyAlignmentFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyWidthHeightFormats" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTable>(deep);
    }

}
/// <summary>
/// <para>Shared String Table. The root element of SharedStringTablePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SharedStringItem &lt;x:si></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SharedStringItem))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SharedStringTable : OpenXmlPartRootElement
{
    private const string tagName = "sst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11101;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count","uniqueCount" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> String Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unique String Count.</para>
    /// <para>Represents the following attribute in the schema: uniqueCount </para>
    /// </summary>
    [SchemaAttr(0, "uniqueCount")]
    public UInt32Value UniqueCount
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    /// <summary>
    /// SharedStringTable constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the SharedStringTable.</param>
    internal SharedStringTable(SharedStringTablePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the SharedStringTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(SharedStringTablePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the SharedStringTablePart associated with this element.
    /// </summary>
    public SharedStringTablePart SharedStringTablePart
    {
		get
		{
			return OpenXmlPart as SharedStringTablePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the SharedStringTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedStringTable(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedStringTable class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedStringTable(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedStringTable class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SharedStringTable(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the SharedStringTable class.
    /// </summary>
    public SharedStringTable() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the SharedStringTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(SharedStringTablePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "si" == name)
    return new SharedStringItem();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "uniqueCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SharedStringTable>(deep);
    }

}
/// <summary>
/// <para>Revision Headers. The root element of WorkbookRevisionHeaderPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:headers.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Header &lt;x:header></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Header))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Headers : OpenXmlPartRootElement
{
    private const string tagName = "headers";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11102;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","lastGuid","shared","diskRevisions","history","trackRevisions","exclusive","revisionId","version","keepChangeHistory","protected","preserveHistory" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Last Revision GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Last GUID.</para>
    /// <para>Represents the following attribute in the schema: lastGuid </para>
    /// </summary>
    [SchemaAttr(0, "lastGuid")]
    public StringValue LastGuid
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Shared Workbook.</para>
    /// <para>Represents the following attribute in the schema: shared </para>
    /// </summary>
    [SchemaAttr(0, "shared")]
    public BooleanValue Shared
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Disk Revisions.</para>
    /// <para>Represents the following attribute in the schema: diskRevisions </para>
    /// </summary>
    [SchemaAttr(0, "diskRevisions")]
    public BooleanValue DiskRevisions
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> History.</para>
    /// <para>Represents the following attribute in the schema: history </para>
    /// </summary>
    [SchemaAttr(0, "history")]
    public BooleanValue History
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Track Revisions.</para>
    /// <para>Represents the following attribute in the schema: trackRevisions </para>
    /// </summary>
    [SchemaAttr(0, "trackRevisions")]
    public BooleanValue TrackRevisions
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Exclusive Mode.</para>
    /// <para>Represents the following attribute in the schema: exclusive </para>
    /// </summary>
    [SchemaAttr(0, "exclusive")]
    public BooleanValue Exclusive
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: revisionId </para>
    /// </summary>
    [SchemaAttr(0, "revisionId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Version.</para>
    /// <para>Represents the following attribute in the schema: version </para>
    /// </summary>
    [SchemaAttr(0, "version")]
    public Int32Value Version
    {
        get { return (Int32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Keep Change History.</para>
    /// <para>Represents the following attribute in the schema: keepChangeHistory </para>
    /// </summary>
    [SchemaAttr(0, "keepChangeHistory")]
    public BooleanValue KeepChangeHistory
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Protected.</para>
    /// <para>Represents the following attribute in the schema: protected </para>
    /// </summary>
    [SchemaAttr(0, "protected")]
    public BooleanValue Protected
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Preserve History.</para>
    /// <para>Represents the following attribute in the schema: preserveHistory </para>
    /// </summary>
    [SchemaAttr(0, "preserveHistory")]
    public UInt32Value PreserveHistory
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    
    /// <summary>
    /// Headers constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Headers.</param>
    internal Headers(WorkbookRevisionHeaderPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorkbookRevisionHeaderPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorkbookRevisionHeaderPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorkbookRevisionHeaderPart associated with this element.
    /// </summary>
    public WorkbookRevisionHeaderPart WorkbookRevisionHeaderPart
    {
		get
		{
			return OpenXmlPart as WorkbookRevisionHeaderPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Headers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Headers(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Headers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Headers(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Headers class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Headers(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Headers class.
    /// </summary>
    public Headers() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorkbookRevisionHeaderPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorkbookRevisionHeaderPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "header" == name)
    return new Header();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "lastGuid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "shared" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "diskRevisions" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "history" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "trackRevisions" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "exclusive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "revisionId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "version" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "keepChangeHistory" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "protected" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "preserveHistory" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Headers>(deep);
    }

}
/// <summary>
/// <para>Revisions. The root element of WorkbookRevisionLogPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:revisions.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RevisionRowColumn &lt;x:rrc></description></item>
///<item><description>RevisionMove &lt;x:rm></description></item>
///<item><description>RevisionCustomView &lt;x:rcv></description></item>
///<item><description>RevisionSheetName &lt;x:rsnm></description></item>
///<item><description>RevisionInsertSheet &lt;x:ris></description></item>
///<item><description>RevisionCellChange &lt;x:rcc></description></item>
///<item><description>RevisionFormat &lt;x:rfmt></description></item>
///<item><description>RevisionAutoFormat &lt;x:raf></description></item>
///<item><description>RevisionDefinedName &lt;x:rdn></description></item>
///<item><description>RevisionComment &lt;x:rcmt></description></item>
///<item><description>RevisionQueryTable &lt;x:rqt></description></item>
///<item><description>RevisionConflict &lt;x:rcft></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RevisionRowColumn))]
    [ChildElementInfo(typeof(RevisionMove))]
    [ChildElementInfo(typeof(RevisionCustomView))]
    [ChildElementInfo(typeof(RevisionSheetName))]
    [ChildElementInfo(typeof(RevisionInsertSheet))]
    [ChildElementInfo(typeof(RevisionCellChange))]
    [ChildElementInfo(typeof(RevisionFormat))]
    [ChildElementInfo(typeof(RevisionAutoFormat))]
    [ChildElementInfo(typeof(RevisionDefinedName))]
    [ChildElementInfo(typeof(RevisionComment))]
    [ChildElementInfo(typeof(RevisionQueryTable))]
    [ChildElementInfo(typeof(RevisionConflict))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Revisions : OpenXmlPartRootElement
{
    private const string tagName = "revisions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11103;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Revisions constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Revisions.</param>
    internal Revisions(WorkbookRevisionLogPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorkbookRevisionLogPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorkbookRevisionLogPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorkbookRevisionLogPart associated with this element.
    /// </summary>
    public WorkbookRevisionLogPart WorkbookRevisionLogPart
    {
		get
		{
			return OpenXmlPart as WorkbookRevisionLogPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Revisions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Revisions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Revisions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Revisions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Revisions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Revisions(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Revisions class.
    /// </summary>
    public Revisions() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorkbookRevisionLogPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorkbookRevisionLogPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rrc" == name)
    return new RevisionRowColumn();
    
if( 22 == namespaceId && "rm" == name)
    return new RevisionMove();
    
if( 22 == namespaceId && "rcv" == name)
    return new RevisionCustomView();
    
if( 22 == namespaceId && "rsnm" == name)
    return new RevisionSheetName();
    
if( 22 == namespaceId && "ris" == name)
    return new RevisionInsertSheet();
    
if( 22 == namespaceId && "rcc" == name)
    return new RevisionCellChange();
    
if( 22 == namespaceId && "rfmt" == name)
    return new RevisionFormat();
    
if( 22 == namespaceId && "raf" == name)
    return new RevisionAutoFormat();
    
if( 22 == namespaceId && "rdn" == name)
    return new RevisionDefinedName();
    
if( 22 == namespaceId && "rcmt" == name)
    return new RevisionComment();
    
if( 22 == namespaceId && "rqt" == name)
    return new RevisionQueryTable();
    
if( 22 == namespaceId && "rcft" == name)
    return new RevisionConflict();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Revisions>(deep);
    }

}
/// <summary>
/// <para>User List. The root element of WorkbookUserDataPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:users.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>UserInfo &lt;x:userInfo></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(UserInfo))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Users : OpenXmlPartRootElement
{
    private const string tagName = "users";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11104;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Active User Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// Users constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Users.</param>
    internal Users(WorkbookUserDataPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorkbookUserDataPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorkbookUserDataPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorkbookUserDataPart associated with this element.
    /// </summary>
    public WorkbookUserDataPart WorkbookUserDataPart
    {
		get
		{
			return OpenXmlPart as WorkbookUserDataPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Users class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Users(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Users class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Users(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Users class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Users(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Users class.
    /// </summary>
    public Users() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorkbookUserDataPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorkbookUserDataPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "userInfo" == name)
    return new UserInfo();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Users>(deep);
    }

}
/// <summary>
/// <para>Worksheet. The root element of WorksheetPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:worksheet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetProperties &lt;x:sheetPr></description></item>
///<item><description>SheetDimension &lt;x:dimension></description></item>
///<item><description>SheetViews &lt;x:sheetViews></description></item>
///<item><description>SheetFormatProperties &lt;x:sheetFormatPr></description></item>
///<item><description>Columns &lt;x:cols></description></item>
///<item><description>SheetData &lt;x:sheetData></description></item>
///<item><description>SheetCalculationProperties &lt;x:sheetCalcPr></description></item>
///<item><description>SheetProtection &lt;x:sheetProtection></description></item>
///<item><description>ProtectedRanges &lt;x:protectedRanges></description></item>
///<item><description>Scenarios &lt;x:scenarios></description></item>
///<item><description>AutoFilter &lt;x:autoFilter></description></item>
///<item><description>SortState &lt;x:sortState></description></item>
///<item><description>DataConsolidate &lt;x:dataConsolidate></description></item>
///<item><description>CustomSheetViews &lt;x:customSheetViews></description></item>
///<item><description>MergeCells &lt;x:mergeCells></description></item>
///<item><description>PhoneticProperties &lt;x:phoneticPr></description></item>
///<item><description>ConditionalFormatting &lt;x:conditionalFormatting></description></item>
///<item><description>DataValidations &lt;x:dataValidations></description></item>
///<item><description>Hyperlinks &lt;x:hyperlinks></description></item>
///<item><description>PrintOptions &lt;x:printOptions></description></item>
///<item><description>PageMargins &lt;x:pageMargins></description></item>
///<item><description>PageSetup &lt;x:pageSetup></description></item>
///<item><description>HeaderFooter &lt;x:headerFooter></description></item>
///<item><description>RowBreaks &lt;x:rowBreaks></description></item>
///<item><description>ColumnBreaks &lt;x:colBreaks></description></item>
///<item><description>CustomProperties &lt;x:customProperties></description></item>
///<item><description>CellWatches &lt;x:cellWatches></description></item>
///<item><description>IgnoredErrors &lt;x:ignoredErrors></description></item>
///<item><description>Drawing &lt;x:drawing></description></item>
///<item><description>LegacyDrawing &lt;x:legacyDrawing></description></item>
///<item><description>LegacyDrawingHeaderFooter &lt;x:legacyDrawingHF></description></item>
///<item><description>DrawingHeaderFooter &lt;x:drawingHF></description></item>
///<item><description>Picture &lt;x:picture></description></item>
///<item><description>OleObjects &lt;x:oleObjects></description></item>
///<item><description>Controls &lt;x:controls></description></item>
///<item><description>WebPublishItems &lt;x:webPublishItems></description></item>
///<item><description>TableParts &lt;x:tableParts></description></item>
///<item><description>WorksheetExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetProperties))]
    [ChildElementInfo(typeof(SheetDimension))]
    [ChildElementInfo(typeof(SheetViews))]
    [ChildElementInfo(typeof(SheetFormatProperties))]
    [ChildElementInfo(typeof(Columns))]
    [ChildElementInfo(typeof(SheetData))]
    [ChildElementInfo(typeof(SheetCalculationProperties))]
    [ChildElementInfo(typeof(SheetProtection))]
    [ChildElementInfo(typeof(ProtectedRanges))]
    [ChildElementInfo(typeof(Scenarios))]
    [ChildElementInfo(typeof(AutoFilter))]
    [ChildElementInfo(typeof(SortState))]
    [ChildElementInfo(typeof(DataConsolidate))]
    [ChildElementInfo(typeof(CustomSheetViews))]
    [ChildElementInfo(typeof(MergeCells))]
    [ChildElementInfo(typeof(PhoneticProperties))]
    [ChildElementInfo(typeof(ConditionalFormatting))]
    [ChildElementInfo(typeof(DataValidations))]
    [ChildElementInfo(typeof(Hyperlinks))]
    [ChildElementInfo(typeof(PrintOptions))]
    [ChildElementInfo(typeof(PageMargins))]
    [ChildElementInfo(typeof(PageSetup))]
    [ChildElementInfo(typeof(HeaderFooter))]
    [ChildElementInfo(typeof(RowBreaks))]
    [ChildElementInfo(typeof(ColumnBreaks))]
    [ChildElementInfo(typeof(CustomProperties))]
    [ChildElementInfo(typeof(CellWatches))]
    [ChildElementInfo(typeof(IgnoredErrors))]
    [ChildElementInfo(typeof(Drawing))]
    [ChildElementInfo(typeof(LegacyDrawing))]
    [ChildElementInfo(typeof(LegacyDrawingHeaderFooter))]
    [ChildElementInfo(typeof(DrawingHeaderFooter))]
    [ChildElementInfo(typeof(Picture))]
    [ChildElementInfo(typeof(OleObjects))]
    [ChildElementInfo(typeof(Controls))]
    [ChildElementInfo(typeof(WebPublishItems))]
    [ChildElementInfo(typeof(TableParts))]
    [ChildElementInfo(typeof(WorksheetExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Worksheet : OpenXmlPartRootElement
{
    private const string tagName = "worksheet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11105;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Worksheet constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Worksheet.</param>
    internal Worksheet(WorksheetPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorksheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorksheetPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorksheetPart associated with this element.
    /// </summary>
    public WorksheetPart WorksheetPart
    {
		get
		{
			return OpenXmlPart as WorksheetPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Worksheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Worksheet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Worksheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Worksheet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Worksheet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Worksheet(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Worksheet class.
    /// </summary>
    public Worksheet() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorksheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorksheetPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetPr" == name)
    return new SheetProperties();
    
if( 22 == namespaceId && "dimension" == name)
    return new SheetDimension();
    
if( 22 == namespaceId && "sheetViews" == name)
    return new SheetViews();
    
if( 22 == namespaceId && "sheetFormatPr" == name)
    return new SheetFormatProperties();
    
if( 22 == namespaceId && "cols" == name)
    return new Columns();
    
if( 22 == namespaceId && "sheetData" == name)
    return new SheetData();
    
if( 22 == namespaceId && "sheetCalcPr" == name)
    return new SheetCalculationProperties();
    
if( 22 == namespaceId && "sheetProtection" == name)
    return new SheetProtection();
    
if( 22 == namespaceId && "protectedRanges" == name)
    return new ProtectedRanges();
    
if( 22 == namespaceId && "scenarios" == name)
    return new Scenarios();
    
if( 22 == namespaceId && "autoFilter" == name)
    return new AutoFilter();
    
if( 22 == namespaceId && "sortState" == name)
    return new SortState();
    
if( 22 == namespaceId && "dataConsolidate" == name)
    return new DataConsolidate();
    
if( 22 == namespaceId && "customSheetViews" == name)
    return new CustomSheetViews();
    
if( 22 == namespaceId && "mergeCells" == name)
    return new MergeCells();
    
if( 22 == namespaceId && "phoneticPr" == name)
    return new PhoneticProperties();
    
if( 22 == namespaceId && "conditionalFormatting" == name)
    return new ConditionalFormatting();
    
if( 22 == namespaceId && "dataValidations" == name)
    return new DataValidations();
    
if( 22 == namespaceId && "hyperlinks" == name)
    return new Hyperlinks();
    
if( 22 == namespaceId && "printOptions" == name)
    return new PrintOptions();
    
if( 22 == namespaceId && "pageMargins" == name)
    return new PageMargins();
    
if( 22 == namespaceId && "pageSetup" == name)
    return new PageSetup();
    
if( 22 == namespaceId && "headerFooter" == name)
    return new HeaderFooter();
    
if( 22 == namespaceId && "rowBreaks" == name)
    return new RowBreaks();
    
if( 22 == namespaceId && "colBreaks" == name)
    return new ColumnBreaks();
    
if( 22 == namespaceId && "customProperties" == name)
    return new CustomProperties();
    
if( 22 == namespaceId && "cellWatches" == name)
    return new CellWatches();
    
if( 22 == namespaceId && "ignoredErrors" == name)
    return new IgnoredErrors();
    
if( 22 == namespaceId && "drawing" == name)
    return new Drawing();
    
if( 22 == namespaceId && "legacyDrawing" == name)
    return new LegacyDrawing();
    
if( 22 == namespaceId && "legacyDrawingHF" == name)
    return new LegacyDrawingHeaderFooter();
    
if( 22 == namespaceId && "drawingHF" == name)
    return new DrawingHeaderFooter();
    
if( 22 == namespaceId && "picture" == name)
    return new Picture();
    
if( 22 == namespaceId && "oleObjects" == name)
    return new OleObjects();
    
if( 22 == namespaceId && "controls" == name)
    return new Controls();
    
if( 22 == namespaceId && "webPublishItems" == name)
    return new WebPublishItems();
    
if( 22 == namespaceId && "tableParts" == name)
    return new TableParts();
    
if( 22 == namespaceId && "extLst" == name)
    return new WorksheetExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sheetPr","dimension","sheetViews","sheetFormatPr","cols","sheetData","sheetCalcPr","sheetProtection","protectedRanges","scenarios","autoFilter","sortState","dataConsolidate","customSheetViews","mergeCells","phoneticPr","conditionalFormatting","dataValidations","hyperlinks","printOptions","pageMargins","pageSetup","headerFooter","rowBreaks","colBreaks","customProperties","cellWatches","ignoredErrors","drawing","legacyDrawing","legacyDrawingHF","drawingHF","picture","oleObjects","controls","webPublishItems","tableParts","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> SheetProperties.</para>
    /// <para> Represents the following element tag in the schema: x:sheetPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetProperties SheetProperties
    {
        get 
        {
            return GetElement<SheetProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> SheetDimension.</para>
    /// <para> Represents the following element tag in the schema: x:dimension </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetDimension SheetDimension
    {
        get 
        {
            return GetElement<SheetDimension>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> SheetViews.</para>
    /// <para> Represents the following element tag in the schema: x:sheetViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetViews SheetViews
    {
        get 
        {
            return GetElement<SheetViews>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> SheetFormatProperties.</para>
    /// <para> Represents the following element tag in the schema: x:sheetFormatPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetFormatProperties SheetFormatProperties
    {
        get 
        {
            return GetElement<SheetFormatProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Worksheet>(deep);
    }

}
/// <summary>
/// <para>Chart Sheet. The root element of ChartsheetPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:chartsheet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ChartSheetProperties &lt;x:sheetPr></description></item>
///<item><description>ChartSheetViews &lt;x:sheetViews></description></item>
///<item><description>ChartSheetProtection &lt;x:sheetProtection></description></item>
///<item><description>CustomChartsheetViews &lt;x:customSheetViews></description></item>
///<item><description>PageMargins &lt;x:pageMargins></description></item>
///<item><description>ChartSheetPageSetup &lt;x:pageSetup></description></item>
///<item><description>HeaderFooter &lt;x:headerFooter></description></item>
///<item><description>Drawing &lt;x:drawing></description></item>
///<item><description>LegacyDrawing &lt;x:legacyDrawing></description></item>
///<item><description>LegacyDrawingHeaderFooter &lt;x:legacyDrawingHF></description></item>
///<item><description>DrawingHeaderFooter &lt;x:drawingHF></description></item>
///<item><description>Picture &lt;x:picture></description></item>
///<item><description>WebPublishItems &lt;x:webPublishItems></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ChartSheetProperties))]
    [ChildElementInfo(typeof(ChartSheetViews))]
    [ChildElementInfo(typeof(ChartSheetProtection))]
    [ChildElementInfo(typeof(CustomChartsheetViews))]
    [ChildElementInfo(typeof(PageMargins))]
    [ChildElementInfo(typeof(ChartSheetPageSetup))]
    [ChildElementInfo(typeof(HeaderFooter))]
    [ChildElementInfo(typeof(Drawing))]
    [ChildElementInfo(typeof(LegacyDrawing))]
    [ChildElementInfo(typeof(LegacyDrawingHeaderFooter))]
    [ChildElementInfo(typeof(DrawingHeaderFooter),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(Picture))]
    [ChildElementInfo(typeof(WebPublishItems))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Chartsheet : OpenXmlPartRootElement
{
    private const string tagName = "chartsheet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11106;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Chartsheet constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Chartsheet.</param>
    internal Chartsheet(ChartsheetPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the ChartsheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(ChartsheetPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the ChartsheetPart associated with this element.
    /// </summary>
    public ChartsheetPart ChartsheetPart
    {
		get
		{
			return OpenXmlPart as ChartsheetPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Chartsheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Chartsheet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Chartsheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Chartsheet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Chartsheet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Chartsheet(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Chartsheet class.
    /// </summary>
    public Chartsheet() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the ChartsheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(ChartsheetPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetPr" == name)
    return new ChartSheetProperties();
    
if( 22 == namespaceId && "sheetViews" == name)
    return new ChartSheetViews();
    
if( 22 == namespaceId && "sheetProtection" == name)
    return new ChartSheetProtection();
    
if( 22 == namespaceId && "customSheetViews" == name)
    return new CustomChartsheetViews();
    
if( 22 == namespaceId && "pageMargins" == name)
    return new PageMargins();
    
if( 22 == namespaceId && "pageSetup" == name)
    return new ChartSheetPageSetup();
    
if( 22 == namespaceId && "headerFooter" == name)
    return new HeaderFooter();
    
if( 22 == namespaceId && "drawing" == name)
    return new Drawing();
    
if( 22 == namespaceId && "legacyDrawing" == name)
    return new LegacyDrawing();
    
if( 22 == namespaceId && "legacyDrawingHF" == name)
    return new LegacyDrawingHeaderFooter();
    
if( 22 == namespaceId && "drawingHF" == name)
    return new DrawingHeaderFooter();
    
if( 22 == namespaceId && "picture" == name)
    return new Picture();
    
if( 22 == namespaceId && "webPublishItems" == name)
    return new WebPublishItems();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sheetPr","sheetViews","sheetProtection","customSheetViews","pageMargins","pageSetup","headerFooter","drawing","legacyDrawing","legacyDrawingHF","drawingHF","picture","webPublishItems","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Chart Sheet Properties.</para>
    /// <para> Represents the following element tag in the schema: x:sheetPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartSheetProperties ChartSheetProperties
    {
        get 
        {
            return GetElement<ChartSheetProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Chart Sheet Views.</para>
    /// <para> Represents the following element tag in the schema: x:sheetViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartSheetViews ChartSheetViews
    {
        get 
        {
            return GetElement<ChartSheetViews>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Chart Sheet Protection.</para>
    /// <para> Represents the following element tag in the schema: x:sheetProtection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartSheetProtection ChartSheetProtection
    {
        get 
        {
            return GetElement<ChartSheetProtection>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Custom Chart Sheet Views.</para>
    /// <para> Represents the following element tag in the schema: x:customSheetViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CustomChartsheetViews CustomChartsheetViews
    {
        get 
        {
            return GetElement<CustomChartsheetViews>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> PageMargins.</para>
    /// <para> Represents the following element tag in the schema: x:pageMargins </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageMargins PageMargins
    {
        get 
        {
            return GetElement<PageMargins>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> ChartSheetPageSetup.</para>
    /// <para> Represents the following element tag in the schema: x:pageSetup </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartSheetPageSetup ChartSheetPageSetup
    {
        get 
        {
            return GetElement<ChartSheetPageSetup>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> HeaderFooter.</para>
    /// <para> Represents the following element tag in the schema: x:headerFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public HeaderFooter HeaderFooter
    {
        get 
        {
            return GetElement<HeaderFooter>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Drawing.</para>
    /// <para> Represents the following element tag in the schema: x:drawing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Drawing Drawing
    {
        get 
        {
            return GetElement<Drawing>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> LegacyDrawing.</para>
    /// <para> Represents the following element tag in the schema: x:legacyDrawing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public LegacyDrawing LegacyDrawing
    {
        get 
        {
            return GetElement<LegacyDrawing>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Legacy Drawing Reference in  Header Footer.</para>
    /// <para> Represents the following element tag in the schema: x:legacyDrawingHF </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public LegacyDrawingHeaderFooter LegacyDrawingHeaderFooter
    {
        get 
        {
            return GetElement<LegacyDrawingHeaderFooter>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> DrawingHeaderFooter.</para>
    /// <para> Represents the following element tag in the schema: x:drawingHF </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DrawingHeaderFooter DrawingHeaderFooter
    {
        get 
        {
            return GetElement<DrawingHeaderFooter>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Picture.</para>
    /// <para> Represents the following element tag in the schema: x:picture </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Picture Picture
    {
        get 
        {
            return GetElement<Picture>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> WebPublishItems.</para>
    /// <para> Represents the following element tag in the schema: x:webPublishItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WebPublishItems WebPublishItems
    {
        get 
        {
            return GetElement<WebPublishItems>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Chartsheet>(deep);
    }

}
/// <summary>
/// <para>Dialog Sheet. The root element of DialogsheetPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dialogsheet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetProperties &lt;x:sheetPr></description></item>
///<item><description>SheetViews &lt;x:sheetViews></description></item>
///<item><description>SheetFormatProperties &lt;x:sheetFormatPr></description></item>
///<item><description>SheetProtection &lt;x:sheetProtection></description></item>
///<item><description>CustomSheetViews &lt;x:customSheetViews></description></item>
///<item><description>PrintOptions &lt;x:printOptions></description></item>
///<item><description>PageMargins &lt;x:pageMargins></description></item>
///<item><description>PageSetup &lt;x:pageSetup></description></item>
///<item><description>HeaderFooter &lt;x:headerFooter></description></item>
///<item><description>Drawing &lt;x:drawing></description></item>
///<item><description>LegacyDrawing &lt;x:legacyDrawing></description></item>
///<item><description>LegacyDrawingHeaderFooter &lt;x:legacyDrawingHF></description></item>
///<item><description>DrawingHeaderFooter &lt;x:drawingHF></description></item>
///<item><description>OleObjects &lt;x:oleObjects></description></item>
///<item><description>Controls &lt;x:controls></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetProperties))]
    [ChildElementInfo(typeof(SheetViews))]
    [ChildElementInfo(typeof(SheetFormatProperties))]
    [ChildElementInfo(typeof(SheetProtection))]
    [ChildElementInfo(typeof(CustomSheetViews))]
    [ChildElementInfo(typeof(PrintOptions))]
    [ChildElementInfo(typeof(PageMargins))]
    [ChildElementInfo(typeof(PageSetup))]
    [ChildElementInfo(typeof(HeaderFooter))]
    [ChildElementInfo(typeof(Drawing))]
    [ChildElementInfo(typeof(LegacyDrawing))]
    [ChildElementInfo(typeof(LegacyDrawingHeaderFooter))]
    [ChildElementInfo(typeof(DrawingHeaderFooter),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(OleObjects))]
    [ChildElementInfo(typeof(Controls),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DialogSheet : OpenXmlPartRootElement
{
    private const string tagName = "dialogsheet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11107;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// DialogSheet constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the DialogSheet.</param>
    internal DialogSheet(DialogsheetPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the DialogsheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(DialogsheetPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the DialogsheetPart associated with this element.
    /// </summary>
    public DialogsheetPart DialogsheetPart
    {
		get
		{
			return OpenXmlPart as DialogsheetPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the DialogSheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DialogSheet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DialogSheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DialogSheet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DialogSheet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DialogSheet(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the DialogSheet class.
    /// </summary>
    public DialogSheet() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the DialogsheetPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(DialogsheetPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetPr" == name)
    return new SheetProperties();
    
if( 22 == namespaceId && "sheetViews" == name)
    return new SheetViews();
    
if( 22 == namespaceId && "sheetFormatPr" == name)
    return new SheetFormatProperties();
    
if( 22 == namespaceId && "sheetProtection" == name)
    return new SheetProtection();
    
if( 22 == namespaceId && "customSheetViews" == name)
    return new CustomSheetViews();
    
if( 22 == namespaceId && "printOptions" == name)
    return new PrintOptions();
    
if( 22 == namespaceId && "pageMargins" == name)
    return new PageMargins();
    
if( 22 == namespaceId && "pageSetup" == name)
    return new PageSetup();
    
if( 22 == namespaceId && "headerFooter" == name)
    return new HeaderFooter();
    
if( 22 == namespaceId && "drawing" == name)
    return new Drawing();
    
if( 22 == namespaceId && "legacyDrawing" == name)
    return new LegacyDrawing();
    
if( 22 == namespaceId && "legacyDrawingHF" == name)
    return new LegacyDrawingHeaderFooter();
    
if( 22 == namespaceId && "drawingHF" == name)
    return new DrawingHeaderFooter();
    
if( 22 == namespaceId && "oleObjects" == name)
    return new OleObjects();
    
if( 22 == namespaceId && "controls" == name)
    return new Controls();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sheetPr","sheetViews","sheetFormatPr","sheetProtection","customSheetViews","printOptions","pageMargins","pageSetup","headerFooter","drawing","legacyDrawing","legacyDrawingHF","drawingHF","oleObjects","controls","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Sheet Properties.</para>
    /// <para> Represents the following element tag in the schema: x:sheetPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetProperties SheetProperties
    {
        get 
        {
            return GetElement<SheetProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Dialog Sheet Views.</para>
    /// <para> Represents the following element tag in the schema: x:sheetViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetViews SheetViews
    {
        get 
        {
            return GetElement<SheetViews>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Dialog Sheet Format Properties.</para>
    /// <para> Represents the following element tag in the schema: x:sheetFormatPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetFormatProperties SheetFormatProperties
    {
        get 
        {
            return GetElement<SheetFormatProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Sheet Protection.</para>
    /// <para> Represents the following element tag in the schema: x:sheetProtection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetProtection SheetProtection
    {
        get 
        {
            return GetElement<SheetProtection>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Custom Sheet Views.</para>
    /// <para> Represents the following element tag in the schema: x:customSheetViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CustomSheetViews CustomSheetViews
    {
        get 
        {
            return GetElement<CustomSheetViews>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Print Options.</para>
    /// <para> Represents the following element tag in the schema: x:printOptions </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PrintOptions PrintOptions
    {
        get 
        {
            return GetElement<PrintOptions>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Page Margins.</para>
    /// <para> Represents the following element tag in the schema: x:pageMargins </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageMargins PageMargins
    {
        get 
        {
            return GetElement<PageMargins>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Page Setup Settings.</para>
    /// <para> Represents the following element tag in the schema: x:pageSetup </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageSetup PageSetup
    {
        get 
        {
            return GetElement<PageSetup>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Header and Footer Settings.</para>
    /// <para> Represents the following element tag in the schema: x:headerFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public HeaderFooter HeaderFooter
    {
        get 
        {
            return GetElement<HeaderFooter>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Drawing.</para>
    /// <para> Represents the following element tag in the schema: x:drawing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Drawing Drawing
    {
        get 
        {
            return GetElement<Drawing>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Legacy Drawing.</para>
    /// <para> Represents the following element tag in the schema: x:legacyDrawing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public LegacyDrawing LegacyDrawing
    {
        get 
        {
            return GetElement<LegacyDrawing>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Legacy Drawing Header Footer.</para>
    /// <para> Represents the following element tag in the schema: x:legacyDrawingHF </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public LegacyDrawingHeaderFooter LegacyDrawingHeaderFooter
    {
        get 
        {
            return GetElement<LegacyDrawingHeaderFooter>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> DrawingHeaderFooter.</para>
    /// <para> Represents the following element tag in the schema: x:drawingHF </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DrawingHeaderFooter DrawingHeaderFooter
    {
        get 
        {
            return GetElement<DrawingHeaderFooter>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> OleObjects.</para>
    /// <para> Represents the following element tag in the schema: x:oleObjects </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OleObjects OleObjects
    {
        get 
        {
            return GetElement<OleObjects>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> Controls.</para>
    /// <para> Represents the following element tag in the schema: x:controls </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Controls Controls
    {
        get 
        {
            return GetElement<Controls>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(15);
        }
        set
        {
            SetElement(15, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DialogSheet>(deep);
    }

}
/// <summary>
/// <para>Metadata. The root element of CellMetadataPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:metadata.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataTypes &lt;x:metadataTypes></description></item>
///<item><description>MetadataStrings &lt;x:metadataStrings></description></item>
///<item><description>MdxMetadata &lt;x:mdxMetadata></description></item>
///<item><description>FutureMetadata &lt;x:futureMetadata></description></item>
///<item><description>CellMetadata &lt;x:cellMetadata></description></item>
///<item><description>ValueMetadata &lt;x:valueMetadata></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MetadataTypes))]
    [ChildElementInfo(typeof(MetadataStrings))]
    [ChildElementInfo(typeof(MdxMetadata))]
    [ChildElementInfo(typeof(FutureMetadata))]
    [ChildElementInfo(typeof(CellMetadata))]
    [ChildElementInfo(typeof(ValueMetadata))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Metadata : OpenXmlPartRootElement
{
    private const string tagName = "metadata";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11108;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Metadata constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Metadata.</param>
    internal Metadata(CellMetadataPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the CellMetadataPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(CellMetadataPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the CellMetadataPart associated with this element.
    /// </summary>
    public CellMetadataPart CellMetadataPart
    {
		get
		{
			return OpenXmlPart as CellMetadataPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Metadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Metadata(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Metadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Metadata(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Metadata class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Metadata(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Metadata class.
    /// </summary>
    public Metadata() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the CellMetadataPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(CellMetadataPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "metadataTypes" == name)
    return new MetadataTypes();
    
if( 22 == namespaceId && "metadataStrings" == name)
    return new MetadataStrings();
    
if( 22 == namespaceId && "mdxMetadata" == name)
    return new MdxMetadata();
    
if( 22 == namespaceId && "futureMetadata" == name)
    return new FutureMetadata();
    
if( 22 == namespaceId && "cellMetadata" == name)
    return new CellMetadata();
    
if( 22 == namespaceId && "valueMetadata" == name)
    return new ValueMetadata();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "metadataTypes","metadataStrings","mdxMetadata","futureMetadata","cellMetadata","valueMetadata","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Metadata Types Collection.</para>
    /// <para> Represents the following element tag in the schema: x:metadataTypes </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MetadataTypes MetadataTypes
    {
        get 
        {
            return GetElement<MetadataTypes>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Metadata String Store.</para>
    /// <para> Represents the following element tag in the schema: x:metadataStrings </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MetadataStrings MetadataStrings
    {
        get 
        {
            return GetElement<MetadataStrings>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> MDX Metadata Information.</para>
    /// <para> Represents the following element tag in the schema: x:mdxMetadata </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MdxMetadata MdxMetadata
    {
        get 
        {
            return GetElement<MdxMetadata>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Metadata>(deep);
    }

}
/// <summary>
/// <para>Single Cells. The root element of SingleCellTablePart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:singleXmlCells.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SingleXmlCell &lt;x:singleXmlCell></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SingleXmlCell))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SingleXmlCells : OpenXmlPartRootElement
{
    private const string tagName = "singleXmlCells";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11109;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// SingleXmlCells constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the SingleXmlCells.</param>
    internal SingleXmlCells(SingleCellTablePart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the SingleCellTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(SingleCellTablePart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the SingleCellTablePart associated with this element.
    /// </summary>
    public SingleCellTablePart SingleCellTablePart
    {
		get
		{
			return OpenXmlPart as SingleCellTablePart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the SingleXmlCells class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SingleXmlCells(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SingleXmlCells class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SingleXmlCells(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SingleXmlCells class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SingleXmlCells(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the SingleXmlCells class.
    /// </summary>
    public SingleXmlCells() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the SingleCellTablePart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(SingleCellTablePart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "singleXmlCell" == name)
    return new SingleXmlCell();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SingleXmlCells>(deep);
    }

}
/// <summary>
/// <para>Style Sheet. The root element of WorkbookStylesPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:styleSheet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NumberingFormats &lt;x:numFmts></description></item>
///<item><description>Fonts &lt;x:fonts></description></item>
///<item><description>Fills &lt;x:fills></description></item>
///<item><description>Borders &lt;x:borders></description></item>
///<item><description>CellStyleFormats &lt;x:cellStyleXfs></description></item>
///<item><description>CellFormats &lt;x:cellXfs></description></item>
///<item><description>CellStyles &lt;x:cellStyles></description></item>
///<item><description>DifferentialFormats &lt;x:dxfs></description></item>
///<item><description>TableStyles &lt;x:tableStyles></description></item>
///<item><description>Colors &lt;x:colors></description></item>
///<item><description>StylesheetExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NumberingFormats))]
    [ChildElementInfo(typeof(Fonts))]
    [ChildElementInfo(typeof(Fills))]
    [ChildElementInfo(typeof(Borders))]
    [ChildElementInfo(typeof(CellStyleFormats))]
    [ChildElementInfo(typeof(CellFormats))]
    [ChildElementInfo(typeof(CellStyles))]
    [ChildElementInfo(typeof(DifferentialFormats))]
    [ChildElementInfo(typeof(TableStyles))]
    [ChildElementInfo(typeof(Colors))]
    [ChildElementInfo(typeof(StylesheetExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Stylesheet : OpenXmlPartRootElement
{
    private const string tagName = "styleSheet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11110;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// Stylesheet constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Stylesheet.</param>
    internal Stylesheet(WorkbookStylesPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorkbookStylesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorkbookStylesPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorkbookStylesPart associated with this element.
    /// </summary>
    public WorkbookStylesPart WorkbookStylesPart
    {
		get
		{
			return OpenXmlPart as WorkbookStylesPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Stylesheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Stylesheet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Stylesheet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Stylesheet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Stylesheet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Stylesheet(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Stylesheet class.
    /// </summary>
    public Stylesheet() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorkbookStylesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorkbookStylesPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "numFmts" == name)
    return new NumberingFormats();
    
if( 22 == namespaceId && "fonts" == name)
    return new Fonts();
    
if( 22 == namespaceId && "fills" == name)
    return new Fills();
    
if( 22 == namespaceId && "borders" == name)
    return new Borders();
    
if( 22 == namespaceId && "cellStyleXfs" == name)
    return new CellStyleFormats();
    
if( 22 == namespaceId && "cellXfs" == name)
    return new CellFormats();
    
if( 22 == namespaceId && "cellStyles" == name)
    return new CellStyles();
    
if( 22 == namespaceId && "dxfs" == name)
    return new DifferentialFormats();
    
if( 22 == namespaceId && "tableStyles" == name)
    return new TableStyles();
    
if( 22 == namespaceId && "colors" == name)
    return new Colors();
    
if( 22 == namespaceId && "extLst" == name)
    return new StylesheetExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "numFmts","fonts","fills","borders","cellStyleXfs","cellXfs","cellStyles","dxfs","tableStyles","colors","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> NumberingFormats.</para>
    /// <para> Represents the following element tag in the schema: x:numFmts </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public NumberingFormats NumberingFormats
    {
        get 
        {
            return GetElement<NumberingFormats>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Fonts.</para>
    /// <para> Represents the following element tag in the schema: x:fonts </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Fonts Fonts
    {
        get 
        {
            return GetElement<Fonts>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Fills.</para>
    /// <para> Represents the following element tag in the schema: x:fills </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Fills Fills
    {
        get 
        {
            return GetElement<Fills>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Borders.</para>
    /// <para> Represents the following element tag in the schema: x:borders </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Borders Borders
    {
        get 
        {
            return GetElement<Borders>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> CellStyleFormats.</para>
    /// <para> Represents the following element tag in the schema: x:cellStyleXfs </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellStyleFormats CellStyleFormats
    {
        get 
        {
            return GetElement<CellStyleFormats>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> CellFormats.</para>
    /// <para> Represents the following element tag in the schema: x:cellXfs </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellFormats CellFormats
    {
        get 
        {
            return GetElement<CellFormats>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> CellStyles.</para>
    /// <para> Represents the following element tag in the schema: x:cellStyles </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellStyles CellStyles
    {
        get 
        {
            return GetElement<CellStyles>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> DifferentialFormats.</para>
    /// <para> Represents the following element tag in the schema: x:dxfs </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DifferentialFormats DifferentialFormats
    {
        get 
        {
            return GetElement<DifferentialFormats>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> TableStyles.</para>
    /// <para> Represents the following element tag in the schema: x:tableStyles </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TableStyles TableStyles
    {
        get 
        {
            return GetElement<TableStyles>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Colors.</para>
    /// <para> Represents the following element tag in the schema: x:colors </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Colors Colors
    {
        get 
        {
            return GetElement<Colors>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> StylesheetExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public StylesheetExtensionList StylesheetExtensionList
    {
        get 
        {
            return GetElement<StylesheetExtensionList>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Stylesheet>(deep);
    }

}
/// <summary>
/// <para>External Reference. The root element of ExternalWorkbookPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:externalLink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalBook &lt;x:externalBook></description></item>
///<item><description>DdeLink &lt;x:ddeLink></description></item>
///<item><description>OleLink &lt;x:oleLink></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalBook))]
    [ChildElementInfo(typeof(DdeLink))]
    [ChildElementInfo(typeof(OleLink))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalLink : OpenXmlPartRootElement
{
    private const string tagName = "externalLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11111;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// ExternalLink constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the ExternalLink.</param>
    internal ExternalLink(ExternalWorkbookPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the ExternalWorkbookPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(ExternalWorkbookPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the ExternalWorkbookPart associated with this element.
    /// </summary>
    public ExternalWorkbookPart ExternalWorkbookPart
    {
		get
		{
			return OpenXmlPart as ExternalWorkbookPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the ExternalLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalLink(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalLink(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalLink class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalLink(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the ExternalLink class.
    /// </summary>
    public ExternalLink() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the ExternalWorkbookPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(ExternalWorkbookPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "externalBook" == name)
    return new ExternalBook();
    
if( 22 == namespaceId && "ddeLink" == name)
    return new DdeLink();
    
if( 22 == namespaceId && "oleLink" == name)
    return new OleLink();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalLink>(deep);
    }

}
/// <summary>
/// <para>Table. The root element of TableDefinitionPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:table.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AutoFilter &lt;x:autoFilter></description></item>
///<item><description>SortState &lt;x:sortState></description></item>
///<item><description>TableColumns &lt;x:tableColumns></description></item>
///<item><description>TableStyleInfo &lt;x:tableStyleInfo></description></item>
///<item><description>TableExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AutoFilter))]
    [ChildElementInfo(typeof(SortState))]
    [ChildElementInfo(typeof(TableColumns))]
    [ChildElementInfo(typeof(TableStyleInfo))]
    [ChildElementInfo(typeof(TableExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Table : OpenXmlPartRootElement
{
    private const string tagName = "table";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11112;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","name","displayName","comment","ref","tableType","headerRowCount","insertRow","insertRowShift","totalsRowCount","totalsRowShown","published","headerRowDxfId","dataDxfId","totalsRowDxfId","headerRowBorderDxfId","tableBorderDxfId","totalsRowBorderDxfId","headerRowCellStyle","dataCellStyle","totalsRowCellStyle","connectionId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Table Name.</para>
    /// <para>Represents the following attribute in the schema: displayName </para>
    /// </summary>
    [SchemaAttr(0, "displayName")]
    public StringValue DisplayName
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Table Comment.</para>
    /// <para>Represents the following attribute in the schema: comment </para>
    /// </summary>
    [SchemaAttr(0, "comment")]
    public StringValue Comment
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Table Type.</para>
    /// <para>Represents the following attribute in the schema: tableType </para>
    /// </summary>
    [SchemaAttr(0, "tableType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableValues> TableType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Count.</para>
    /// <para>Represents the following attribute in the schema: headerRowCount </para>
    /// </summary>
    [SchemaAttr(0, "headerRowCount")]
    public UInt32Value HeaderRowCount
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Insert Row Showing.</para>
    /// <para>Represents the following attribute in the schema: insertRow </para>
    /// </summary>
    [SchemaAttr(0, "insertRow")]
    public BooleanValue InsertRow
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Insert Row Shift.</para>
    /// <para>Represents the following attribute in the schema: insertRowShift </para>
    /// </summary>
    [SchemaAttr(0, "insertRowShift")]
    public BooleanValue InsertRowShift
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Count.</para>
    /// <para>Represents the following attribute in the schema: totalsRowCount </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowCount")]
    public UInt32Value TotalsRowCount
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Shown.</para>
    /// <para>Represents the following attribute in the schema: totalsRowShown </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowShown")]
    public BooleanValue TotalsRowShown
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Published.</para>
    /// <para>Represents the following attribute in the schema: published </para>
    /// </summary>
    [SchemaAttr(0, "published")]
    public BooleanValue Published
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Format Id.</para>
    /// <para>Represents the following attribute in the schema: headerRowDxfId </para>
    /// </summary>
    [SchemaAttr(0, "headerRowDxfId")]
    public UInt32Value HeaderRowFormatId
    {
        get { return (UInt32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Data Area Format Id.</para>
    /// <para>Represents the following attribute in the schema: dataDxfId </para>
    /// </summary>
    [SchemaAttr(0, "dataDxfId")]
    public UInt32Value DataFormatId
    {
        get { return (UInt32Value)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Format Id.</para>
    /// <para>Represents the following attribute in the schema: totalsRowDxfId </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowDxfId")]
    public UInt32Value TotalsRowFormatId
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Border Format Id.</para>
    /// <para>Represents the following attribute in the schema: headerRowBorderDxfId </para>
    /// </summary>
    [SchemaAttr(0, "headerRowBorderDxfId")]
    public UInt32Value HeaderRowBorderFormatId
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Table Border Format Id.</para>
    /// <para>Represents the following attribute in the schema: tableBorderDxfId </para>
    /// </summary>
    [SchemaAttr(0, "tableBorderDxfId")]
    public UInt32Value BorderFormatId
    {
        get { return (UInt32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Border Format Id.</para>
    /// <para>Represents the following attribute in the schema: totalsRowBorderDxfId </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowBorderDxfId")]
    public UInt32Value TotalsRowBorderFormatId
    {
        get { return (UInt32Value)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Style.</para>
    /// <para>Represents the following attribute in the schema: headerRowCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "headerRowCellStyle")]
    public StringValue HeaderRowCellStyle
    {
        get { return (StringValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Data Style Name.</para>
    /// <para>Represents the following attribute in the schema: dataCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "dataCellStyle")]
    public StringValue DataCellStyle
    {
        get { return (StringValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Style.</para>
    /// <para>Represents the following attribute in the schema: totalsRowCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowCellStyle")]
    public StringValue TotalsRowCellStyle
    {
        get { return (StringValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Connection ID.</para>
    /// <para>Represents the following attribute in the schema: connectionId </para>
    /// </summary>
    [SchemaAttr(0, "connectionId")]
    public UInt32Value ConnectionId
    {
        get { return (UInt32Value)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    

    
    /// <summary>
    /// Table constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Table.</param>
    internal Table(TableDefinitionPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the TableDefinitionPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(TableDefinitionPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the TableDefinitionPart associated with this element.
    /// </summary>
    public TableDefinitionPart TableDefinitionPart
    {
		get
		{
			return OpenXmlPart as TableDefinitionPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Table(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Table class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Table(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Table class.
    /// </summary>
    public Table() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the TableDefinitionPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(TableDefinitionPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "autoFilter" == name)
    return new AutoFilter();
    
if( 22 == namespaceId && "sortState" == name)
    return new SortState();
    
if( 22 == namespaceId && "tableColumns" == name)
    return new TableColumns();
    
if( 22 == namespaceId && "tableStyleInfo" == name)
    return new TableStyleInfo();
    
if( 22 == namespaceId && "extLst" == name)
    return new TableExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "autoFilter","sortState","tableColumns","tableStyleInfo","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Table AutoFilter.</para>
    /// <para> Represents the following element tag in the schema: x:autoFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public AutoFilter AutoFilter
    {
        get 
        {
            return GetElement<AutoFilter>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Sort State.</para>
    /// <para> Represents the following element tag in the schema: x:sortState </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SortState SortState
    {
        get 
        {
            return GetElement<SortState>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Table Columns.</para>
    /// <para> Represents the following element tag in the schema: x:tableColumns </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TableColumns TableColumns
    {
        get 
        {
            return GetElement<TableColumns>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Table Style.</para>
    /// <para> Represents the following element tag in the schema: x:tableStyleInfo </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TableStyleInfo TableStyleInfo
    {
        get 
        {
            return GetElement<TableStyleInfo>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TableExtensionList TableExtensionList
    {
        get 
        {
            return GetElement<TableExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "displayName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "comment" == name)
    return new StringValue();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tableType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableValues>();
    
if( 0 == namespaceId && "headerRowCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "insertRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertRowShift" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "totalsRowCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "totalsRowShown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "published" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "headerRowDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "dataDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "totalsRowDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "headerRowBorderDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "tableBorderDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "totalsRowBorderDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "headerRowCellStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dataCellStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "totalsRowCellStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "connectionId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Table>(deep);
    }

}
/// <summary>
/// <para>Volatile Dependency Types. The root element of VolatileDependenciesPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:volTypes.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>VolatileType &lt;x:volType></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(VolatileType))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VolatileTypes : OpenXmlPartRootElement
{
    private const string tagName = "volTypes";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11113;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    
    /// <summary>
    /// VolatileTypes constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the VolatileTypes.</param>
    internal VolatileTypes(VolatileDependenciesPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the VolatileDependenciesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(VolatileDependenciesPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the VolatileDependenciesPart associated with this element.
    /// </summary>
    public VolatileDependenciesPart VolatileDependenciesPart
    {
		get
		{
			return OpenXmlPart as VolatileDependenciesPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the VolatileTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VolatileTypes(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the VolatileTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VolatileTypes(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the VolatileTypes class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public VolatileTypes(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the VolatileTypes class.
    /// </summary>
    public VolatileTypes() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the VolatileDependenciesPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(VolatileDependenciesPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "volType" == name)
    return new VolatileType();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VolatileTypes>(deep);
    }

}
/// <summary>
/// <para>Workbook. The root element of WorkbookPart.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:workbook.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FileVersion &lt;x:fileVersion></description></item>
///<item><description>FileSharing &lt;x:fileSharing></description></item>
///<item><description>WorkbookProperties &lt;x:workbookPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath &lt;x15ac:absPath></description></item>
///<item><description>WorkbookProtection &lt;x:workbookProtection></description></item>
///<item><description>BookViews &lt;x:bookViews></description></item>
///<item><description>Sheets &lt;x:sheets></description></item>
///<item><description>FunctionGroups &lt;x:functionGroups></description></item>
///<item><description>ExternalReferences &lt;x:externalReferences></description></item>
///<item><description>DefinedNames &lt;x:definedNames></description></item>
///<item><description>CalculationProperties &lt;x:calcPr></description></item>
///<item><description>OleSize &lt;x:oleSize></description></item>
///<item><description>CustomWorkbookViews &lt;x:customWorkbookViews></description></item>
///<item><description>PivotCaches &lt;x:pivotCaches></description></item>
///<item><description>WebPublishing &lt;x:webPublishing></description></item>
///<item><description>FileRecoveryProperties &lt;x:fileRecoveryPr></description></item>
///<item><description>WebPublishObjects &lt;x:webPublishObjects></description></item>
///<item><description>WorkbookExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FileVersion))]
    [ChildElementInfo(typeof(FileSharing))]
    [ChildElementInfo(typeof(WorkbookProperties))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(WorkbookProtection))]
    [ChildElementInfo(typeof(BookViews))]
    [ChildElementInfo(typeof(Sheets))]
    [ChildElementInfo(typeof(FunctionGroups))]
    [ChildElementInfo(typeof(ExternalReferences))]
    [ChildElementInfo(typeof(DefinedNames))]
    [ChildElementInfo(typeof(CalculationProperties))]
    [ChildElementInfo(typeof(OleSize))]
    [ChildElementInfo(typeof(CustomWorkbookViews))]
    [ChildElementInfo(typeof(PivotCaches))]
    [ChildElementInfo(typeof(WebPublishing))]
    [ChildElementInfo(typeof(FileRecoveryProperties))]
    [ChildElementInfo(typeof(WebPublishObjects))]
    [ChildElementInfo(typeof(WorkbookExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Workbook : OpenXmlPartRootElement
{
    private const string tagName = "workbook";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11114;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "conformance" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> conformance.</para>
    /// <para>Represents the following attribute in the schema: conformance </para>
    /// </summary>
    [SchemaAttr(0, "conformance")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConformanceClass> Conformance
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConformanceClass>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    /// <summary>
    /// Workbook constructor.
    /// </summary>
    /// <param name="ownerPart">The owner part of the Workbook.</param>
    internal Workbook(WorkbookPart ownerPart) : base (ownerPart )
    {
    }
    
    /// <summary>
    /// Loads the DOM from the WorkbookPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to be loaded.</param>
    public void Load(WorkbookPart openXmlPart)
    {
        LoadFromPart(openXmlPart);
    }
    /// <summary>
    /// Gets the WorkbookPart associated with this element.
    /// </summary>
    public WorkbookPart WorkbookPart
    {
		get
		{
			return OpenXmlPart as WorkbookPart;
		}
		internal set
		{
			OpenXmlPart = value;
		}
    }
    
            /// <summary>
    ///Initializes a new instance of the Workbook class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Workbook(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Workbook class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Workbook(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Workbook class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Workbook(string outerXml)
        : base(outerXml)
    {
    }

    
    
    /// <summary>
    /// Initializes a new instance of the Workbook class.
    /// </summary>
    public Workbook() : base ()
    {
    }
    
    /// <summary>
    /// Saves the DOM into the WorkbookPart.
    /// </summary>
    /// <param name="openXmlPart">Specifies the part to save to.</param>
    public void Save(WorkbookPart openXmlPart)
    {
        base.SaveToPart(openXmlPart);
    }
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "fileVersion" == name)
    return new FileVersion();
    
if( 22 == namespaceId && "fileSharing" == name)
    return new FileSharing();
    
if( 22 == namespaceId && "workbookPr" == name)
    return new WorkbookProperties();
    
if( 74 == namespaceId && "absPath" == name)
    return new DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath();
    
if( 22 == namespaceId && "workbookProtection" == name)
    return new WorkbookProtection();
    
if( 22 == namespaceId && "bookViews" == name)
    return new BookViews();
    
if( 22 == namespaceId && "sheets" == name)
    return new Sheets();
    
if( 22 == namespaceId && "functionGroups" == name)
    return new FunctionGroups();
    
if( 22 == namespaceId && "externalReferences" == name)
    return new ExternalReferences();
    
if( 22 == namespaceId && "definedNames" == name)
    return new DefinedNames();
    
if( 22 == namespaceId && "calcPr" == name)
    return new CalculationProperties();
    
if( 22 == namespaceId && "oleSize" == name)
    return new OleSize();
    
if( 22 == namespaceId && "customWorkbookViews" == name)
    return new CustomWorkbookViews();
    
if( 22 == namespaceId && "pivotCaches" == name)
    return new PivotCaches();
    
if( 22 == namespaceId && "webPublishing" == name)
    return new WebPublishing();
    
if( 22 == namespaceId && "fileRecoveryPr" == name)
    return new FileRecoveryProperties();
    
if( 22 == namespaceId && "webPublishObjects" == name)
    return new WebPublishObjects();
    
if( 22 == namespaceId && "extLst" == name)
    return new WorkbookExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fileVersion","fileSharing","workbookPr","absPath","workbookProtection","bookViews","sheets","functionGroups","externalReferences","definedNames","calcPr","oleSize","customWorkbookViews","pivotCaches","webPublishing","fileRecoveryPr","webPublishObjects","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,74,22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> FileVersion.</para>
    /// <para> Represents the following element tag in the schema: x:fileVersion </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FileVersion FileVersion
    {
        get 
        {
            return GetElement<FileVersion>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> FileSharing.</para>
    /// <para> Represents the following element tag in the schema: x:fileSharing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FileSharing FileSharing
    {
        get 
        {
            return GetElement<FileSharing>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> WorkbookProperties.</para>
    /// <para> Represents the following element tag in the schema: x:workbookPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WorkbookProperties WorkbookProperties
    {
        get 
        {
            return GetElement<WorkbookProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> AbsolutePath.</para>
    /// <para> Represents the following element tag in the schema: x15ac:absPath </para>
    /// </summary>
    /// <remark>
    /// xmlns:x15ac = http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac
    /// </remark>
    public DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath AbsolutePath
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2013.ExcelAc.AbsolutePath>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> WorkbookProtection.</para>
    /// <para> Represents the following element tag in the schema: x:workbookProtection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WorkbookProtection WorkbookProtection
    {
        get 
        {
            return GetElement<WorkbookProtection>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> BookViews.</para>
    /// <para> Represents the following element tag in the schema: x:bookViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public BookViews BookViews
    {
        get 
        {
            return GetElement<BookViews>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Sheets.</para>
    /// <para> Represents the following element tag in the schema: x:sheets </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Sheets Sheets
    {
        get 
        {
            return GetElement<Sheets>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> FunctionGroups.</para>
    /// <para> Represents the following element tag in the schema: x:functionGroups </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FunctionGroups FunctionGroups
    {
        get 
        {
            return GetElement<FunctionGroups>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ExternalReferences.</para>
    /// <para> Represents the following element tag in the schema: x:externalReferences </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExternalReferences ExternalReferences
    {
        get 
        {
            return GetElement<ExternalReferences>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> DefinedNames.</para>
    /// <para> Represents the following element tag in the schema: x:definedNames </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DefinedNames DefinedNames
    {
        get 
        {
            return GetElement<DefinedNames>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> CalculationProperties.</para>
    /// <para> Represents the following element tag in the schema: x:calcPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CalculationProperties CalculationProperties
    {
        get 
        {
            return GetElement<CalculationProperties>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> OleSize.</para>
    /// <para> Represents the following element tag in the schema: x:oleSize </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OleSize OleSize
    {
        get 
        {
            return GetElement<OleSize>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> CustomWorkbookViews.</para>
    /// <para> Represents the following element tag in the schema: x:customWorkbookViews </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CustomWorkbookViews CustomWorkbookViews
    {
        get 
        {
            return GetElement<CustomWorkbookViews>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> PivotCaches.</para>
    /// <para> Represents the following element tag in the schema: x:pivotCaches </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotCaches PivotCaches
    {
        get 
        {
            return GetElement<PivotCaches>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> WebPublishing.</para>
    /// <para> Represents the following element tag in the schema: x:webPublishing </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WebPublishing WebPublishing
    {
        get 
        {
            return GetElement<WebPublishing>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "conformance" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConformanceClass>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Workbook>(deep);
    }

}
/// <summary>
/// <para>AutoFilter Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:filterColumn.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Filters &lt;x:filters></description></item>
///<item><description>Top10 &lt;x:top10></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.CustomFilters &lt;x14:customFilters></description></item>
///<item><description>CustomFilters &lt;x:customFilters></description></item>
///<item><description>DynamicFilter &lt;x:dynamicFilter></description></item>
///<item><description>ColorFilter &lt;x:colorFilter></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.IconFilter &lt;x14:iconFilter></description></item>
///<item><description>IconFilter &lt;x:iconFilter></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Filters))]
    [ChildElementInfo(typeof(Top10))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.CustomFilters),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(CustomFilters))]
    [ChildElementInfo(typeof(DynamicFilter))]
    [ChildElementInfo(typeof(ColorFilter))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.IconFilter),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(IconFilter))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FilterColumn : OpenXmlCompositeElement
{
    private const string tagName = "filterColumn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11115;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "colId","hiddenButton","showButton" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Filter Column Data.</para>
    /// <para>Represents the following attribute in the schema: colId </para>
    /// </summary>
    [SchemaAttr(0, "colId")]
    public UInt32Value ColumnId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Hidden AutoFilter Button.</para>
    /// <para>Represents the following attribute in the schema: hiddenButton </para>
    /// </summary>
    [SchemaAttr(0, "hiddenButton")]
    public BooleanValue HiddenButton
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Filter Button.</para>
    /// <para>Represents the following attribute in the schema: showButton </para>
    /// </summary>
    [SchemaAttr(0, "showButton")]
    public BooleanValue ShowButton
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FilterColumn class.
    /// </summary>
    public FilterColumn():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FilterColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FilterColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FilterColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FilterColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FilterColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FilterColumn(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "filters" == name)
    return new Filters();
    
if( 22 == namespaceId && "top10" == name)
    return new Top10();
    
if( 53 == namespaceId && "customFilters" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.CustomFilters();
    
if( 22 == namespaceId && "customFilters" == name)
    return new CustomFilters();
    
if( 22 == namespaceId && "dynamicFilter" == name)
    return new DynamicFilter();
    
if( 22 == namespaceId && "colorFilter" == name)
    return new ColorFilter();
    
if( 53 == namespaceId && "iconFilter" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.IconFilter();
    
if( 22 == namespaceId && "iconFilter" == name)
    return new IconFilter();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "filters","top10","customFilters","customFilters","dynamicFilter","colorFilter","iconFilter","iconFilter","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,53,22,22,22,53,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Filter Criteria.</para>
    /// <para> Represents the following element tag in the schema: x:filters </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Filters Filters
    {
        get 
        {
            return GetElement<Filters>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Top 10.</para>
    /// <para> Represents the following element tag in the schema: x:top10 </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Top10 Top10
    {
        get 
        {
            return GetElement<Top10>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> CustomFilters14.</para>
    /// <para> Represents the following element tag in the schema: x14:customFilters </para>
    /// </summary>
    /// <remark>
    /// xmlns:x14 = http://schemas.microsoft.com/office/spreadsheetml/2009/9/main
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Excel.CustomFilters CustomFilters14
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Excel.CustomFilters>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Custom Filters.</para>
    /// <para> Represents the following element tag in the schema: x:customFilters </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CustomFilters CustomFilters
    {
        get 
        {
            return GetElement<CustomFilters>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Dynamic Filter.</para>
    /// <para> Represents the following element tag in the schema: x:dynamicFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DynamicFilter DynamicFilter
    {
        get 
        {
            return GetElement<DynamicFilter>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Color Filter Criteria.</para>
    /// <para> Represents the following element tag in the schema: x:colorFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ColorFilter ColorFilter
    {
        get 
        {
            return GetElement<ColorFilter>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> IconFilter14.</para>
    /// <para> Represents the following element tag in the schema: x14:iconFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x14 = http://schemas.microsoft.com/office/spreadsheetml/2009/9/main
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.Excel.IconFilter IconFilter14
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.Excel.IconFilter>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Icon Filter.</para>
    /// <para> Represents the following element tag in the schema: x:iconFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public IconFilter IconFilter
    {
        get 
        {
            return GetElement<IconFilter>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "colId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hiddenButton" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showButton" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FilterColumn>(deep);
    }

   
}
/// <summary>
/// <para>Sort State for Auto Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sortState.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SortCondition &lt;x14:sortCondition></description></item>
///<item><description>SortCondition &lt;x:sortCondition></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SortCondition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(SortCondition))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SortState : OpenXmlCompositeElement
{
    private const string tagName = "sortState";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11116;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "columnSort","caseSensitive","sortMethod","ref" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sort by Columns.</para>
    /// <para>Represents the following attribute in the schema: columnSort </para>
    /// </summary>
    [SchemaAttr(0, "columnSort")]
    public BooleanValue ColumnSort
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Case Sensitive.</para>
    /// <para>Represents the following attribute in the schema: caseSensitive </para>
    /// </summary>
    [SchemaAttr(0, "caseSensitive")]
    public BooleanValue CaseSensitive
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Sort Method.</para>
    /// <para>Represents the following attribute in the schema: sortMethod </para>
    /// </summary>
    [SchemaAttr(0, "sortMethod")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortMethodValues> SortMethod
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortMethodValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sort Range.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SortState class.
    /// </summary>
    public SortState():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SortState class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SortState(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SortState class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SortState(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SortState class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SortState(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "sortCondition" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SortCondition();
    
if( 22 == namespaceId && "sortCondition" == name)
    return new SortCondition();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "columnSort" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "caseSensitive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sortMethod" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortMethodValues>();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SortState>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Extension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Extension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11117;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class.
    /// </summary>
    public ExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new Extension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Custom Filter Criteria.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customFilter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomFilter : OpenXmlLeafElement
{
    private const string tagName = "customFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11118;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "operator","val" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Filter Comparison Operator.</para>
    /// <para>Represents the following attribute in the schema: operator </para>
    /// </summary>
    [SchemaAttr(0, "operator")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FilterOperatorValues> Operator
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FilterOperatorValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Top or Bottom Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomFilter class.
    /// </summary>
    public CustomFilter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "operator" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FilterOperatorValues>();
    
if( 0 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomFilter>(deep);
    }

   
}
/// <summary>
/// <para>Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:c.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculationCell : OpenXmlLeafElement
{
    private const string tagName = "c";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11119;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","i","s","l","t","a" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Cell Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public Int32Value SheetId
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Child Chain.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public BooleanValue InChildChain
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> New Dependency Level.</para>
    /// <para>Represents the following attribute in the schema: l </para>
    /// </summary>
    [SchemaAttr(0, "l")]
    public BooleanValue NewLevel
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> New Thread.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public BooleanValue NewThread
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Array.</para>
    /// <para>Represents the following attribute in the schema: a </para>
    /// </summary>
    [SchemaAttr(0, "a")]
    public BooleanValue Array
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculationCell class.
    /// </summary>
    public CalculationCell():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "i" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "s" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "l" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "t" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "a" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculationCell>(deep);
    }

   
}
/// <summary>
/// <para>Authors.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:authors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Author &lt;x:author></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Author))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Authors : OpenXmlCompositeElement
{
    private const string tagName = "authors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11120;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Authors class.
    /// </summary>
    public Authors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Authors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Authors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Authors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Authors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Authors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Authors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "author" == name)
    return new Author();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Authors>(deep);
    }

   
}
/// <summary>
/// <para>List of Comments.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:commentList.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Comment &lt;x:comment></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Comment))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CommentList : OpenXmlCompositeElement
{
    private const string tagName = "commentList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11121;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CommentList class.
    /// </summary>
    public CommentList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CommentList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CommentList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "comment" == name)
    return new Comment();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentList>(deep);
    }

   
}
/// <summary>
/// <para>Comment.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:comment.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CommentText &lt;x:text></description></item>
///<item><description>CommentProperties &lt;x:commentPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CommentText))]
    [ChildElementInfo(typeof(CommentProperties),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Comment : OpenXmlCompositeElement
{
    private const string tagName = "comment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11122;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref","authorId","guid","shapeId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Cell Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Author Id.</para>
    /// <para>Represents the following attribute in the schema: authorId </para>
    /// </summary>
    [SchemaAttr(0, "authorId")]
    public UInt32Value AuthorId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Unique Identifier for Comment.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> shapeId.</para>
    /// <para>Represents the following attribute in the schema: shapeId </para>
    /// </summary>
    [SchemaAttr(0, "shapeId")]
    public UInt32Value ShapeId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Comment class.
    /// </summary>
    public Comment():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Comment class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comment(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Comment class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Comment(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Comment class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Comment(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "text" == name)
    return new CommentText();
    
if( 22 == namespaceId && "commentPr" == name)
    return new CommentProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "text","commentPr" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Comment Text.</para>
    /// <para> Represents the following element tag in the schema: x:text </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CommentText CommentText
    {
        get 
        {
            return GetElement<CommentText>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> CommentProperties.</para>
    /// <para> Represents the following element tag in the schema: x:commentPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CommentProperties CommentProperties
    {
        get 
        {
            return GetElement<CommentProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "authorId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "shapeId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Comment>(deep);
    }

   
}
/// <summary>
/// <para>Author.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:author.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Author : XstringType
{
    private const string tagName = "author";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11123;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Author class.
    /// </summary>
    public Author():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Author class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Author(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Author>(deep);
    }

}
/// <summary>
/// <para>Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:t.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Text : XstringType
{
    private const string tagName = "t";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11213;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Text class.
    /// </summary>
    public Text():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Text class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Text(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Text>(deep);
    }

}
/// <summary>
/// <para>Cell Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:v.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellValue : XstringType
{
    private const string tagName = "v";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11242;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CellValue class.
    /// </summary>
    public CellValue():base(){}
    
           /// <summary>
    /// Initializes a new instance of the CellValue class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public CellValue(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellValue>(deep);
    }

}
/// <summary>
/// <para>Formula.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:formula.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Formula : XstringType
{
    private const string tagName = "formula";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11244;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Formula class.
    /// </summary>
    public Formula():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Formula class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Formula(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Formula>(deep);
    }

}
/// <summary>
/// <para>Old Formula.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oldFormula.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OldFormula : XstringType
{
    private const string tagName = "oldFormula";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11245;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OldFormula class.
    /// </summary>
    public OldFormula():base(){}
    
           /// <summary>
    /// Initializes a new instance of the OldFormula class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public OldFormula(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OldFormula>(deep);
    }

}
/// <summary>
/// <para>Odd Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oddHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OddHeader : XstringType
{
    private const string tagName = "oddHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11284;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OddHeader class.
    /// </summary>
    public OddHeader():base(){}
    
           /// <summary>
    /// Initializes a new instance of the OddHeader class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public OddHeader(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OddHeader>(deep);
    }

}
/// <summary>
/// <para>Odd Page Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oddFooter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OddFooter : XstringType
{
    private const string tagName = "oddFooter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11285;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OddFooter class.
    /// </summary>
    public OddFooter():base(){}
    
           /// <summary>
    /// Initializes a new instance of the OddFooter class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public OddFooter(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OddFooter>(deep);
    }

}
/// <summary>
/// <para>Even Page Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:evenHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EvenHeader : XstringType
{
    private const string tagName = "evenHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11286;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EvenHeader class.
    /// </summary>
    public EvenHeader():base(){}
    
           /// <summary>
    /// Initializes a new instance of the EvenHeader class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public EvenHeader(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EvenHeader>(deep);
    }

}
/// <summary>
/// <para>Even Page Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:evenFooter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class EvenFooter : XstringType
{
    private const string tagName = "evenFooter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11287;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EvenFooter class.
    /// </summary>
    public EvenFooter():base(){}
    
           /// <summary>
    /// Initializes a new instance of the EvenFooter class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public EvenFooter(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EvenFooter>(deep);
    }

}
/// <summary>
/// <para>First Page Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:firstHeader.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FirstHeader : XstringType
{
    private const string tagName = "firstHeader";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11288;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FirstHeader class.
    /// </summary>
    public FirstHeader():base(){}
    
           /// <summary>
    /// Initializes a new instance of the FirstHeader class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public FirstHeader(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FirstHeader>(deep);
    }

}
/// <summary>
/// <para>First Page Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:firstFooter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FirstFooter : XstringType
{
    private const string tagName = "firstFooter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11289;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FirstFooter class.
    /// </summary>
    public FirstFooter():base(){}
    
           /// <summary>
    /// Initializes a new instance of the FirstFooter class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public FirstFooter(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FirstFooter>(deep);
    }

}
/// <summary>
/// <para>DDE Link Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:val.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DdeLinkValue : XstringType
{
    private const string tagName = "val";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11347;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DdeLinkValue class.
    /// </summary>
    public DdeLinkValue():base(){}
    
           /// <summary>
    /// Initializes a new instance of the DdeLinkValue class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public DdeLinkValue(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DdeLinkValue>(deep);
    }

}
/// <summary>
/// <para>Strings in Subtopic.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:stp.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Subtopic : XstringType
{
    private const string tagName = "stp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11355;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Subtopic class.
    /// </summary>
    public Subtopic():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Subtopic class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Subtopic(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Subtopic>(deep);
    }

}
/// <summary>
/// <para>Defines the Formula1 Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:formula1.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Formula1 : XstringType
{
    private const string tagName = "formula1";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11505;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Formula1 class.
    /// </summary>
    public Formula1():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Formula1 class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Formula1(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Formula1>(deep);
    }

}
/// <summary>
/// <para>Defines the Formula2 Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:formula2.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Formula2 : XstringType
{
    private const string tagName = "formula2";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11506;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Formula2 class.
    /// </summary>
    public Formula2():base(){}
    
           /// <summary>
    /// Initializes a new instance of the Formula2 class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Formula2(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Formula2>(deep);
    }

}
/// <summary>
/// Defines the XstringType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class XstringType : OpenXmlLeafTextElement
{
    private static string[] attributeTagNames = { "space" };
    private static byte[] attributeNamespaceIds = { 1 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Content Contains Significant Whitespace.</para>
    /// <para>Represents the following attribute in the schema: xml:space </para>
    /// </summary>
///<remark> xmlns:xml=http://www.w3.org/XML/1998/namespace
///</remark>
    [SchemaAttr(1, "space")]
    public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues> Space
    {
        get { return (EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 1 == namespaceId && "space" == name)
    return new EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the XstringType class.
    /// </summary>
    protected XstringType(){}
    
    
           /// <summary>
    /// Initializes a new instance of the XstringType class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    protected XstringType(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

}
/// <summary>
/// <para>XML Schema.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:Schema.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Schema : OpenXmlCompositeElement
{
    private const string tagName = "Schema";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11124;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ID","SchemaRef","Namespace" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Schema ID.</para>
    /// <para>Represents the following attribute in the schema: ID </para>
    /// </summary>
    [SchemaAttr(0, "ID")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Schema Reference.</para>
    /// <para>Represents the following attribute in the schema: SchemaRef </para>
    /// </summary>
    [SchemaAttr(0, "SchemaRef")]
    public StringValue SchemaReference
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Schema Root Namespace.</para>
    /// <para>Represents the following attribute in the schema: Namespace </para>
    /// </summary>
    [SchemaAttr(0, "Namespace")]
    public StringValue Namespace
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Schema class.
    /// </summary>
    public Schema():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Schema class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Schema(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Schema class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Schema(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Schema class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Schema(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    
    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ID" == name)
    return new StringValue();
    
if( 0 == namespaceId && "SchemaRef" == name)
    return new StringValue();
    
if( 0 == namespaceId && "Namespace" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Schema>(deep);
    }

   
}
/// <summary>
/// <para>XML Mapping Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:Map.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataBinding &lt;x:DataBinding></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataBinding))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Map : OpenXmlCompositeElement
{
    private const string tagName = "Map";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11125;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ID","Name","RootElement","SchemaID","ShowImportExportValidationErrors","AutoFit","Append","PreserveSortAFLayout","PreserveFormat" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XML Mapping ID.</para>
    /// <para>Represents the following attribute in the schema: ID </para>
    /// </summary>
    [SchemaAttr(0, "ID")]
    public UInt32Value ID
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> XML Mapping Name.</para>
    /// <para>Represents the following attribute in the schema: Name </para>
    /// </summary>
    [SchemaAttr(0, "Name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Root Element Name.</para>
    /// <para>Represents the following attribute in the schema: RootElement </para>
    /// </summary>
    [SchemaAttr(0, "RootElement")]
    public StringValue RootElement
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Schema Name.</para>
    /// <para>Represents the following attribute in the schema: SchemaID </para>
    /// </summary>
    [SchemaAttr(0, "SchemaID")]
    public StringValue SchemaId
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Validation Errors.</para>
    /// <para>Represents the following attribute in the schema: ShowImportExportValidationErrors </para>
    /// </summary>
    [SchemaAttr(0, "ShowImportExportValidationErrors")]
    public BooleanValue ShowImportExportErrors
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> AutoFit Table on Refresh.</para>
    /// <para>Represents the following attribute in the schema: AutoFit </para>
    /// </summary>
    [SchemaAttr(0, "AutoFit")]
    public BooleanValue AutoFit
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Append Data to Table.</para>
    /// <para>Represents the following attribute in the schema: Append </para>
    /// </summary>
    [SchemaAttr(0, "Append")]
    public BooleanValue AppendData
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Preserve AutoFilter State.</para>
    /// <para>Represents the following attribute in the schema: PreserveSortAFLayout </para>
    /// </summary>
    [SchemaAttr(0, "PreserveSortAFLayout")]
    public BooleanValue PreserveAutoFilterState
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Preserve Cell Formatting.</para>
    /// <para>Represents the following attribute in the schema: PreserveFormat </para>
    /// </summary>
    [SchemaAttr(0, "PreserveFormat")]
    public BooleanValue PreserveFormat
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Map class.
    /// </summary>
    public Map():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Map class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Map(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Map class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Map(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Map class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Map(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "DataBinding" == name)
    return new DataBinding();
    

    return null;
}

        private static readonly string[] eleTagNames = { "DataBinding" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> XML Mapping.</para>
    /// <para> Represents the following element tag in the schema: x:DataBinding </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DataBinding DataBinding
    {
        get 
        {
            return GetElement<DataBinding>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ID" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "Name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "RootElement" == name)
    return new StringValue();
    
if( 0 == namespaceId && "SchemaID" == name)
    return new StringValue();
    
if( 0 == namespaceId && "ShowImportExportValidationErrors" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "AutoFit" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "Append" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "PreserveSortAFLayout" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "PreserveFormat" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Map>(deep);
    }

   
}
/// <summary>
/// <para>XML Mapping.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:DataBinding.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataBinding : OpenXmlCompositeElement
{
    private const string tagName = "DataBinding";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11126;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "DataBindingName","FileBinding","ConnectionID","FileBindingName","DataBindingLoadMode" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> DataBindingName.</para>
    /// <para>Represents the following attribute in the schema: DataBindingName </para>
    /// </summary>
    [SchemaAttr(0, "DataBindingName")]
    public StringValue DataBindingName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> FileBinding.</para>
    /// <para>Represents the following attribute in the schema: FileBinding </para>
    /// </summary>
    [SchemaAttr(0, "FileBinding")]
    public BooleanValue FileBinding
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> ConnectionID.</para>
    /// <para>Represents the following attribute in the schema: ConnectionID </para>
    /// </summary>
    [SchemaAttr(0, "ConnectionID")]
    public UInt32Value ConnectionId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> FileBindingName.</para>
    /// <para>Represents the following attribute in the schema: FileBindingName </para>
    /// </summary>
    [SchemaAttr(0, "FileBindingName")]
    public StringValue FileBindingName
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> DataBindingLoadMode.</para>
    /// <para>Represents the following attribute in the schema: DataBindingLoadMode </para>
    /// </summary>
    [SchemaAttr(0, "DataBindingLoadMode")]
    public UInt32Value DataBindingLoadMode
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataBinding class.
    /// </summary>
    public DataBinding():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataBinding class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataBinding(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataBinding class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataBinding(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataBinding class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataBinding(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    
    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "DataBindingName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "FileBinding" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ConnectionID" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "FileBindingName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "DataBindingLoadMode" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataBinding>(deep);
    }

   
}
/// <summary>
/// <para>Connection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:connection.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DatabaseProperties &lt;x:dbPr></description></item>
///<item><description>OlapProperties &lt;x:olapPr></description></item>
///<item><description>WebQueryProperties &lt;x:webPr></description></item>
///<item><description>TextProperties &lt;x:textPr></description></item>
///<item><description>Parameters &lt;x:parameters></description></item>
///<item><description>ConnectionExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DatabaseProperties))]
    [ChildElementInfo(typeof(OlapProperties))]
    [ChildElementInfo(typeof(WebQueryProperties))]
    [ChildElementInfo(typeof(TextProperties))]
    [ChildElementInfo(typeof(Parameters))]
    [ChildElementInfo(typeof(ConnectionExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Connection : OpenXmlCompositeElement
{
    private const string tagName = "connection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11127;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","sourceFile","odcFile","keepAlive","interval","name","description","type","reconnectionMethod","refreshedVersion","minRefreshableVersion","savePassword","new","deleted","onlyUseConnectionFile","background","refreshOnLoad","saveData","credentials","singleSignOnId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> sourceFile.</para>
    /// <para>Represents the following attribute in the schema: sourceFile </para>
    /// </summary>
    [SchemaAttr(0, "sourceFile")]
    public StringValue SourceFile
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> odcFile.</para>
    /// <para>Represents the following attribute in the schema: odcFile </para>
    /// </summary>
    [SchemaAttr(0, "odcFile")]
    public StringValue ConnectionFile
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> keepAlive.</para>
    /// <para>Represents the following attribute in the schema: keepAlive </para>
    /// </summary>
    [SchemaAttr(0, "keepAlive")]
    public BooleanValue KeepAlive
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> interval.</para>
    /// <para>Represents the following attribute in the schema: interval </para>
    /// </summary>
    [SchemaAttr(0, "interval")]
    public UInt32Value Interval
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> description.</para>
    /// <para>Represents the following attribute in the schema: description </para>
    /// </summary>
    [SchemaAttr(0, "description")]
    public StringValue Description
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public UInt32Value Type
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> reconnectionMethod.</para>
    /// <para>Represents the following attribute in the schema: reconnectionMethod </para>
    /// </summary>
    [SchemaAttr(0, "reconnectionMethod")]
    public UInt32Value ReconnectionMethod
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> refreshedVersion.</para>
    /// <para>Represents the following attribute in the schema: refreshedVersion </para>
    /// </summary>
    [SchemaAttr(0, "refreshedVersion")]
    public ByteValue RefreshedVersion
    {
        get { return (ByteValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> minRefreshableVersion.</para>
    /// <para>Represents the following attribute in the schema: minRefreshableVersion </para>
    /// </summary>
    [SchemaAttr(0, "minRefreshableVersion")]
    public ByteValue MinRefreshableVersion
    {
        get { return (ByteValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> savePassword.</para>
    /// <para>Represents the following attribute in the schema: savePassword </para>
    /// </summary>
    [SchemaAttr(0, "savePassword")]
    public BooleanValue SavePassword
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> new.</para>
    /// <para>Represents the following attribute in the schema: new </para>
    /// </summary>
    [SchemaAttr(0, "new")]
    public BooleanValue New
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> deleted.</para>
    /// <para>Represents the following attribute in the schema: deleted </para>
    /// </summary>
    [SchemaAttr(0, "deleted")]
    public BooleanValue Deleted
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> onlyUseConnectionFile.</para>
    /// <para>Represents the following attribute in the schema: onlyUseConnectionFile </para>
    /// </summary>
    [SchemaAttr(0, "onlyUseConnectionFile")]
    public BooleanValue OnlyUseConnectionFile
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> background.</para>
    /// <para>Represents the following attribute in the schema: background </para>
    /// </summary>
    [SchemaAttr(0, "background")]
    public BooleanValue Background
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> refreshOnLoad.</para>
    /// <para>Represents the following attribute in the schema: refreshOnLoad </para>
    /// </summary>
    [SchemaAttr(0, "refreshOnLoad")]
    public BooleanValue RefreshOnLoad
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> saveData.</para>
    /// <para>Represents the following attribute in the schema: saveData </para>
    /// </summary>
    [SchemaAttr(0, "saveData")]
    public BooleanValue SaveData
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> credentials.</para>
    /// <para>Represents the following attribute in the schema: credentials </para>
    /// </summary>
    [SchemaAttr(0, "credentials")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CredentialsMethodValues> Credentials
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CredentialsMethodValues>)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> singleSignOnId.</para>
    /// <para>Represents the following attribute in the schema: singleSignOnId </para>
    /// </summary>
    [SchemaAttr(0, "singleSignOnId")]
    public StringValue SingleSignOnId
    {
        get { return (StringValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Connection class.
    /// </summary>
    public Connection():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Connection class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Connection(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Connection class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Connection(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Connection class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Connection(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dbPr" == name)
    return new DatabaseProperties();
    
if( 22 == namespaceId && "olapPr" == name)
    return new OlapProperties();
    
if( 22 == namespaceId && "webPr" == name)
    return new WebQueryProperties();
    
if( 22 == namespaceId && "textPr" == name)
    return new TextProperties();
    
if( 22 == namespaceId && "parameters" == name)
    return new Parameters();
    
if( 22 == namespaceId && "extLst" == name)
    return new ConnectionExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "dbPr","olapPr","webPr","textPr","parameters","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> DatabaseProperties.</para>
    /// <para> Represents the following element tag in the schema: x:dbPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DatabaseProperties DatabaseProperties
    {
        get 
        {
            return GetElement<DatabaseProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> OlapProperties.</para>
    /// <para> Represents the following element tag in the schema: x:olapPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OlapProperties OlapProperties
    {
        get 
        {
            return GetElement<OlapProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> WebQueryProperties.</para>
    /// <para> Represents the following element tag in the schema: x:webPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WebQueryProperties WebQueryProperties
    {
        get 
        {
            return GetElement<WebQueryProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> TextProperties.</para>
    /// <para> Represents the following element tag in the schema: x:textPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TextProperties TextProperties
    {
        get 
        {
            return GetElement<TextProperties>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Parameters.</para>
    /// <para> Represents the following element tag in the schema: x:parameters </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Parameters Parameters
    {
        get 
        {
            return GetElement<Parameters>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> ConnectionExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ConnectionExtensionList ConnectionExtensionList
    {
        get 
        {
            return GetElement<ConnectionExtensionList>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sourceFile" == name)
    return new StringValue();
    
if( 0 == namespaceId && "odcFile" == name)
    return new StringValue();
    
if( 0 == namespaceId && "keepAlive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "interval" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "description" == name)
    return new StringValue();
    
if( 0 == namespaceId && "type" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "reconnectionMethod" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "refreshedVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "minRefreshableVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "savePassword" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "new" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "deleted" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "onlyUseConnectionFile" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "background" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refreshOnLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "saveData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "credentials" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CredentialsMethodValues>();
    
if( 0 == namespaceId && "singleSignOnId" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Connection>(deep);
    }

   
}
/// <summary>
/// <para>Tables.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tables.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MissingTable &lt;x:m></description></item>
///<item><description>CharacterValue &lt;x:s></description></item>
///<item><description>FieldItem &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MissingTable))]
    [ChildElementInfo(typeof(CharacterValue))]
    [ChildElementInfo(typeof(FieldItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tables : OpenXmlCompositeElement
{
    private const string tagName = "tables";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11128;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Count of Tables.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Tables class.
    /// </summary>
    public Tables():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Tables class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tables(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Tables class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tables(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Tables class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Tables(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "m" == name)
    return new MissingTable();
    
if( 22 == namespaceId && "s" == name)
    return new CharacterValue();
    
if( 22 == namespaceId && "x" == name)
    return new FieldItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tables>(deep);
    }

   
}
/// <summary>
/// <para>Parameter Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:parameter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Parameter : OpenXmlLeafElement
{
    private const string tagName = "parameter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11129;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","sqlType","parameterType","refreshOnChange","prompt","boolean","double","integer","string","cell" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Parameter Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> SQL Data Type.</para>
    /// <para>Represents the following attribute in the schema: sqlType </para>
    /// </summary>
    [SchemaAttr(0, "sqlType")]
    public Int32Value SqlType
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Parameter Type.</para>
    /// <para>Represents the following attribute in the schema: parameterType </para>
    /// </summary>
    [SchemaAttr(0, "parameterType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ParameterValues> ParameterType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ParameterValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Refresh on Change.</para>
    /// <para>Represents the following attribute in the schema: refreshOnChange </para>
    /// </summary>
    [SchemaAttr(0, "refreshOnChange")]
    public BooleanValue RefreshOnChange
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Parameter Prompt String.</para>
    /// <para>Represents the following attribute in the schema: prompt </para>
    /// </summary>
    [SchemaAttr(0, "prompt")]
    public StringValue Prompt
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Boolean.</para>
    /// <para>Represents the following attribute in the schema: boolean </para>
    /// </summary>
    [SchemaAttr(0, "boolean")]
    public BooleanValue Boolean
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Double.</para>
    /// <para>Represents the following attribute in the schema: double </para>
    /// </summary>
    [SchemaAttr(0, "double")]
    public DoubleValue Double
    {
        get { return (DoubleValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Integer.</para>
    /// <para>Represents the following attribute in the schema: integer </para>
    /// </summary>
    [SchemaAttr(0, "integer")]
    public Int32Value Integer
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> String.</para>
    /// <para>Represents the following attribute in the schema: string </para>
    /// </summary>
    [SchemaAttr(0, "string")]
    public StringValue String
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Cell Reference.</para>
    /// <para>Represents the following attribute in the schema: cell </para>
    /// </summary>
    [SchemaAttr(0, "cell")]
    public StringValue Cell
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Parameter class.
    /// </summary>
    public Parameter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sqlType" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "parameterType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ParameterValues>();
    
if( 0 == namespaceId && "refreshOnChange" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "prompt" == name)
    return new StringValue();
    
if( 0 == namespaceId && "boolean" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "double" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "integer" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "string" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cell" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Parameter>(deep);
    }

   
}
/// <summary>
/// <para>No Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:m.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MissingTable : OpenXmlLeafElement
{
    private const string tagName = "m";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11130;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the MissingTable class.
    /// </summary>
    public MissingTable():base(){}
    
      
     
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MissingTable>(deep);
    }

   
}
/// <summary>
/// <para>Character Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:s.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CharacterValue : OpenXmlLeafElement
{
    private const string tagName = "s";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11131;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CharacterValue class.
    /// </summary>
    public CharacterValue():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CharacterValue>(deep);
    }

   
}
/// <summary>
/// <para>Index.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:x.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldItem : OpenXmlLeafElement
{
    private const string tagName = "x";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11132;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shared Items Index.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldItem class.
    /// </summary>
    public FieldItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldItem>(deep);
    }

   
}
/// <summary>
/// <para>Text Import Field Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:textField.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextField : OpenXmlLeafElement
{
    private const string tagName = "textField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11133;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","position" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ExternalConnectionValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ExternalConnectionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Position.</para>
    /// <para>Represents the following attribute in the schema: position </para>
    /// </summary>
    [SchemaAttr(0, "position")]
    public UInt32Value Position
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextField class.
    /// </summary>
    public TextField():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ExternalConnectionValues>();
    
if( 0 == namespaceId && "position" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextField>(deep);
    }

   
}
/// <summary>
/// <para>PivotCache Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cacheField.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SharedItems &lt;x:sharedItems></description></item>
///<item><description>FieldGroup &lt;x:fieldGroup></description></item>
///<item><description>MemberPropertiesMap &lt;x:mpMap></description></item>
///<item><description>CacheFieldExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SharedItems))]
    [ChildElementInfo(typeof(FieldGroup))]
    [ChildElementInfo(typeof(MemberPropertiesMap))]
    [ChildElementInfo(typeof(CacheFieldExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheField : OpenXmlCompositeElement
{
    private const string tagName = "cacheField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11134;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","caption","propertyName","serverField","uniqueList","numFmtId","formula","sqlType","hierarchy","level","databaseField","mappingCount","memberPropertyField" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> caption.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> propertyName.</para>
    /// <para>Represents the following attribute in the schema: propertyName </para>
    /// </summary>
    [SchemaAttr(0, "propertyName")]
    public StringValue PropertyName
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> serverField.</para>
    /// <para>Represents the following attribute in the schema: serverField </para>
    /// </summary>
    [SchemaAttr(0, "serverField")]
    public BooleanValue ServerField
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> uniqueList.</para>
    /// <para>Represents the following attribute in the schema: uniqueList </para>
    /// </summary>
    [SchemaAttr(0, "uniqueList")]
    public BooleanValue UniqueList
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> numFmtId.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> formula.</para>
    /// <para>Represents the following attribute in the schema: formula </para>
    /// </summary>
    [SchemaAttr(0, "formula")]
    public StringValue Formula
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> sqlType.</para>
    /// <para>Represents the following attribute in the schema: sqlType </para>
    /// </summary>
    [SchemaAttr(0, "sqlType")]
    public Int32Value SqlType
    {
        get { return (Int32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> hierarchy.</para>
    /// <para>Represents the following attribute in the schema: hierarchy </para>
    /// </summary>
    [SchemaAttr(0, "hierarchy")]
    public Int32Value Hierarchy
    {
        get { return (Int32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> level.</para>
    /// <para>Represents the following attribute in the schema: level </para>
    /// </summary>
    [SchemaAttr(0, "level")]
    public UInt32Value Level
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> databaseField.</para>
    /// <para>Represents the following attribute in the schema: databaseField </para>
    /// </summary>
    [SchemaAttr(0, "databaseField")]
    public BooleanValue DatabaseField
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> mappingCount.</para>
    /// <para>Represents the following attribute in the schema: mappingCount </para>
    /// </summary>
    [SchemaAttr(0, "mappingCount")]
    public UInt32Value MappingCount
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> memberPropertyField.</para>
    /// <para>Represents the following attribute in the schema: memberPropertyField </para>
    /// </summary>
    [SchemaAttr(0, "memberPropertyField")]
    public BooleanValue MemberPropertyField
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheField class.
    /// </summary>
    public CacheField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sharedItems" == name)
    return new SharedItems();
    
if( 22 == namespaceId && "fieldGroup" == name)
    return new FieldGroup();
    
if( 22 == namespaceId && "mpMap" == name)
    return new MemberPropertiesMap();
    
if( 22 == namespaceId && "extLst" == name)
    return new CacheFieldExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sharedItems","fieldGroup","mpMap","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> SharedItems.</para>
    /// <para> Represents the following element tag in the schema: x:sharedItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SharedItems SharedItems
    {
        get 
        {
            return GetElement<SharedItems>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> FieldGroup.</para>
    /// <para> Represents the following element tag in the schema: x:fieldGroup </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FieldGroup FieldGroup
    {
        get 
        {
            return GetElement<FieldGroup>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "propertyName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "serverField" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "uniqueList" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "formula" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sqlType" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "hierarchy" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "level" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "databaseField" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "mappingCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "memberPropertyField" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheField>(deep);
    }

   
}
/// <summary>
/// <para>Page Item Values.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pages.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Page &lt;x:page></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Page))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Pages : OpenXmlCompositeElement
{
    private const string tagName = "pages";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11135;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Item String Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Pages class.
    /// </summary>
    public Pages():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Pages class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Pages(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Pages class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Pages(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Pages class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Pages(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "page" == name)
    return new Page();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Pages>(deep);
    }

   
}
/// <summary>
/// <para>Range Sets.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rangeSets.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RangeSet &lt;x:rangeSet></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RangeSet))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RangeSets : OpenXmlCompositeElement
{
    private const string tagName = "rangeSets";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11136;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference and Page Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RangeSets class.
    /// </summary>
    public RangeSets():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RangeSets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RangeSets(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RangeSets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RangeSets(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RangeSets class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RangeSets(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rangeSet" == name)
    return new RangeSet();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RangeSets>(deep);
    }

   
}
/// <summary>
/// <para>Page Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:page.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PageItem &lt;x:pageItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PageItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Page : OpenXmlCompositeElement
{
    private const string tagName = "page";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11137;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Item String Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Page class.
    /// </summary>
    public Page():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Page class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Page(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Page class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Page(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Page class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Page(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pageItem" == name)
    return new PageItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Page>(deep);
    }

   
}
/// <summary>
/// <para>Page Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageItem.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageItem : OpenXmlLeafElement
{
    private const string tagName = "pageItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11138;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Item Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageItem class.
    /// </summary>
    public PageItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageItem>(deep);
    }

   
}
/// <summary>
/// <para>Range Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rangeSet.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RangeSet : OpenXmlLeafElement
{
    private const string tagName = "rangeSet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11139;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "i1","i2","i3","i4","ref","name","sheet","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Item Index Page 1.</para>
    /// <para>Represents the following attribute in the schema: i1 </para>
    /// </summary>
    [SchemaAttr(0, "i1")]
    public UInt32Value FieldItemIndexPage1
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field Item Index Page 2.</para>
    /// <para>Represents the following attribute in the schema: i2 </para>
    /// </summary>
    [SchemaAttr(0, "i2")]
    public UInt32Value FieldItemIndexPage2
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Field Item index Page 3.</para>
    /// <para>Represents the following attribute in the schema: i3 </para>
    /// </summary>
    [SchemaAttr(0, "i3")]
    public UInt32Value FieldItemIndexPage3
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Field Item Index Page 4.</para>
    /// <para>Represents the following attribute in the schema: i4 </para>
    /// </summary>
    [SchemaAttr(0, "i4")]
    public UInt32Value FieldItemIndexPage4
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Named Range.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: sheet </para>
    /// </summary>
    [SchemaAttr(0, "sheet")]
    public StringValue Sheet
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RangeSet class.
    /// </summary>
    public RangeSet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "i1" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "i2" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "i3" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "i4" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheet" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RangeSet>(deep);
    }

   
}
/// <summary>
/// <para>No Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:m.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MissingItem : OpenXmlCompositeElement
{
    private const string tagName = "m";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11140;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "u","f","c","cp","in","bc","fc","i","un","st","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Format Index.</para>
    /// <para>Represents the following attribute in the schema: in </para>
    /// </summary>
    [SchemaAttr(0, "in")]
    public UInt32Value FormatIndex
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> background Color.</para>
    /// <para>Represents the following attribute in the schema: bc </para>
    /// </summary>
    [SchemaAttr(0, "bc")]
    public HexBinaryValue BackgroundColor
    {
        get { return (HexBinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Foreground Color.</para>
    /// <para>Represents the following attribute in the schema: fc </para>
    /// </summary>
    [SchemaAttr(0, "fc")]
    public HexBinaryValue ForegroundColor
    {
        get { return (HexBinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Italic.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Underline.</para>
    /// <para>Represents the following attribute in the schema: un </para>
    /// </summary>
    [SchemaAttr(0, "un")]
    public BooleanValue Underline
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Strikethrough.</para>
    /// <para>Represents the following attribute in the schema: st </para>
    /// </summary>
    [SchemaAttr(0, "st")]
    public BooleanValue Strikethrough
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Bold.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MissingItem class.
    /// </summary>
    public MissingItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MissingItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MissingItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MissingItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MissingItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MissingItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MissingItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    
if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "in" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "fc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "un" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "st" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MissingItem>(deep);
    }

   
}
/// <summary>
/// <para>Numeric.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:n.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberItem : OpenXmlCompositeElement
{
    private const string tagName = "n";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11141;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v","u","f","c","cp","in","bc","fc","i","un","st","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public DoubleValue Val
    {
        get { return (DoubleValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Format Index.</para>
    /// <para>Represents the following attribute in the schema: in </para>
    /// </summary>
    [SchemaAttr(0, "in")]
    public UInt32Value FormatIndex
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Background Color.</para>
    /// <para>Represents the following attribute in the schema: bc </para>
    /// </summary>
    [SchemaAttr(0, "bc")]
    public HexBinaryValue BackgroundColor
    {
        get { return (HexBinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Foreground Color.</para>
    /// <para>Represents the following attribute in the schema: fc </para>
    /// </summary>
    [SchemaAttr(0, "fc")]
    public HexBinaryValue ForegroundColor
    {
        get { return (HexBinaryValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Italic.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Underline.</para>
    /// <para>Represents the following attribute in the schema: un </para>
    /// </summary>
    [SchemaAttr(0, "un")]
    public BooleanValue Underline
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Strikethrough.</para>
    /// <para>Represents the following attribute in the schema: st </para>
    /// </summary>
    [SchemaAttr(0, "st")]
    public BooleanValue Strikethrough
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Bold.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberItem class.
    /// </summary>
    public NumberItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    
if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "in" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "fc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "un" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "st" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberItem>(deep);
    }

   
}
/// <summary>
/// <para>Boolean.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:b.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BooleanItem : OpenXmlCompositeElement
{
    private const string tagName = "b";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11142;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v","u","f","c","cp" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public BooleanValue Val
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the BooleanItem class.
    /// </summary>
    public BooleanItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BooleanItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BooleanItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BooleanItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BooleanItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BooleanItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BooleanItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BooleanItem>(deep);
    }

   
}
/// <summary>
/// <para>Error Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:e.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ErrorItem : OpenXmlCompositeElement
{
    private const string tagName = "e";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11143;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v","u","f","c","cp","in","bc","fc","i","un","st","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Item Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Format Index.</para>
    /// <para>Represents the following attribute in the schema: in </para>
    /// </summary>
    [SchemaAttr(0, "in")]
    public UInt32Value FormatIndex
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> background Color.</para>
    /// <para>Represents the following attribute in the schema: bc </para>
    /// </summary>
    [SchemaAttr(0, "bc")]
    public HexBinaryValue BackgroundColor
    {
        get { return (HexBinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Foreground Color.</para>
    /// <para>Represents the following attribute in the schema: fc </para>
    /// </summary>
    [SchemaAttr(0, "fc")]
    public HexBinaryValue ForegroundColor
    {
        get { return (HexBinaryValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Italic.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Underline.</para>
    /// <para>Represents the following attribute in the schema: un </para>
    /// </summary>
    [SchemaAttr(0, "un")]
    public BooleanValue Underline
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Strikethrough.</para>
    /// <para>Represents the following attribute in the schema: st </para>
    /// </summary>
    [SchemaAttr(0, "st")]
    public BooleanValue Strikethrough
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Bold.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ErrorItem class.
    /// </summary>
    public ErrorItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ErrorItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ErrorItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ErrorItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ErrorItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ErrorItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ErrorItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    
if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tpls","x" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Tuples.</para>
    /// <para> Represents the following element tag in the schema: x:tpls </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Tuples Tuples
    {
        get 
        {
            return GetElement<Tuples>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new StringValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "in" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "fc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "un" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "st" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ErrorItem>(deep);
    }

   
}
/// <summary>
/// <para>Character Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:s.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StringItem : OpenXmlCompositeElement
{
    private const string tagName = "s";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11144;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v","u","f","c","cp","in","bc","fc","i","un","st","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Item Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Format Index.</para>
    /// <para>Represents the following attribute in the schema: in </para>
    /// </summary>
    [SchemaAttr(0, "in")]
    public UInt32Value FormatIndex
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Background Color.</para>
    /// <para>Represents the following attribute in the schema: bc </para>
    /// </summary>
    [SchemaAttr(0, "bc")]
    public HexBinaryValue BackgroundColor
    {
        get { return (HexBinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Foreground Color.</para>
    /// <para>Represents the following attribute in the schema: fc </para>
    /// </summary>
    [SchemaAttr(0, "fc")]
    public HexBinaryValue ForegroundColor
    {
        get { return (HexBinaryValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Italic.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Underline.</para>
    /// <para>Represents the following attribute in the schema: un </para>
    /// </summary>
    [SchemaAttr(0, "un")]
    public BooleanValue Underline
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Strikethrough.</para>
    /// <para>Represents the following attribute in the schema: st </para>
    /// </summary>
    [SchemaAttr(0, "st")]
    public BooleanValue Strikethrough
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Bold.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StringItem class.
    /// </summary>
    public StringItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StringItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StringItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StringItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StringItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StringItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StringItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    
if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new StringValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "in" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "fc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "un" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "st" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StringItem>(deep);
    }

   
}
/// <summary>
/// <para>Date Time.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:d.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DateTimeItem : OpenXmlCompositeElement
{
    private const string tagName = "d";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11145;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "v","u","f","c","cp" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public DateTimeValue Val
    {
        get { return (DateTimeValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unused Item.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Unused
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item Value.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Caption.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Member Property Count.</para>
    /// <para>Represents the following attribute in the schema: cp </para>
    /// </summary>
    [SchemaAttr(0, "cp")]
    public UInt32Value PropertyCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DateTimeItem class.
    /// </summary>
    public DateTimeItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DateTimeItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DateTimeItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DateTimeItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DateTimeItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DateTimeItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DateTimeItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cp" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DateTimeItem>(deep);
    }

   
}
/// <summary>
/// <para>Tuples.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tpls.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuple &lt;x:tpl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tuples : TuplesType
{
    private const string tagName = "tpls";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11146;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Tuples class.
    /// </summary>
    public Tuples():base(){}
            /// <summary>
    ///Initializes a new instance of the Tuples class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tuples(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Tuples class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Tuples(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Tuples class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Tuples(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tuples>(deep);
    }

}
/// <summary>
/// <para>Sort By Tuple.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sortByTuple.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuple &lt;x:tpl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SortByTuple : TuplesType
{
    private const string tagName = "sortByTuple";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11163;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SortByTuple class.
    /// </summary>
    public SortByTuple():base(){}
            /// <summary>
    ///Initializes a new instance of the SortByTuple class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SortByTuple(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SortByTuple class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SortByTuple(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SortByTuple class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SortByTuple(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SortByTuple>(deep);
    }

}
/// <summary>
/// Defines the TuplesType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuple &lt;x:tpl></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuple))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TuplesType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "c" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Member Name Count.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public UInt32Value MemberNameCount
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpl" == name)
    return new Tuple();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "c" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TuplesType class.
    /// </summary>
    protected TuplesType(){}
    
            /// <summary>
    ///Initializes a new instance of the TuplesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TuplesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TuplesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected TuplesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TuplesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected TuplesType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Member Property Indexes.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:x.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MemberPropertyIndex : XType
{
    private const string tagName = "x";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11147;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MemberPropertyIndex class.
    /// </summary>
    public MemberPropertyIndex():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MemberPropertyIndex>(deep);
    }

}
/// <summary>
/// <para>Defines the MemberPropertiesMap Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mpMap.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MemberPropertiesMap : XType
{
    private const string tagName = "mpMap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11462;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the MemberPropertiesMap class.
    /// </summary>
    public MemberPropertiesMap():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MemberPropertiesMap>(deep);
    }

}
/// <summary>
/// Defines the XType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class XType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "v" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Shared Items Index.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "v" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the XType class.
    /// </summary>
    protected XType(){}
    
    
    
}
/// <summary>
/// <para>PivotCache Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:r.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MissingItem &lt;x:m></description></item>
///<item><description>NumberItem &lt;x:n></description></item>
///<item><description>BooleanItem &lt;x:b></description></item>
///<item><description>ErrorItem &lt;x:e></description></item>
///<item><description>StringItem &lt;x:s></description></item>
///<item><description>DateTimeItem &lt;x:d></description></item>
///<item><description>FieldItem &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MissingItem))]
    [ChildElementInfo(typeof(NumberItem))]
    [ChildElementInfo(typeof(BooleanItem))]
    [ChildElementInfo(typeof(ErrorItem))]
    [ChildElementInfo(typeof(StringItem))]
    [ChildElementInfo(typeof(DateTimeItem))]
    [ChildElementInfo(typeof(FieldItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCacheRecord : OpenXmlCompositeElement
{
    private const string tagName = "r";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11148;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecord class.
    /// </summary>
    public PivotCacheRecord():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotCacheRecord class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheRecord(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecord class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheRecord(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheRecord class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCacheRecord(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "m" == name)
    return new MissingItem();
    
if( 22 == namespaceId && "n" == name)
    return new NumberItem();
    
if( 22 == namespaceId && "b" == name)
    return new BooleanItem();
    
if( 22 == namespaceId && "e" == name)
    return new ErrorItem();
    
if( 22 == namespaceId && "s" == name)
    return new StringItem();
    
if( 22 == namespaceId && "d" == name)
    return new DateTimeItem();
    
if( 22 == namespaceId && "x" == name)
    return new FieldItem();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCacheRecord>(deep);
    }

   
}
/// <summary>
/// <para>OLAP KPI.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:kpi.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Kpi : OpenXmlLeafElement
{
    private const string tagName = "kpi";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11149;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uniqueName","caption","displayFolder","measureGroup","parent","value","goal","status","trend","weight" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> KPI Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> KPI Display Name.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> KPI Display Folder.</para>
    /// <para>Represents the following attribute in the schema: displayFolder </para>
    /// </summary>
    [SchemaAttr(0, "displayFolder")]
    public StringValue DisplayFolder
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> KPI Measure Group Name.</para>
    /// <para>Represents the following attribute in the schema: measureGroup </para>
    /// </summary>
    [SchemaAttr(0, "measureGroup")]
    public StringValue MeasureGroup
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Parent KPI.</para>
    /// <para>Represents the following attribute in the schema: parent </para>
    /// </summary>
    [SchemaAttr(0, "parent")]
    public StringValue ParentKpi
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> KPI Value Unique Name.</para>
    /// <para>Represents the following attribute in the schema: value </para>
    /// </summary>
    [SchemaAttr(0, "value")]
    public StringValue Value
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> KPI Goal Unique Name.</para>
    /// <para>Represents the following attribute in the schema: goal </para>
    /// </summary>
    [SchemaAttr(0, "goal")]
    public StringValue Goal
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> KPI Status Unique Name.</para>
    /// <para>Represents the following attribute in the schema: status </para>
    /// </summary>
    [SchemaAttr(0, "status")]
    public StringValue Status
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> KPI Trend Unique Name.</para>
    /// <para>Represents the following attribute in the schema: trend </para>
    /// </summary>
    [SchemaAttr(0, "trend")]
    public StringValue Trend
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> KPI Weight Unique Name.</para>
    /// <para>Represents the following attribute in the schema: weight </para>
    /// </summary>
    [SchemaAttr(0, "weight")]
    public StringValue Weight
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Kpi class.
    /// </summary>
    public Kpi():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "displayFolder" == name)
    return new StringValue();
    
if( 0 == namespaceId && "measureGroup" == name)
    return new StringValue();
    
if( 0 == namespaceId && "parent" == name)
    return new StringValue();
    
if( 0 == namespaceId && "value" == name)
    return new StringValue();
    
if( 0 == namespaceId && "goal" == name)
    return new StringValue();
    
if( 0 == namespaceId && "status" == name)
    return new StringValue();
    
if( 0 == namespaceId && "trend" == name)
    return new StringValue();
    
if( 0 == namespaceId && "weight" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Kpi>(deep);
    }

   
}
/// <summary>
/// <para>PivotCache Field Id.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fieldUsage.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldUsage : OpenXmlLeafElement
{
    private const string tagName = "fieldUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11150;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "x" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public Int32Value Index
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldUsage class.
    /// </summary>
    public FieldUsage():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldUsage>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Grouping Levels.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groupLevel.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Groups &lt;x:groups></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Groups))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupLevel : OpenXmlCompositeElement
{
    private const string tagName = "groupLevel";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11151;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uniqueName","caption","user","customRollUp" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Grouping Level Display Name.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> User-Defined Group Level.</para>
    /// <para>Represents the following attribute in the schema: user </para>
    /// </summary>
    [SchemaAttr(0, "user")]
    public BooleanValue User
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Custom Roll Up.</para>
    /// <para>Represents the following attribute in the schema: customRollUp </para>
    /// </summary>
    [SchemaAttr(0, "customRollUp")]
    public BooleanValue CustomRollUp
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupLevel class.
    /// </summary>
    public GroupLevel():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupLevel class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupLevel(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupLevel class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupLevel(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupLevel class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupLevel(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "groups" == name)
    return new Groups();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "groups","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> OLAP Level Groups.</para>
    /// <para> Represents the following element tag in the schema: x:groups </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Groups Groups
    {
        get 
        {
            return GetElement<Groups>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "user" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customRollUp" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupLevel>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Level Groups.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groups.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Group &lt;x:group></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Group))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Groups : OpenXmlCompositeElement
{
    private const string tagName = "groups";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11152;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Level Group Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Groups class.
    /// </summary>
    public Groups():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Groups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Groups(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Groups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Groups(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Groups class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Groups(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "group" == name)
    return new Group();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Groups>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Group.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:group.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GroupMembers &lt;x:groupMembers></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GroupMembers))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Group : OpenXmlCompositeElement
{
    private const string tagName = "group";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11153;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","uniqueName","caption","uniqueParent","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Group Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unique Group Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Group Caption.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Parent Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueParent </para>
    /// </summary>
    [SchemaAttr(0, "uniqueParent")]
    public StringValue UniqueParent
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Group Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Group class.
    /// </summary>
    public Group():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Group class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Group(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Group class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Group(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Group class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Group(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "groupMembers" == name)
    return new GroupMembers();
    

    return null;
}

        private static readonly string[] eleTagNames = { "groupMembers" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> OLAP Group Members.</para>
    /// <para> Represents the following element tag in the schema: x:groupMembers </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public GroupMembers GroupMembers
    {
        get 
        {
            return GetElement<GroupMembers>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "uniqueParent" == name)
    return new StringValue();
    
if( 0 == namespaceId && "id" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Group>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Group Members.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groupMembers.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GroupMember &lt;x:groupMember></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GroupMember))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupMembers : OpenXmlCompositeElement
{
    private const string tagName = "groupMembers";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11154;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Group Member Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupMembers class.
    /// </summary>
    public GroupMembers():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupMembers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupMembers(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupMembers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupMembers(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupMembers class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupMembers(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "groupMember" == name)
    return new GroupMember();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupMembers>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Group Member.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groupMember.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupMember : OpenXmlLeafElement
{
    private const string tagName = "groupMember";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11155;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uniqueName","group" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Group Member Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Group.</para>
    /// <para>Represents the following attribute in the schema: group </para>
    /// </summary>
    [SchemaAttr(0, "group")]
    public BooleanValue Group
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupMember class.
    /// </summary>
    public GroupMember():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "group" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupMember>(deep);
    }

   
}
/// <summary>
/// <para>Entries.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:entries.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MissingItem &lt;x:m></description></item>
///<item><description>NumberItem &lt;x:n></description></item>
///<item><description>ErrorItem &lt;x:e></description></item>
///<item><description>StringItem &lt;x:s></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MissingItem))]
    [ChildElementInfo(typeof(NumberItem))]
    [ChildElementInfo(typeof(ErrorItem))]
    [ChildElementInfo(typeof(StringItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Entries : OpenXmlCompositeElement
{
    private const string tagName = "entries";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11156;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Tuple Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Entries class.
    /// </summary>
    public Entries():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Entries class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Entries(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Entries class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Entries(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Entries class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Entries(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "m" == name)
    return new MissingItem();
    
if( 22 == namespaceId && "n" == name)
    return new NumberItem();
    
if( 22 == namespaceId && "e" == name)
    return new ErrorItem();
    
if( 22 == namespaceId && "s" == name)
    return new StringItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Entries>(deep);
    }

   
}
/// <summary>
/// <para>Sets.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sets.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TupleSet &lt;x:set></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TupleSet))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Sets : OpenXmlCompositeElement
{
    private const string tagName = "sets";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11157;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Tuple Set Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Sets class.
    /// </summary>
    public Sets():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Sets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Sets(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Sets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Sets(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Sets class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Sets(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "set" == name)
    return new TupleSet();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Sets>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Query Cache.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryCache.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Query &lt;x:query></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Query))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryCache : OpenXmlCompositeElement
{
    private const string tagName = "queryCache";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11158;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Cached Query Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryCache class.
    /// </summary>
    public QueryCache():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryCache class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryCache(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryCache class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryCache(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryCache class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryCache(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "query" == name)
    return new Query();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryCache>(deep);
    }

   
}
/// <summary>
/// <para>Server Formats.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:serverFormats.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ServerFormat &lt;x:serverFormat></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ServerFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ServerFormats : OpenXmlCompositeElement
{
    private const string tagName = "serverFormats";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11159;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ServerFormats class.
    /// </summary>
    public ServerFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ServerFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ServerFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ServerFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ServerFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ServerFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ServerFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "serverFormat" == name)
    return new ServerFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ServerFormats>(deep);
    }

   
}
/// <summary>
/// <para>Server Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:serverFormat.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ServerFormat : OpenXmlLeafElement
{
    private const string tagName = "serverFormat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11160;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "culture","format" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Culture.</para>
    /// <para>Represents the following attribute in the schema: culture </para>
    /// </summary>
    [SchemaAttr(0, "culture")]
    public StringValue Culture
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Format.</para>
    /// <para>Represents the following attribute in the schema: format </para>
    /// </summary>
    [SchemaAttr(0, "format")]
    public StringValue Format
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ServerFormat class.
    /// </summary>
    public ServerFormat():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "culture" == name)
    return new StringValue();
    
if( 0 == namespaceId && "format" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ServerFormat>(deep);
    }

   
}
/// <summary>
/// <para>Tuple.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tpl.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Tuple : OpenXmlLeafElement
{
    private const string tagName = "tpl";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11161;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fld","hier","item" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: fld </para>
    /// </summary>
    [SchemaAttr(0, "fld")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Hierarchy Index.</para>
    /// <para>Represents the following attribute in the schema: hier </para>
    /// </summary>
    [SchemaAttr(0, "hier")]
    public UInt32Value Hierarchy
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Item Index.</para>
    /// <para>Represents the following attribute in the schema: item </para>
    /// </summary>
    [SchemaAttr(0, "item")]
    public UInt32Value Item
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Tuple class.
    /// </summary>
    public Tuple():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fld" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hier" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "item" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Tuple>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:set.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
///<item><description>SortByTuple &lt;x:sortByTuple></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
    [ChildElementInfo(typeof(SortByTuple))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TupleSet : OpenXmlCompositeElement
{
    private const string tagName = "set";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11162;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count","maxRank","setDefinition","sortType","queryFailed" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Number of Tuples.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Rank Requested.</para>
    /// <para>Represents the following attribute in the schema: maxRank </para>
    /// </summary>
    [SchemaAttr(0, "maxRank")]
    public Int32Value MaxRank
    {
        get { return (Int32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> MDX Set Definition.</para>
    /// <para>Represents the following attribute in the schema: setDefinition </para>
    /// </summary>
    [SchemaAttr(0, "setDefinition")]
    public StringValue SetDefinition
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Set Sort Order.</para>
    /// <para>Represents the following attribute in the schema: sortType </para>
    /// </summary>
    [SchemaAttr(0, "sortType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortValues> SortType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Query Failed.</para>
    /// <para>Represents the following attribute in the schema: queryFailed </para>
    /// </summary>
    [SchemaAttr(0, "queryFailed")]
    public BooleanValue QueryFailed
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TupleSet class.
    /// </summary>
    public TupleSet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TupleSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TupleSet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TupleSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TupleSet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TupleSet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TupleSet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    
if( 22 == namespaceId && "sortByTuple" == name)
    return new SortByTuple();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "maxRank" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "setDefinition" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sortType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortValues>();
    
if( 0 == namespaceId && "queryFailed" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TupleSet>(deep);
    }

   
}
/// <summary>
/// <para>Query.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:query.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tuples &lt;x:tpls></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tuples))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Query : OpenXmlCompositeElement
{
    private const string tagName = "query";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11164;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "mdx" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> MDX Query String.</para>
    /// <para>Represents the following attribute in the schema: mdx </para>
    /// </summary>
    [SchemaAttr(0, "mdx")]
    public StringValue Mdx
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Query class.
    /// </summary>
    public Query():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Query class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Query(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Query class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Query(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Query class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Query(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tpls" == name)
    return new Tuples();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tpls" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Tuples.</para>
    /// <para> Represents the following element tag in the schema: x:tpls </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Tuples Tuples
    {
        get 
        {
            return GetElement<Tuples>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "mdx" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Query>(deep);
    }

   
}
/// <summary>
/// <para>Calculated Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calculatedItem.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedItem : OpenXmlCompositeElement
{
    private const string tagName = "calculatedItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11165;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "field","formula" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: field </para>
    /// </summary>
    [SchemaAttr(0, "field")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Item Formula.</para>
    /// <para>Represents the following attribute in the schema: formula </para>
    /// </summary>
    [SchemaAttr(0, "formula")]
    public StringValue Formula
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedItem class.
    /// </summary>
    public CalculatedItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotArea","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Calculated Item Location.</para>
    /// <para> Represents the following element tag in the schema: x:pivotArea </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotArea PivotArea
    {
        get 
        {
            return GetElement<PivotArea>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "field" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "formula" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedItem>(deep);
    }

   
}
/// <summary>
/// <para>Calculated Item Location.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotArea.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotAreaReferences &lt;x:references></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotAreaReferences))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotArea : OpenXmlCompositeElement
{
    private const string tagName = "pivotArea";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11166;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "field","type","dataOnly","labelOnly","grandRow","grandCol","cacheIndex","outline","offset","collapsedLevelsAreSubtotals","axis","fieldPosition" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: field </para>
    /// </summary>
    [SchemaAttr(0, "field")]
    public Int32Value Field
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Rule Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotAreaValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotAreaValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Data Only.</para>
    /// <para>Represents the following attribute in the schema: dataOnly </para>
    /// </summary>
    [SchemaAttr(0, "dataOnly")]
    public BooleanValue DataOnly
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Labels Only.</para>
    /// <para>Represents the following attribute in the schema: labelOnly </para>
    /// </summary>
    [SchemaAttr(0, "labelOnly")]
    public BooleanValue LabelOnly
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Include Row Grand Total.</para>
    /// <para>Represents the following attribute in the schema: grandRow </para>
    /// </summary>
    [SchemaAttr(0, "grandRow")]
    public BooleanValue GrandRow
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Include Column Grand Total.</para>
    /// <para>Represents the following attribute in the schema: grandCol </para>
    /// </summary>
    [SchemaAttr(0, "grandCol")]
    public BooleanValue GrandColumn
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Cache Index.</para>
    /// <para>Represents the following attribute in the schema: cacheIndex </para>
    /// </summary>
    [SchemaAttr(0, "cacheIndex")]
    public BooleanValue CacheIndex
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Outline.</para>
    /// <para>Represents the following attribute in the schema: outline </para>
    /// </summary>
    [SchemaAttr(0, "outline")]
    public BooleanValue Outline
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Offset Reference.</para>
    /// <para>Represents the following attribute in the schema: offset </para>
    /// </summary>
    [SchemaAttr(0, "offset")]
    public StringValue Offset
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Collapsed Levels Are Subtotals.</para>
    /// <para>Represents the following attribute in the schema: collapsedLevelsAreSubtotals </para>
    /// </summary>
    [SchemaAttr(0, "collapsedLevelsAreSubtotals")]
    public BooleanValue CollapsedLevelsAreSubtotals
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Axis.</para>
    /// <para>Represents the following attribute in the schema: axis </para>
    /// </summary>
    [SchemaAttr(0, "axis")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues> Axis
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Field Position.</para>
    /// <para>Represents the following attribute in the schema: fieldPosition </para>
    /// </summary>
    [SchemaAttr(0, "fieldPosition")]
    public UInt32Value FieldPosition
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotArea class.
    /// </summary>
    public PivotArea():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotArea class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotArea(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotArea class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotArea(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotArea class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotArea(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "references" == name)
    return new PivotAreaReferences();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "references","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> References.</para>
    /// <para> Represents the following element tag in the schema: x:references </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotAreaReferences PivotAreaReferences
    {
        get 
        {
            return GetElement<PivotAreaReferences>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "field" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotAreaValues>();
    
if( 0 == namespaceId && "dataOnly" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "labelOnly" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "grandRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "grandCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "cacheIndex" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outline" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "offset" == name)
    return new StringValue();
    
if( 0 == namespaceId && "collapsedLevelsAreSubtotals" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "axis" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>();
    
if( 0 == namespaceId && "fieldPosition" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotArea>(deep);
    }

   
}
/// <summary>
/// <para>Calculated Member.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calculatedMember.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculatedMemberExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculatedMemberExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedMember : OpenXmlCompositeElement
{
    private const string tagName = "calculatedMember";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11167;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","mdx","memberName","hierarchy","parent","solveOrder","set" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> mdx.</para>
    /// <para>Represents the following attribute in the schema: mdx </para>
    /// </summary>
    [SchemaAttr(0, "mdx")]
    public StringValue Mdx
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> memberName.</para>
    /// <para>Represents the following attribute in the schema: memberName </para>
    /// </summary>
    [SchemaAttr(0, "memberName")]
    public StringValue MemberName
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> hierarchy.</para>
    /// <para>Represents the following attribute in the schema: hierarchy </para>
    /// </summary>
    [SchemaAttr(0, "hierarchy")]
    public StringValue Hierarchy
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> parent.</para>
    /// <para>Represents the following attribute in the schema: parent </para>
    /// </summary>
    [SchemaAttr(0, "parent")]
    public StringValue ParentName
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> solveOrder.</para>
    /// <para>Represents the following attribute in the schema: solveOrder </para>
    /// </summary>
    [SchemaAttr(0, "solveOrder")]
    public Int32Value SolveOrder
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> set.</para>
    /// <para>Represents the following attribute in the schema: set </para>
    /// </summary>
    [SchemaAttr(0, "set")]
    public BooleanValue Set
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedMember class.
    /// </summary>
    public CalculatedMember():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedMember class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMember(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMember class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMember(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMember class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedMember(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new CalculatedMemberExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> CalculatedMemberExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CalculatedMemberExtensionList CalculatedMemberExtensionList
    {
        get 
        {
            return GetElement<CalculatedMemberExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "mdx" == name)
    return new StringValue();
    
if( 0 == namespaceId && "memberName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hierarchy" == name)
    return new StringValue();
    
if( 0 == namespaceId && "parent" == name)
    return new StringValue();
    
if( 0 == namespaceId && "solveOrder" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "set" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedMember>(deep);
    }

   
}
/// <summary>
/// <para>PivotTable Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotField.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Items &lt;x:items></description></item>
///<item><description>AutoSortScope &lt;x:autoSortScope></description></item>
///<item><description>PivotFieldExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Items))]
    [ChildElementInfo(typeof(AutoSortScope))]
    [ChildElementInfo(typeof(PivotFieldExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotField : OpenXmlCompositeElement
{
    private const string tagName = "pivotField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11168;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","axis","dataField","subtotalCaption","showDropDowns","hiddenLevel","uniqueMemberProperty","compact","allDrilled","numFmtId","outline","subtotalTop","dragToRow","dragToCol","multipleItemSelectionAllowed","dragToPage","dragToData","dragOff","showAll","insertBlankRow","serverField","insertPageBreak","autoShow","topAutoShow","hideNewItems","measureFilter","includeNewItemsInFilter","itemPageCount","sortType","dataSourceSort","nonAutoSortDefault","rankBy","defaultSubtotal","sumSubtotal","countASubtotal","avgSubtotal","maxSubtotal","minSubtotal","productSubtotal","countSubtotal","stdDevSubtotal","stdDevPSubtotal","varSubtotal","varPSubtotal","showPropCell","showPropTip","showPropAsCaption","defaultAttributeDrillState" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Axis.</para>
    /// <para>Represents the following attribute in the schema: axis </para>
    /// </summary>
    [SchemaAttr(0, "axis")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues> Axis
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Data Field.</para>
    /// <para>Represents the following attribute in the schema: dataField </para>
    /// </summary>
    [SchemaAttr(0, "dataField")]
    public BooleanValue DataField
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Custom Subtotal Caption.</para>
    /// <para>Represents the following attribute in the schema: subtotalCaption </para>
    /// </summary>
    [SchemaAttr(0, "subtotalCaption")]
    public StringValue SubtotalCaption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show PivotField Header Drop Downs.</para>
    /// <para>Represents the following attribute in the schema: showDropDowns </para>
    /// </summary>
    [SchemaAttr(0, "showDropDowns")]
    public BooleanValue ShowDropDowns
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Level.</para>
    /// <para>Represents the following attribute in the schema: hiddenLevel </para>
    /// </summary>
    [SchemaAttr(0, "hiddenLevel")]
    public BooleanValue HiddenLevel
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Unique Member Property.</para>
    /// <para>Represents the following attribute in the schema: uniqueMemberProperty </para>
    /// </summary>
    [SchemaAttr(0, "uniqueMemberProperty")]
    public StringValue UniqueMemberProperty
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Compact.</para>
    /// <para>Represents the following attribute in the schema: compact </para>
    /// </summary>
    [SchemaAttr(0, "compact")]
    public BooleanValue Compact
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> All Items Expanded.</para>
    /// <para>Represents the following attribute in the schema: allDrilled </para>
    /// </summary>
    [SchemaAttr(0, "allDrilled")]
    public BooleanValue AllDrilled
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Number Format Id.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Outline Items.</para>
    /// <para>Represents the following attribute in the schema: outline </para>
    /// </summary>
    [SchemaAttr(0, "outline")]
    public BooleanValue Outline
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Subtotals At Top.</para>
    /// <para>Represents the following attribute in the schema: subtotalTop </para>
    /// </summary>
    [SchemaAttr(0, "subtotalTop")]
    public BooleanValue SubtotalTop
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Drag To Row.</para>
    /// <para>Represents the following attribute in the schema: dragToRow </para>
    /// </summary>
    [SchemaAttr(0, "dragToRow")]
    public BooleanValue DragToRow
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Drag To Column.</para>
    /// <para>Represents the following attribute in the schema: dragToCol </para>
    /// </summary>
    [SchemaAttr(0, "dragToCol")]
    public BooleanValue DragToColumn
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Multiple Field Filters.</para>
    /// <para>Represents the following attribute in the schema: multipleItemSelectionAllowed </para>
    /// </summary>
    [SchemaAttr(0, "multipleItemSelectionAllowed")]
    public BooleanValue MultipleItemSelectionAllowed
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Drag Field to Page.</para>
    /// <para>Represents the following attribute in the schema: dragToPage </para>
    /// </summary>
    [SchemaAttr(0, "dragToPage")]
    public BooleanValue DragToPage
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Field Can Drag to Data.</para>
    /// <para>Represents the following attribute in the schema: dragToData </para>
    /// </summary>
    [SchemaAttr(0, "dragToData")]
    public BooleanValue DragToData
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Drag Off.</para>
    /// <para>Represents the following attribute in the schema: dragOff </para>
    /// </summary>
    [SchemaAttr(0, "dragOff")]
    public BooleanValue DragOff
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Show All Items.</para>
    /// <para>Represents the following attribute in the schema: showAll </para>
    /// </summary>
    [SchemaAttr(0, "showAll")]
    public BooleanValue ShowAll
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Insert Blank Row.</para>
    /// <para>Represents the following attribute in the schema: insertBlankRow </para>
    /// </summary>
    [SchemaAttr(0, "insertBlankRow")]
    public BooleanValue InsertBlankRow
    {
        get { return (BooleanValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Server-based Page Field.</para>
    /// <para>Represents the following attribute in the schema: serverField </para>
    /// </summary>
    [SchemaAttr(0, "serverField")]
    public BooleanValue ServerField
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Insert Item Page Break.</para>
    /// <para>Represents the following attribute in the schema: insertPageBreak </para>
    /// </summary>
    [SchemaAttr(0, "insertPageBreak")]
    public BooleanValue InsertPageBreak
    {
        get { return (BooleanValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    
    /// <summary>
    /// <para> Auto Show.</para>
    /// <para>Represents the following attribute in the schema: autoShow </para>
    /// </summary>
    [SchemaAttr(0, "autoShow")]
    public BooleanValue AutoShow
    {
        get { return (BooleanValue)Attributes[22]; }
        set { Attributes[22] = value; }
    }
    
    /// <summary>
    /// <para> Top Auto Show.</para>
    /// <para>Represents the following attribute in the schema: topAutoShow </para>
    /// </summary>
    [SchemaAttr(0, "topAutoShow")]
    public BooleanValue TopAutoShow
    {
        get { return (BooleanValue)Attributes[23]; }
        set { Attributes[23] = value; }
    }
    
    /// <summary>
    /// <para> Hide New Items.</para>
    /// <para>Represents the following attribute in the schema: hideNewItems </para>
    /// </summary>
    [SchemaAttr(0, "hideNewItems")]
    public BooleanValue HideNewItems
    {
        get { return (BooleanValue)Attributes[24]; }
        set { Attributes[24] = value; }
    }
    
    /// <summary>
    /// <para> Measure Filter.</para>
    /// <para>Represents the following attribute in the schema: measureFilter </para>
    /// </summary>
    [SchemaAttr(0, "measureFilter")]
    public BooleanValue MeasureFilter
    {
        get { return (BooleanValue)Attributes[25]; }
        set { Attributes[25] = value; }
    }
    
    /// <summary>
    /// <para> Inclusive Manual Filter.</para>
    /// <para>Represents the following attribute in the schema: includeNewItemsInFilter </para>
    /// </summary>
    [SchemaAttr(0, "includeNewItemsInFilter")]
    public BooleanValue IncludeNewItemsInFilter
    {
        get { return (BooleanValue)Attributes[26]; }
        set { Attributes[26] = value; }
    }
    
    /// <summary>
    /// <para> Items Per Page Count.</para>
    /// <para>Represents the following attribute in the schema: itemPageCount </para>
    /// </summary>
    [SchemaAttr(0, "itemPageCount")]
    public UInt32Value ItemPageCount
    {
        get { return (UInt32Value)Attributes[27]; }
        set { Attributes[27] = value; }
    }
    
    /// <summary>
    /// <para> Auto Sort Type.</para>
    /// <para>Represents the following attribute in the schema: sortType </para>
    /// </summary>
    [SchemaAttr(0, "sortType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FieldSortValues> SortType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FieldSortValues>)Attributes[28]; }
        set { Attributes[28] = value; }
    }
    
    /// <summary>
    /// <para> Data Source Sort.</para>
    /// <para>Represents the following attribute in the schema: dataSourceSort </para>
    /// </summary>
    [SchemaAttr(0, "dataSourceSort")]
    public BooleanValue DataSourceSort
    {
        get { return (BooleanValue)Attributes[29]; }
        set { Attributes[29] = value; }
    }
    
    /// <summary>
    /// <para> Auto Sort.</para>
    /// <para>Represents the following attribute in the schema: nonAutoSortDefault </para>
    /// </summary>
    [SchemaAttr(0, "nonAutoSortDefault")]
    public BooleanValue NonAutoSortDefault
    {
        get { return (BooleanValue)Attributes[30]; }
        set { Attributes[30] = value; }
    }
    
    /// <summary>
    /// <para> Auto Show Rank By.</para>
    /// <para>Represents the following attribute in the schema: rankBy </para>
    /// </summary>
    [SchemaAttr(0, "rankBy")]
    public UInt32Value RankBy
    {
        get { return (UInt32Value)Attributes[31]; }
        set { Attributes[31] = value; }
    }
    
    /// <summary>
    /// <para> Show Default Subtotal.</para>
    /// <para>Represents the following attribute in the schema: defaultSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "defaultSubtotal")]
    public BooleanValue DefaultSubtotal
    {
        get { return (BooleanValue)Attributes[32]; }
        set { Attributes[32] = value; }
    }
    
    /// <summary>
    /// <para> Sum Subtotal.</para>
    /// <para>Represents the following attribute in the schema: sumSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "sumSubtotal")]
    public BooleanValue SumSubtotal
    {
        get { return (BooleanValue)Attributes[33]; }
        set { Attributes[33] = value; }
    }
    
    /// <summary>
    /// <para> CountA.</para>
    /// <para>Represents the following attribute in the schema: countASubtotal </para>
    /// </summary>
    [SchemaAttr(0, "countASubtotal")]
    public BooleanValue CountASubtotal
    {
        get { return (BooleanValue)Attributes[34]; }
        set { Attributes[34] = value; }
    }
    
    /// <summary>
    /// <para> Average.</para>
    /// <para>Represents the following attribute in the schema: avgSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "avgSubtotal")]
    public BooleanValue AverageSubTotal
    {
        get { return (BooleanValue)Attributes[35]; }
        set { Attributes[35] = value; }
    }
    
    /// <summary>
    /// <para> Max Subtotal.</para>
    /// <para>Represents the following attribute in the schema: maxSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "maxSubtotal")]
    public BooleanValue MaxSubtotal
    {
        get { return (BooleanValue)Attributes[36]; }
        set { Attributes[36] = value; }
    }
    
    /// <summary>
    /// <para> Min Subtotal.</para>
    /// <para>Represents the following attribute in the schema: minSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "minSubtotal")]
    public BooleanValue MinSubtotal
    {
        get { return (BooleanValue)Attributes[37]; }
        set { Attributes[37] = value; }
    }
    
    /// <summary>
    /// <para> Product Subtotal.</para>
    /// <para>Represents the following attribute in the schema: productSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "productSubtotal")]
    public BooleanValue ApplyProductInSubtotal
    {
        get { return (BooleanValue)Attributes[38]; }
        set { Attributes[38] = value; }
    }
    
    /// <summary>
    /// <para> Count.</para>
    /// <para>Represents the following attribute in the schema: countSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "countSubtotal")]
    public BooleanValue CountSubtotal
    {
        get { return (BooleanValue)Attributes[39]; }
        set { Attributes[39] = value; }
    }
    
    /// <summary>
    /// <para> StdDev Subtotal.</para>
    /// <para>Represents the following attribute in the schema: stdDevSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "stdDevSubtotal")]
    public BooleanValue ApplyStandardDeviationInSubtotal
    {
        get { return (BooleanValue)Attributes[40]; }
        set { Attributes[40] = value; }
    }
    
    /// <summary>
    /// <para> StdDevP Subtotal.</para>
    /// <para>Represents the following attribute in the schema: stdDevPSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "stdDevPSubtotal")]
    public BooleanValue ApplyStandardDeviationPInSubtotal
    {
        get { return (BooleanValue)Attributes[41]; }
        set { Attributes[41] = value; }
    }
    
    /// <summary>
    /// <para> Variance Subtotal.</para>
    /// <para>Represents the following attribute in the schema: varSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "varSubtotal")]
    public BooleanValue ApplyVarianceInSubtotal
    {
        get { return (BooleanValue)Attributes[42]; }
        set { Attributes[42] = value; }
    }
    
    /// <summary>
    /// <para> VarP Subtotal.</para>
    /// <para>Represents the following attribute in the schema: varPSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "varPSubtotal")]
    public BooleanValue ApplyVariancePInSubtotal
    {
        get { return (BooleanValue)Attributes[43]; }
        set { Attributes[43] = value; }
    }
    
    /// <summary>
    /// <para> Show Member Property in Cell.</para>
    /// <para>Represents the following attribute in the schema: showPropCell </para>
    /// </summary>
    [SchemaAttr(0, "showPropCell")]
    public BooleanValue ShowPropCell
    {
        get { return (BooleanValue)Attributes[44]; }
        set { Attributes[44] = value; }
    }
    
    /// <summary>
    /// <para> Show Member Property ToolTip.</para>
    /// <para>Represents the following attribute in the schema: showPropTip </para>
    /// </summary>
    [SchemaAttr(0, "showPropTip")]
    public BooleanValue ShowPropertyTooltip
    {
        get { return (BooleanValue)Attributes[45]; }
        set { Attributes[45] = value; }
    }
    
    /// <summary>
    /// <para> Show As Caption.</para>
    /// <para>Represents the following attribute in the schema: showPropAsCaption </para>
    /// </summary>
    [SchemaAttr(0, "showPropAsCaption")]
    public BooleanValue ShowPropAsCaption
    {
        get { return (BooleanValue)Attributes[46]; }
        set { Attributes[46] = value; }
    }
    
    /// <summary>
    /// <para> Drill State.</para>
    /// <para>Represents the following attribute in the schema: defaultAttributeDrillState </para>
    /// </summary>
    [SchemaAttr(0, "defaultAttributeDrillState")]
    public BooleanValue DefaultAttributeDrillState
    {
        get { return (BooleanValue)Attributes[47]; }
        set { Attributes[47] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotField class.
    /// </summary>
    public PivotField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "items" == name)
    return new Items();
    
if( 22 == namespaceId && "autoSortScope" == name)
    return new AutoSortScope();
    
if( 22 == namespaceId && "extLst" == name)
    return new PivotFieldExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "items","autoSortScope","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Field Items.</para>
    /// <para> Represents the following element tag in the schema: x:items </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Items Items
    {
        get 
        {
            return GetElement<Items>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> AutoSort Scope.</para>
    /// <para> Represents the following element tag in the schema: x:autoSortScope </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public AutoSortScope AutoSortScope
    {
        get 
        {
            return GetElement<AutoSortScope>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotFieldExtensionList PivotFieldExtensionList
    {
        get 
        {
            return GetElement<PivotFieldExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "axis" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>();
    
if( 0 == namespaceId && "dataField" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "subtotalCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showDropDowns" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hiddenLevel" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "uniqueMemberProperty" == name)
    return new StringValue();
    
if( 0 == namespaceId && "compact" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "allDrilled" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "outline" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "subtotalTop" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "multipleItemSelectionAllowed" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToPage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragOff" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showAll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertBlankRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "serverField" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertPageBreak" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoShow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "topAutoShow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hideNewItems" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "measureFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "includeNewItemsInFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "itemPageCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sortType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FieldSortValues>();
    
if( 0 == namespaceId && "dataSourceSort" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "nonAutoSortDefault" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rankBy" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "defaultSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sumSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "countASubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "avgSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "maxSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "minSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "productSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "countSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "stdDevSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "stdDevPSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "varSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "varPSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showPropCell" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showPropTip" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showPropAsCaption" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultAttributeDrillState" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotField>(deep);
    }

   
}
/// <summary>
/// <para>PivotTable Field Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:item.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Item : OpenXmlLeafElement
{
    private const string tagName = "item";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11169;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "n","t","h","s","sd","f","m","c","x","d","e" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Item User Caption.</para>
    /// <para>Represents the following attribute in the schema: n </para>
    /// </summary>
    [SchemaAttr(0, "n")]
    public StringValue ItemName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Item Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues> ItemType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Hidden.</para>
    /// <para>Represents the following attribute in the schema: h </para>
    /// </summary>
    [SchemaAttr(0, "h")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Character.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public BooleanValue HasStringVlue
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hide Details.</para>
    /// <para>Represents the following attribute in the schema: sd </para>
    /// </summary>
    [SchemaAttr(0, "sd")]
    public BooleanValue HideDetails
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Member.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public BooleanValue Calculated
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Missing.</para>
    /// <para>Represents the following attribute in the schema: m </para>
    /// </summary>
    [SchemaAttr(0, "m")]
    public BooleanValue Missing
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Child Items.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public BooleanValue ChildItems
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Item Index.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Expanded.</para>
    /// <para>Represents the following attribute in the schema: d </para>
    /// </summary>
    [SchemaAttr(0, "d")]
    public BooleanValue Expanded
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Drill Across Attributes.</para>
    /// <para>Represents the following attribute in the schema: e </para>
    /// </summary>
    [SchemaAttr(0, "e")]
    public BooleanValue DrillAcrossAttributes
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Item class.
    /// </summary>
    public Item():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "n" == name)
    return new StringValue();
    
if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>();
    
if( 0 == namespaceId && "h" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "s" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sd" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "f" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "m" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "c" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "x" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "d" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "e" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Item>(deep);
    }

   
}
/// <summary>
/// <para>Data Field Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataField.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataFieldExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataFieldExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataField : OpenXmlCompositeElement
{
    private const string tagName = "dataField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11170;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","fld","subtotal","showDataAs","baseField","baseItem","numFmtId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> fld.</para>
    /// <para>Represents the following attribute in the schema: fld </para>
    /// </summary>
    [SchemaAttr(0, "fld")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> subtotal.</para>
    /// <para>Represents the following attribute in the schema: subtotal </para>
    /// </summary>
    [SchemaAttr(0, "subtotal")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues> Subtotal
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> showDataAs.</para>
    /// <para>Represents the following attribute in the schema: showDataAs </para>
    /// </summary>
    [SchemaAttr(0, "showDataAs")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ShowDataAsValues> ShowDataAs
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ShowDataAsValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> baseField.</para>
    /// <para>Represents the following attribute in the schema: baseField </para>
    /// </summary>
    [SchemaAttr(0, "baseField")]
    public Int32Value BaseField
    {
        get { return (Int32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> baseItem.</para>
    /// <para>Represents the following attribute in the schema: baseItem </para>
    /// </summary>
    [SchemaAttr(0, "baseItem")]
    public UInt32Value BaseItem
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> numFmtId.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataField class.
    /// </summary>
    public DataField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new DataFieldExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> DataFieldExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DataFieldExtensionList DataFieldExtensionList
    {
        get 
        {
            return GetElement<DataFieldExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "fld" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "subtotal" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>();
    
if( 0 == namespaceId && "showDataAs" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ShowDataAsValues>();
    
if( 0 == namespaceId && "baseField" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "baseItem" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataField>(deep);
    }

   
}
/// <summary>
/// <para>Row Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:i.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MemberPropertyIndex &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MemberPropertyIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowItem : OpenXmlCompositeElement
{
    private const string tagName = "i";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11171;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "t","r","i" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Item Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues> ItemType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Repeated Items Count.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public UInt32Value RepeatedItemCount
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Data Field Index.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RowItem class.
    /// </summary>
    public RowItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RowItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RowItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RowItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RowItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "x" == name)
    return new MemberPropertyIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ItemValues>();
    
if( 0 == namespaceId && "r" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "i" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowItem>(deep);
    }

   
}
/// <summary>
/// <para>Row Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:field.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Field : OpenXmlLeafElement
{
    private const string tagName = "field";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11172;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "x" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public Int32Value Index
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Field class.
    /// </summary>
    public Field():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Field>(deep);
    }

   
}
/// <summary>
/// <para>PivotTable Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:format.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Format : OpenXmlCompositeElement
{
    private const string tagName = "format";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11173;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "action","dxfId" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Format Action.</para>
    /// <para>Represents the following attribute in the schema: action </para>
    /// </summary>
    [SchemaAttr(0, "action")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormatActionValues> Action
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormatActionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Format Id.</para>
    /// <para>Represents the following attribute in the schema: dxfId </para>
    /// </summary>
    [SchemaAttr(0, "dxfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Format class.
    /// </summary>
    public Format():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Format class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Format(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Format class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Format(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Format class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Format(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotArea","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Pivot Table Location.</para>
    /// <para> Represents the following element tag in the schema: x:pivotArea </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotArea PivotArea
    {
        get 
        {
            return GetElement<PivotArea>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "action" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormatActionValues>();
    
if( 0 == namespaceId && "dxfId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Format>(deep);
    }

   
}
/// <summary>
/// <para>Conditional Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:conditionalFormat.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotAreas &lt;x:pivotAreas></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotAreas))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormat : OpenXmlCompositeElement
{
    private const string tagName = "conditionalFormat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11174;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "scope","type","priority" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Conditional Formatting Scope.</para>
    /// <para>Represents the following attribute in the schema: scope </para>
    /// </summary>
    [SchemaAttr(0, "scope")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ScopeValues> Scope
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ScopeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Conditional Formatting Rule Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RuleValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.RuleValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Priority.</para>
    /// <para>Represents the following attribute in the schema: priority </para>
    /// </summary>
    [SchemaAttr(0, "priority")]
    public UInt32Value Priority
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormat class.
    /// </summary>
    public ConditionalFormat():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormat(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotAreas" == name)
    return new PivotAreas();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotAreas","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Pivot Areas.</para>
    /// <para> Represents the following element tag in the schema: x:pivotAreas </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotAreas PivotAreas
    {
        get 
        {
            return GetElement<PivotAreas>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "scope" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ScopeValues>();
    
if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.RuleValues>();
    
if( 0 == namespaceId && "priority" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormat>(deep);
    }

   
}
/// <summary>
/// <para>Pivot Areas.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotAreas.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotAreas : OpenXmlCompositeElement
{
    private const string tagName = "pivotAreas";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11175;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pivot Area Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotAreas class.
    /// </summary>
    public PivotAreas():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotAreas class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreas(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreas class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreas(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreas class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotAreas(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotAreas>(deep);
    }

   
}
/// <summary>
/// <para>PivotChart Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:chartFormat.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartFormat : OpenXmlCompositeElement
{
    private const string tagName = "chartFormat";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11176;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "chart","format","series" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Chart Index.</para>
    /// <para>Represents the following attribute in the schema: chart </para>
    /// </summary>
    [SchemaAttr(0, "chart")]
    public UInt32Value Chart
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Pivot Format Id.</para>
    /// <para>Represents the following attribute in the schema: format </para>
    /// </summary>
    [SchemaAttr(0, "format")]
    public UInt32Value Format
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Series Format.</para>
    /// <para>Represents the following attribute in the schema: series </para>
    /// </summary>
    [SchemaAttr(0, "series")]
    public BooleanValue Series
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartFormat class.
    /// </summary>
    public ChartFormat():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ChartFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ChartFormat(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotArea" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Pivot Table Location Rule.</para>
    /// <para> Represents the following element tag in the schema: x:pivotArea </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotArea PivotArea
    {
        get 
        {
            return GetElement<PivotArea>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "chart" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "format" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "series" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartFormat>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Hierarchy.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotHierarchy.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MemberProperties &lt;x:mps></description></item>
///<item><description>Members &lt;x:members></description></item>
///<item><description>PivotHierarchyExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MemberProperties))]
    [ChildElementInfo(typeof(Members))]
    [ChildElementInfo(typeof(PivotHierarchyExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotHierarchy : OpenXmlCompositeElement
{
    private const string tagName = "pivotHierarchy";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11177;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "outline","multipleItemSelectionAllowed","subtotalTop","showInFieldList","dragToRow","dragToCol","dragToPage","dragToData","dragOff","includeNewItemsInFilter","caption" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Outline New Levels.</para>
    /// <para>Represents the following attribute in the schema: outline </para>
    /// </summary>
    [SchemaAttr(0, "outline")]
    public BooleanValue Outline
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Multiple Field Filters.</para>
    /// <para>Represents the following attribute in the schema: multipleItemSelectionAllowed </para>
    /// </summary>
    [SchemaAttr(0, "multipleItemSelectionAllowed")]
    public BooleanValue MultipleItemSelectionAllowed
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> New Levels Subtotals At Top.</para>
    /// <para>Represents the following attribute in the schema: subtotalTop </para>
    /// </summary>
    [SchemaAttr(0, "subtotalTop")]
    public BooleanValue SubtotalTop
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show In Field List.</para>
    /// <para>Represents the following attribute in the schema: showInFieldList </para>
    /// </summary>
    [SchemaAttr(0, "showInFieldList")]
    public BooleanValue ShowInFieldList
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Drag To Row.</para>
    /// <para>Represents the following attribute in the schema: dragToRow </para>
    /// </summary>
    [SchemaAttr(0, "dragToRow")]
    public BooleanValue DragToRow
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Drag To Column.</para>
    /// <para>Represents the following attribute in the schema: dragToCol </para>
    /// </summary>
    [SchemaAttr(0, "dragToCol")]
    public BooleanValue DragToColumn
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Drag to Page.</para>
    /// <para>Represents the following attribute in the schema: dragToPage </para>
    /// </summary>
    [SchemaAttr(0, "dragToPage")]
    public BooleanValue DragToPage
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Drag To Data.</para>
    /// <para>Represents the following attribute in the schema: dragToData </para>
    /// </summary>
    [SchemaAttr(0, "dragToData")]
    public BooleanValue DragToData
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Drag Off.</para>
    /// <para>Represents the following attribute in the schema: dragOff </para>
    /// </summary>
    [SchemaAttr(0, "dragOff")]
    public BooleanValue DragOff
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Inclusive Manual Filter.</para>
    /// <para>Represents the following attribute in the schema: includeNewItemsInFilter </para>
    /// </summary>
    [SchemaAttr(0, "includeNewItemsInFilter")]
    public BooleanValue IncludeNewItemsInFilter
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Hierarchy Caption.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotHierarchy class.
    /// </summary>
    public PivotHierarchy():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotHierarchy class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchy(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchy class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchy(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchy class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotHierarchy(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "mps" == name)
    return new MemberProperties();
    
if( 22 == namespaceId && "members" == name)
    return new Members();
    
if( 22 == namespaceId && "extLst" == name)
    return new PivotHierarchyExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "mps","members","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> OLAP Member Properties.</para>
    /// <para> Represents the following element tag in the schema: x:mps </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MemberProperties MemberProperties
    {
        get 
        {
            return GetElement<MemberProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "outline" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "multipleItemSelectionAllowed" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "subtotalTop" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showInFieldList" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToPage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragToData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dragOff" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "includeNewItemsInFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotHierarchy>(deep);
    }

   
}
/// <summary>
/// <para>Row OLAP Hierarchies.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rowHierarchyUsage.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowHierarchyUsage : HierarchyUsageType
{
    private const string tagName = "rowHierarchyUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11178;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RowHierarchyUsage class.
    /// </summary>
    public RowHierarchyUsage():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowHierarchyUsage>(deep);
    }

}
/// <summary>
/// <para>Column OLAP Hierarchies.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colHierarchyUsage.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnHierarchyUsage : HierarchyUsageType
{
    private const string tagName = "colHierarchyUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11190;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnHierarchyUsage class.
    /// </summary>
    public ColumnHierarchyUsage():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnHierarchyUsage>(deep);
    }

}
/// <summary>
/// Defines the HierarchyUsageType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class HierarchyUsageType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "hierarchyUsage" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Hierarchy Usage.</para>
    /// <para>Represents the following attribute in the schema: hierarchyUsage </para>
    /// </summary>
    [SchemaAttr(0, "hierarchyUsage")]
    public Int32Value Value
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "hierarchyUsage" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the HierarchyUsageType class.
    /// </summary>
    protected HierarchyUsageType(){}
    
    
    
}
/// <summary>
/// <para>OLAP Member Property.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mp.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MemberProperty : OpenXmlLeafElement
{
    private const string tagName = "mp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11179;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","showCell","showTip","showAsCaption","nameLen","pPos","pLen","level","field" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLAP Member Property Unique Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show Cell.</para>
    /// <para>Represents the following attribute in the schema: showCell </para>
    /// </summary>
    [SchemaAttr(0, "showCell")]
    public BooleanValue ShowCell
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Tooltip.</para>
    /// <para>Represents the following attribute in the schema: showTip </para>
    /// </summary>
    [SchemaAttr(0, "showTip")]
    public BooleanValue ShowTip
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show As Caption.</para>
    /// <para>Represents the following attribute in the schema: showAsCaption </para>
    /// </summary>
    [SchemaAttr(0, "showAsCaption")]
    public BooleanValue ShowAsCaption
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Name Length.</para>
    /// <para>Represents the following attribute in the schema: nameLen </para>
    /// </summary>
    [SchemaAttr(0, "nameLen")]
    public UInt32Value NameLength
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Property Name Character Index.</para>
    /// <para>Represents the following attribute in the schema: pPos </para>
    /// </summary>
    [SchemaAttr(0, "pPos")]
    public UInt32Value PropertyNamePosition
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Property Name Length.</para>
    /// <para>Represents the following attribute in the schema: pLen </para>
    /// </summary>
    [SchemaAttr(0, "pLen")]
    public UInt32Value PropertyNameLength
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Level Index.</para>
    /// <para>Represents the following attribute in the schema: level </para>
    /// </summary>
    [SchemaAttr(0, "level")]
    public UInt32Value Level
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: field </para>
    /// </summary>
    [SchemaAttr(0, "field")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MemberProperty class.
    /// </summary>
    public MemberProperty():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showCell" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showTip" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showAsCaption" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "nameLen" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "pPos" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "pLen" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "level" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "field" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MemberProperty>(deep);
    }

   
}
/// <summary>
/// <para>Member.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:member.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Member : OpenXmlLeafElement
{
    private const string tagName = "member";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11180;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hidden Item Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Member class.
    /// </summary>
    public Member():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Member>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Dimension.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dimension.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Dimension : OpenXmlLeafElement
{
    private const string tagName = "dimension";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11181;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "measure","name","uniqueName","caption" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Measure.</para>
    /// <para>Represents the following attribute in the schema: measure </para>
    /// </summary>
    [SchemaAttr(0, "measure")]
    public BooleanValue Measure
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Dimension Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Dimension Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Dimension Display Name.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Dimension class.
    /// </summary>
    public Dimension():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "measure" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Dimension>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Measure Group.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:measureGroup.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MeasureGroup : OpenXmlLeafElement
{
    private const string tagName = "measureGroup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11182;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","caption" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Measure Group Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Measure Group Display Name.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MeasureGroup class.
    /// </summary>
    public MeasureGroup():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MeasureGroup>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Measure Group.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:map.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MeasureDimensionMap : OpenXmlLeafElement
{
    private const string tagName = "map";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11183;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "measureGroup","dimension" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Measure Group Id.</para>
    /// <para>Represents the following attribute in the schema: measureGroup </para>
    /// </summary>
    [SchemaAttr(0, "measureGroup")]
    public UInt32Value MeasureGroup
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Dimension Id.</para>
    /// <para>Represents the following attribute in the schema: dimension </para>
    /// </summary>
    [SchemaAttr(0, "dimension")]
    public UInt32Value Dimension
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MeasureDimensionMap class.
    /// </summary>
    public MeasureDimensionMap():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "measureGroup" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "dimension" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MeasureDimensionMap>(deep);
    }

   
}
/// <summary>
/// <para>PivotTable Advanced Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:filter.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>AutoFilter &lt;x:autoFilter></description></item>
///<item><description>PivotFilterExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(AutoFilter))]
    [ChildElementInfo(typeof(PivotFilterExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFilter : OpenXmlCompositeElement
{
    private const string tagName = "filter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11184;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fld","mpFld","type","evalOrder","id","iMeasureHier","iMeasureFld","name","description","stringValue1","stringValue2" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> fld.</para>
    /// <para>Represents the following attribute in the schema: fld </para>
    /// </summary>
    [SchemaAttr(0, "fld")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> mpFld.</para>
    /// <para>Represents the following attribute in the schema: mpFld </para>
    /// </summary>
    [SchemaAttr(0, "mpFld")]
    public UInt32Value MemberPropertyFieldId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotFilterValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotFilterValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> evalOrder.</para>
    /// <para>Represents the following attribute in the schema: evalOrder </para>
    /// </summary>
    [SchemaAttr(0, "evalOrder")]
    public Int32Value EvaluationOrder
    {
        get { return (Int32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> iMeasureHier.</para>
    /// <para>Represents the following attribute in the schema: iMeasureHier </para>
    /// </summary>
    [SchemaAttr(0, "iMeasureHier")]
    public UInt32Value MeasureHierarchy
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> iMeasureFld.</para>
    /// <para>Represents the following attribute in the schema: iMeasureFld </para>
    /// </summary>
    [SchemaAttr(0, "iMeasureFld")]
    public UInt32Value MeasureField
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> description.</para>
    /// <para>Represents the following attribute in the schema: description </para>
    /// </summary>
    [SchemaAttr(0, "description")]
    public StringValue Description
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> stringValue1.</para>
    /// <para>Represents the following attribute in the schema: stringValue1 </para>
    /// </summary>
    [SchemaAttr(0, "stringValue1")]
    public StringValue StringValue1
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> stringValue2.</para>
    /// <para>Represents the following attribute in the schema: stringValue2 </para>
    /// </summary>
    [SchemaAttr(0, "stringValue2")]
    public StringValue StringValue2
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotFilter class.
    /// </summary>
    public PivotFilter():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFilter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilter(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilter(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilter class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFilter(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "autoFilter" == name)
    return new AutoFilter();
    
if( 22 == namespaceId && "extLst" == name)
    return new PivotFilterExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "autoFilter","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> AutoFilter.</para>
    /// <para> Represents the following element tag in the schema: x:autoFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public AutoFilter AutoFilter
    {
        get 
        {
            return GetElement<AutoFilter>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> PivotFilterExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotFilterExtensionList PivotFilterExtensionList
    {
        get 
        {
            return GetElement<PivotFilterExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fld" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "mpFld" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotFilterValues>();
    
if( 0 == namespaceId && "evalOrder" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iMeasureHier" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iMeasureFld" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "description" == name)
    return new StringValue();
    
if( 0 == namespaceId && "stringValue1" == name)
    return new StringValue();
    
if( 0 == namespaceId && "stringValue2" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFilter>(deep);
    }

   
}
/// <summary>
/// <para>PivotCache Hierarchy.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cacheHierarchy.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldsUsage &lt;x:fieldsUsage></description></item>
///<item><description>GroupLevels &lt;x:groupLevels></description></item>
///<item><description>CacheHierarchyExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldsUsage))]
    [ChildElementInfo(typeof(GroupLevels))]
    [ChildElementInfo(typeof(CacheHierarchyExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheHierarchy : OpenXmlCompositeElement
{
    private const string tagName = "cacheHierarchy";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11185;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uniqueName","caption","measure","set","parentSet","iconSet","attribute","time","keyAttribute","defaultMemberUniqueName","allUniqueName","allCaption","dimensionUniqueName","displayFolder","measureGroup","measures","count","oneField","memberValueDatatype","unbalanced","unbalancedGroup","hidden" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> uniqueName.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> caption.</para>
    /// <para>Represents the following attribute in the schema: caption </para>
    /// </summary>
    [SchemaAttr(0, "caption")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> measure.</para>
    /// <para>Represents the following attribute in the schema: measure </para>
    /// </summary>
    [SchemaAttr(0, "measure")]
    public BooleanValue Measure
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> set.</para>
    /// <para>Represents the following attribute in the schema: set </para>
    /// </summary>
    [SchemaAttr(0, "set")]
    public BooleanValue Set
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> parentSet.</para>
    /// <para>Represents the following attribute in the schema: parentSet </para>
    /// </summary>
    [SchemaAttr(0, "parentSet")]
    public UInt32Value ParentSet
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> iconSet.</para>
    /// <para>Represents the following attribute in the schema: iconSet </para>
    /// </summary>
    [SchemaAttr(0, "iconSet")]
    public Int32Value IconSet
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> attribute.</para>
    /// <para>Represents the following attribute in the schema: attribute </para>
    /// </summary>
    [SchemaAttr(0, "attribute")]
    public BooleanValue Attribute
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> time.</para>
    /// <para>Represents the following attribute in the schema: time </para>
    /// </summary>
    [SchemaAttr(0, "time")]
    public BooleanValue Time
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> keyAttribute.</para>
    /// <para>Represents the following attribute in the schema: keyAttribute </para>
    /// </summary>
    [SchemaAttr(0, "keyAttribute")]
    public BooleanValue KeyAttribute
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> defaultMemberUniqueName.</para>
    /// <para>Represents the following attribute in the schema: defaultMemberUniqueName </para>
    /// </summary>
    [SchemaAttr(0, "defaultMemberUniqueName")]
    public StringValue DefaultMemberUniqueName
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> allUniqueName.</para>
    /// <para>Represents the following attribute in the schema: allUniqueName </para>
    /// </summary>
    [SchemaAttr(0, "allUniqueName")]
    public StringValue AllUniqueName
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> allCaption.</para>
    /// <para>Represents the following attribute in the schema: allCaption </para>
    /// </summary>
    [SchemaAttr(0, "allCaption")]
    public StringValue AllCaption
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> dimensionUniqueName.</para>
    /// <para>Represents the following attribute in the schema: dimensionUniqueName </para>
    /// </summary>
    [SchemaAttr(0, "dimensionUniqueName")]
    public StringValue DimensionUniqueName
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> displayFolder.</para>
    /// <para>Represents the following attribute in the schema: displayFolder </para>
    /// </summary>
    [SchemaAttr(0, "displayFolder")]
    public StringValue DisplayFolder
    {
        get { return (StringValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> measureGroup.</para>
    /// <para>Represents the following attribute in the schema: measureGroup </para>
    /// </summary>
    [SchemaAttr(0, "measureGroup")]
    public StringValue MeasureGroup
    {
        get { return (StringValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> measures.</para>
    /// <para>Represents the following attribute in the schema: measures </para>
    /// </summary>
    [SchemaAttr(0, "measures")]
    public BooleanValue Measures
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> oneField.</para>
    /// <para>Represents the following attribute in the schema: oneField </para>
    /// </summary>
    [SchemaAttr(0, "oneField")]
    public BooleanValue OneField
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> memberValueDatatype.</para>
    /// <para>Represents the following attribute in the schema: memberValueDatatype </para>
    /// </summary>
    [SchemaAttr(0, "memberValueDatatype")]
    public UInt16Value MemberValueDatatype
    {
        get { return (UInt16Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> unbalanced.</para>
    /// <para>Represents the following attribute in the schema: unbalanced </para>
    /// </summary>
    [SchemaAttr(0, "unbalanced")]
    public BooleanValue Unbalanced
    {
        get { return (BooleanValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> unbalancedGroup.</para>
    /// <para>Represents the following attribute in the schema: unbalancedGroup </para>
    /// </summary>
    [SchemaAttr(0, "unbalancedGroup")]
    public BooleanValue UnbalancedGroup
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> hidden.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheHierarchy class.
    /// </summary>
    public CacheHierarchy():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheHierarchy class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchy(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchy class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchy(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchy class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheHierarchy(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "fieldsUsage" == name)
    return new FieldsUsage();
    
if( 22 == namespaceId && "groupLevels" == name)
    return new GroupLevels();
    
if( 22 == namespaceId && "extLst" == name)
    return new CacheHierarchyExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fieldsUsage","groupLevels","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> FieldsUsage.</para>
    /// <para> Represents the following element tag in the schema: x:fieldsUsage </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FieldsUsage FieldsUsage
    {
        get 
        {
            return GetElement<FieldsUsage>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> GroupLevels.</para>
    /// <para> Represents the following element tag in the schema: x:groupLevels </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public GroupLevels GroupLevels
    {
        get 
        {
            return GetElement<GroupLevels>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> CacheHierarchyExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CacheHierarchyExtensionList CacheHierarchyExtensionList
    {
        get 
        {
            return GetElement<CacheHierarchyExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "caption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "measure" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "set" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "parentSet" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iconSet" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "attribute" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "time" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "keyAttribute" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultMemberUniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "allUniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "allCaption" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dimensionUniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "displayFolder" == name)
    return new StringValue();
    
if( 0 == namespaceId && "measureGroup" == name)
    return new StringValue();
    
if( 0 == namespaceId && "measures" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "oneField" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "memberValueDatatype" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "unbalanced" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "unbalancedGroup" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheHierarchy>(deep);
    }

   
}
/// <summary>
/// <para>Range Grouping Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rangePr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RangeProperties : OpenXmlLeafElement
{
    private const string tagName = "rangePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11186;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "autoStart","autoEnd","groupBy","startNum","endNum","startDate","endDate","groupInterval" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Source Data Set Beginning Range.</para>
    /// <para>Represents the following attribute in the schema: autoStart </para>
    /// </summary>
    [SchemaAttr(0, "autoStart")]
    public BooleanValue AutoStart
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Source Data Ending Range.</para>
    /// <para>Represents the following attribute in the schema: autoEnd </para>
    /// </summary>
    [SchemaAttr(0, "autoEnd")]
    public BooleanValue AutoEnd
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Group By.</para>
    /// <para>Represents the following attribute in the schema: groupBy </para>
    /// </summary>
    [SchemaAttr(0, "groupBy")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GroupByValues> GroupBy
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.GroupByValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Numeric Grouping Start Value.</para>
    /// <para>Represents the following attribute in the schema: startNum </para>
    /// </summary>
    [SchemaAttr(0, "startNum")]
    public DoubleValue StartNumber
    {
        get { return (DoubleValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Numeric Grouping End Value.</para>
    /// <para>Represents the following attribute in the schema: endNum </para>
    /// </summary>
    [SchemaAttr(0, "endNum")]
    public DoubleValue EndNum
    {
        get { return (DoubleValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Date Grouping Start Value.</para>
    /// <para>Represents the following attribute in the schema: startDate </para>
    /// </summary>
    [SchemaAttr(0, "startDate")]
    public DateTimeValue StartDate
    {
        get { return (DateTimeValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Date Grouping End Value.</para>
    /// <para>Represents the following attribute in the schema: endDate </para>
    /// </summary>
    [SchemaAttr(0, "endDate")]
    public DateTimeValue EndDate
    {
        get { return (DateTimeValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Grouping Interval.</para>
    /// <para>Represents the following attribute in the schema: groupInterval </para>
    /// </summary>
    [SchemaAttr(0, "groupInterval")]
    public DoubleValue GroupInterval
    {
        get { return (DoubleValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RangeProperties class.
    /// </summary>
    public RangeProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "autoStart" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoEnd" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "groupBy" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.GroupByValues>();
    
if( 0 == namespaceId && "startNum" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "endNum" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "startDate" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "endDate" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "groupInterval" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RangeProperties>(deep);
    }

   
}
/// <summary>
/// <para>Discrete Grouping Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:discretePr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldItem &lt;x:x></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DiscreteProperties : OpenXmlCompositeElement
{
    private const string tagName = "discretePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11187;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Mapping Index Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DiscreteProperties class.
    /// </summary>
    public DiscreteProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DiscreteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DiscreteProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DiscreteProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DiscreteProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DiscreteProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DiscreteProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "x" == name)
    return new FieldItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DiscreteProperties>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Group Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groupItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MissingItem &lt;x:m></description></item>
///<item><description>NumberItem &lt;x:n></description></item>
///<item><description>BooleanItem &lt;x:b></description></item>
///<item><description>ErrorItem &lt;x:e></description></item>
///<item><description>StringItem &lt;x:s></description></item>
///<item><description>DateTimeItem &lt;x:d></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MissingItem))]
    [ChildElementInfo(typeof(NumberItem))]
    [ChildElementInfo(typeof(BooleanItem))]
    [ChildElementInfo(typeof(ErrorItem))]
    [ChildElementInfo(typeof(StringItem))]
    [ChildElementInfo(typeof(DateTimeItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupItems : OpenXmlCompositeElement
{
    private const string tagName = "groupItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11188;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Items Created Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupItems class.
    /// </summary>
    public GroupItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "m" == name)
    return new MissingItem();
    
if( 22 == namespaceId && "n" == name)
    return new NumberItem();
    
if( 22 == namespaceId && "b" == name)
    return new BooleanItem();
    
if( 22 == namespaceId && "e" == name)
    return new ErrorItem();
    
if( 22 == namespaceId && "s" == name)
    return new StringItem();
    
if( 22 == namespaceId && "d" == name)
    return new DateTimeItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupItems>(deep);
    }

   
}
/// <summary>
/// <para>Page Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageField.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageField : OpenXmlCompositeElement
{
    private const string tagName = "pageField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11189;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fld","item","hier","name","cap" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field.</para>
    /// <para>Represents the following attribute in the schema: fld </para>
    /// </summary>
    [SchemaAttr(0, "fld")]
    public Int32Value Field
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Item Index.</para>
    /// <para>Represents the following attribute in the schema: item </para>
    /// </summary>
    [SchemaAttr(0, "item")]
    public UInt32Value Item
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> OLAP Hierarchy Index.</para>
    /// <para>Represents the following attribute in the schema: hier </para>
    /// </summary>
    [SchemaAttr(0, "hier")]
    public Int32Value Hierarchy
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Hierarchy Unique Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hierarchy Display Name.</para>
    /// <para>Represents the following attribute in the schema: cap </para>
    /// </summary>
    [SchemaAttr(0, "cap")]
    public StringValue Caption
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageField class.
    /// </summary>
    public PageField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PageField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PageField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PageField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PageField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fld" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "item" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hier" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cap" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageField>(deep);
    }

   
}
/// <summary>
/// <para>References.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:references.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotAreaReference &lt;x:reference></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotAreaReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotAreaReferences : OpenXmlCompositeElement
{
    private const string tagName = "references";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11191;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pivot Filter Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotAreaReferences class.
    /// </summary>
    public PivotAreaReferences():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotAreaReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreaReferences(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreaReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreaReferences(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreaReferences class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotAreaReferences(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "reference" == name)
    return new PivotAreaReference();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotAreaReferences>(deep);
    }

   
}
/// <summary>
/// <para>Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:reference.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldItem &lt;x:x></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldItem))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotAreaReference : OpenXmlCompositeElement
{
    private const string tagName = "reference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11192;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "field","count","selected","byPosition","relative","defaultSubtotal","sumSubtotal","countASubtotal","avgSubtotal","maxSubtotal","minSubtotal","productSubtotal","countSubtotal","stdDevSubtotal","stdDevPSubtotal","varSubtotal","varPSubtotal" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Index.</para>
    /// <para>Represents the following attribute in the schema: field </para>
    /// </summary>
    [SchemaAttr(0, "field")]
    public UInt32Value Field
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Item Index Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Selected.</para>
    /// <para>Represents the following attribute in the schema: selected </para>
    /// </summary>
    [SchemaAttr(0, "selected")]
    public BooleanValue Selected
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Positional Reference.</para>
    /// <para>Represents the following attribute in the schema: byPosition </para>
    /// </summary>
    [SchemaAttr(0, "byPosition")]
    public BooleanValue ByPosition
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Relative Reference.</para>
    /// <para>Represents the following attribute in the schema: relative </para>
    /// </summary>
    [SchemaAttr(0, "relative")]
    public BooleanValue Relative
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Include Default Filter.</para>
    /// <para>Represents the following attribute in the schema: defaultSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "defaultSubtotal")]
    public BooleanValue DefaultSubtotal
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Include Sum Filter.</para>
    /// <para>Represents the following attribute in the schema: sumSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "sumSubtotal")]
    public BooleanValue SumSubtotal
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Include CountA Filter.</para>
    /// <para>Represents the following attribute in the schema: countASubtotal </para>
    /// </summary>
    [SchemaAttr(0, "countASubtotal")]
    public BooleanValue CountASubtotal
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Include Average Filter.</para>
    /// <para>Represents the following attribute in the schema: avgSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "avgSubtotal")]
    public BooleanValue AverageSubtotal
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Include Maximum Filter.</para>
    /// <para>Represents the following attribute in the schema: maxSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "maxSubtotal")]
    public BooleanValue MaxSubtotal
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Include Minimum Filter.</para>
    /// <para>Represents the following attribute in the schema: minSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "minSubtotal")]
    public BooleanValue MinSubtotal
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Include Product Filter.</para>
    /// <para>Represents the following attribute in the schema: productSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "productSubtotal")]
    public BooleanValue ApplyProductInSubtotal
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Include Count Subtotal.</para>
    /// <para>Represents the following attribute in the schema: countSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "countSubtotal")]
    public BooleanValue CountSubtotal
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Include StdDev Filter.</para>
    /// <para>Represents the following attribute in the schema: stdDevSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "stdDevSubtotal")]
    public BooleanValue ApplyStandardDeviationInSubtotal
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Include StdDevP Filter.</para>
    /// <para>Represents the following attribute in the schema: stdDevPSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "stdDevPSubtotal")]
    public BooleanValue ApplyStandardDeviationPInSubtotal
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Include Var Filter.</para>
    /// <para>Represents the following attribute in the schema: varSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "varSubtotal")]
    public BooleanValue ApplyVarianceInSubtotal
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Include VarP Filter.</para>
    /// <para>Represents the following attribute in the schema: varPSubtotal </para>
    /// </summary>
    [SchemaAttr(0, "varPSubtotal")]
    public BooleanValue ApplyVariancePInSubtotal
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotAreaReference class.
    /// </summary>
    public PivotAreaReference():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotAreaReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreaReference(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreaReference class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotAreaReference(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotAreaReference class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotAreaReference(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "x" == name)
    return new FieldItem();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "field" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "selected" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "byPosition" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "relative" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sumSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "countASubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "avgSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "maxSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "minSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "productSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "countSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "stdDevSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "stdDevPSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "varSubtotal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "varPSubtotal" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotAreaReference>(deep);
    }

   
}
/// <summary>
/// <para>Query table fields.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryTableFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>QueryTableField &lt;x:queryTableField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(QueryTableField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableFields : OpenXmlCompositeElement
{
    private const string tagName = "queryTableFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11193;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Column Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryTableFields class.
    /// </summary>
    public QueryTableFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "queryTableField" == name)
    return new QueryTableField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableFields>(deep);
    }

   
}
/// <summary>
/// <para>Deleted Fields.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryTableDeletedFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DeletedField &lt;x:deletedField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DeletedField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableDeletedFields : OpenXmlCompositeElement
{
    private const string tagName = "queryTableDeletedFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11194;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Deleted Fields Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryTableDeletedFields class.
    /// </summary>
    public QueryTableDeletedFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableDeletedFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableDeletedFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableDeletedFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableDeletedFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableDeletedFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableDeletedFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "deletedField" == name)
    return new DeletedField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableDeletedFields>(deep);
    }

   
}
/// <summary>
/// <para>Deleted Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:deletedField.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DeletedField : OpenXmlLeafElement
{
    private const string tagName = "deletedField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11195;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Deleted Fields Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DeletedField class.
    /// </summary>
    public DeletedField():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DeletedField>(deep);
    }

   
}
/// <summary>
/// <para>QueryTable Field.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryTableField.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableField : OpenXmlCompositeElement
{
    private const string tagName = "queryTableField";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11196;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","name","dataBound","rowNumbers","fillFormulas","clipped","tableColumnId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Data Bound Column.</para>
    /// <para>Represents the following attribute in the schema: dataBound </para>
    /// </summary>
    [SchemaAttr(0, "dataBound")]
    public BooleanValue DataBound
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Row Numbers.</para>
    /// <para>Represents the following attribute in the schema: rowNumbers </para>
    /// </summary>
    [SchemaAttr(0, "rowNumbers")]
    public BooleanValue RowNumbers
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Fill This Formula On Refresh.</para>
    /// <para>Represents the following attribute in the schema: fillFormulas </para>
    /// </summary>
    [SchemaAttr(0, "fillFormulas")]
    public BooleanValue FillFormulas
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Clipped Column.</para>
    /// <para>Represents the following attribute in the schema: clipped </para>
    /// </summary>
    [SchemaAttr(0, "clipped")]
    public BooleanValue Clipped
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Table Column Id.</para>
    /// <para>Represents the following attribute in the schema: tableColumnId </para>
    /// </summary>
    [SchemaAttr(0, "tableColumnId")]
    public UInt32Value TableColumnId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryTableField class.
    /// </summary>
    public QueryTableField():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableField(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableField class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableField(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableField class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableField(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dataBound" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowNumbers" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fillFormulas" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "clipped" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "tableColumnId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableField>(deep);
    }

   
}
/// <summary>
/// <para>String Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:si.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Text &lt;x:t></description></item>
///<item><description>Run &lt;x:r></description></item>
///<item><description>PhoneticRun &lt;x:rPh></description></item>
///<item><description>PhoneticProperties &lt;x:phoneticPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SharedStringItem : RstType
{
    private const string tagName = "si";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11197;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the SharedStringItem class.
    /// </summary>
    public SharedStringItem():base(){}
            /// <summary>
    ///Initializes a new instance of the SharedStringItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedStringItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedStringItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedStringItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedStringItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SharedStringItem(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SharedStringItem>(deep);
    }

}
/// <summary>
/// <para>Rich Text Inline.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:is.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Text &lt;x:t></description></item>
///<item><description>Run &lt;x:r></description></item>
///<item><description>PhoneticRun &lt;x:rPh></description></item>
///<item><description>PhoneticProperties &lt;x:phoneticPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InlineString : RstType
{
    private const string tagName = "is";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11243;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the InlineString class.
    /// </summary>
    public InlineString():base(){}
            /// <summary>
    ///Initializes a new instance of the InlineString class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InlineString(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the InlineString class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public InlineString(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the InlineString class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public InlineString(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InlineString>(deep);
    }

}
/// <summary>
/// <para>Comment Text.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:text.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Text &lt;x:t></description></item>
///<item><description>Run &lt;x:r></description></item>
///<item><description>PhoneticRun &lt;x:rPh></description></item>
///<item><description>PhoneticProperties &lt;x:phoneticPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CommentText : RstType
{
    private const string tagName = "text";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11426;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CommentText class.
    /// </summary>
    public CommentText():base(){}
            /// <summary>
    ///Initializes a new instance of the CommentText class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentText(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentText class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentText(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentText class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CommentText(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentText>(deep);
    }

}
/// <summary>
/// Defines the RstType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Text &lt;x:t></description></item>
///<item><description>Run &lt;x:r></description></item>
///<item><description>PhoneticRun &lt;x:rPh></description></item>
///<item><description>PhoneticProperties &lt;x:phoneticPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Text))]
    [ChildElementInfo(typeof(Run))]
    [ChildElementInfo(typeof(PhoneticRun))]
    [ChildElementInfo(typeof(PhoneticProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class RstType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "t" == name)
    return new Text();
    
if( 22 == namespaceId && "r" == name)
    return new Run();
    
if( 22 == namespaceId && "rPh" == name)
    return new PhoneticRun();
    
if( 22 == namespaceId && "phoneticPr" == name)
    return new PhoneticProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "t","r","rPh","phoneticPr" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text.</para>
    /// <para> Represents the following element tag in the schema: x:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Text Text
    {
        get 
        {
            return GetElement<Text>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the RstType class.
    /// </summary>
    protected RstType(){}
    
            /// <summary>
    ///Initializes a new instance of the RstType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RstType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RstType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected RstType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RstType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected RstType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Bold.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:b.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Bold : BooleanPropertyType
{
    private const string tagName = "b";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11198;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Bold class.
    /// </summary>
    public Bold():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Bold>(deep);
    }

}
/// <summary>
/// <para>Italic.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:i.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Italic : BooleanPropertyType
{
    private const string tagName = "i";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11199;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Italic class.
    /// </summary>
    public Italic():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Italic>(deep);
    }

}
/// <summary>
/// <para>Strike Through.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:strike.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Strike : BooleanPropertyType
{
    private const string tagName = "strike";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11200;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Strike class.
    /// </summary>
    public Strike():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Strike>(deep);
    }

}
/// <summary>
/// <para>Condense.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:condense.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Condense : BooleanPropertyType
{
    private const string tagName = "condense";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11201;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Condense class.
    /// </summary>
    public Condense():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Condense>(deep);
    }

}
/// <summary>
/// <para>Extend.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extend.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Extend : BooleanPropertyType
{
    private const string tagName = "extend";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11202;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Extend class.
    /// </summary>
    public Extend():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Extend>(deep);
    }

}
/// <summary>
/// <para>Outline.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:outline.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Outline : BooleanPropertyType
{
    private const string tagName = "outline";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11203;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Outline class.
    /// </summary>
    public Outline():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Outline>(deep);
    }

}
/// <summary>
/// <para>Shadow.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:shadow.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Shadow : BooleanPropertyType
{
    private const string tagName = "shadow";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11204;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Shadow class.
    /// </summary>
    public Shadow():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Shadow>(deep);
    }

}
/// <summary>
/// Defines the BooleanPropertyType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class BooleanPropertyType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public BooleanValue Val
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the BooleanPropertyType class.
    /// </summary>
    protected BooleanPropertyType(){}
    
    
    
}
/// <summary>
/// <para>Underline.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:u.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Underline : OpenXmlLeafElement
{
    private const string tagName = "u";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11205;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Underline Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.UnderlineValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.UnderlineValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Underline class.
    /// </summary>
    public Underline():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.UnderlineValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Underline>(deep);
    }

   
}
/// <summary>
/// <para>Vertical Alignment.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:vertAlign.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VerticalTextAlignment : OpenXmlLeafElement
{
    private const string tagName = "vertAlign";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11206;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentRunValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentRunValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VerticalTextAlignment class.
    /// </summary>
    public VerticalTextAlignment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentRunValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VerticalTextAlignment>(deep);
    }

   
}
/// <summary>
/// <para>Font Size.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sz.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontSize : OpenXmlLeafElement
{
    private const string tagName = "sz";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11207;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public DoubleValue Val
    {
        get { return (DoubleValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontSize class.
    /// </summary>
    public FontSize():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontSize>(deep);
    }

   
}
/// <summary>
/// <para>Text Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:color.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Color : ColorType
{
    private const string tagName = "color";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11208;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Color class.
    /// </summary>
    public Color():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Color>(deep);
    }

}
/// <summary>
/// <para>Sheet Tab Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tabColor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TabColor : ColorType
{
    private const string tagName = "tabColor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11249;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TabColor class.
    /// </summary>
    public TabColor():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TabColor>(deep);
    }

}
/// <summary>
/// <para>Foreground Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fgColor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ForegroundColor : ColorType
{
    private const string tagName = "fgColor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11311;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ForegroundColor class.
    /// </summary>
    public ForegroundColor():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ForegroundColor>(deep);
    }

}
/// <summary>
/// <para>Background Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:bgColor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BackgroundColor : ColorType
{
    private const string tagName = "bgColor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11312;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BackgroundColor class.
    /// </summary>
    public BackgroundColor():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BackgroundColor>(deep);
    }

}
/// <summary>
/// Defines the ColorType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class ColorType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "auto","indexed","rgb","theme","tint" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Automatic.</para>
    /// <para>Represents the following attribute in the schema: auto </para>
    /// </summary>
    [SchemaAttr(0, "auto")]
    public BooleanValue Auto
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Index.</para>
    /// <para>Represents the following attribute in the schema: indexed </para>
    /// </summary>
    [SchemaAttr(0, "indexed")]
    public UInt32Value Indexed
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Alpha Red Green Blue Color Value.</para>
    /// <para>Represents the following attribute in the schema: rgb </para>
    /// </summary>
    [SchemaAttr(0, "rgb")]
    public HexBinaryValue Rgb
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Theme Color.</para>
    /// <para>Represents the following attribute in the schema: theme </para>
    /// </summary>
    [SchemaAttr(0, "theme")]
    public UInt32Value Theme
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Tint.</para>
    /// <para>Represents the following attribute in the schema: tint </para>
    /// </summary>
    [SchemaAttr(0, "tint")]
    public DoubleValue Tint
    {
        get { return (DoubleValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "auto" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "indexed" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rgb" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "theme" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "tint" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the ColorType class.
    /// </summary>
    protected ColorType(){}
    
    
    
}
/// <summary>
/// <para>Font.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rFont.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunFont : OpenXmlLeafElement
{
    private const string tagName = "rFont";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11209;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> String Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RunFont class.
    /// </summary>
    public RunFont():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunFont>(deep);
    }

   
}
/// <summary>
/// <para>Font Family.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:family.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontFamily : InternationalPropertyType
{
    private const string tagName = "family";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11210;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FontFamily class.
    /// </summary>
    public FontFamily():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontFamily>(deep);
    }

}
/// <summary>
/// <para>Character Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:charset.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunPropertyCharSet : InternationalPropertyType
{
    private const string tagName = "charset";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11211;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RunPropertyCharSet class.
    /// </summary>
    public RunPropertyCharSet():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunPropertyCharSet>(deep);
    }

}
/// <summary>
/// Defines the InternationalPropertyType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class InternationalPropertyType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the InternationalPropertyType class.
    /// </summary>
    protected InternationalPropertyType(){}
    
    
    
}
/// <summary>
/// <para>Font Scheme.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:scheme.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontScheme : OpenXmlLeafElement
{
    private const string tagName = "scheme";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11212;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Scheme.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FontSchemeValues> Val
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FontSchemeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontScheme class.
    /// </summary>
    public FontScheme():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FontSchemeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontScheme>(deep);
    }

   
}
/// <summary>
/// <para>Run Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Bold &lt;x:b></description></item>
///<item><description>Italic &lt;x:i></description></item>
///<item><description>Strike &lt;x:strike></description></item>
///<item><description>Condense &lt;x:condense></description></item>
///<item><description>Extend &lt;x:extend></description></item>
///<item><description>Outline &lt;x:outline></description></item>
///<item><description>Shadow &lt;x:shadow></description></item>
///<item><description>Underline &lt;x:u></description></item>
///<item><description>VerticalTextAlignment &lt;x:vertAlign></description></item>
///<item><description>FontSize &lt;x:sz></description></item>
///<item><description>Color &lt;x:color></description></item>
///<item><description>RunFont &lt;x:rFont></description></item>
///<item><description>FontFamily &lt;x:family></description></item>
///<item><description>RunPropertyCharSet &lt;x:charset></description></item>
///<item><description>FontScheme &lt;x:scheme></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(Condense))]
    [ChildElementInfo(typeof(Extend))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(RunFont))]
    [ChildElementInfo(typeof(FontFamily))]
    [ChildElementInfo(typeof(RunPropertyCharSet))]
    [ChildElementInfo(typeof(FontScheme))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RunProperties : OpenXmlCompositeElement
{
    private const string tagName = "rPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11214;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class.
    /// </summary>
    public RunProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RunProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RunProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RunProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "b" == name)
    return new Bold();
    
if( 22 == namespaceId && "i" == name)
    return new Italic();
    
if( 22 == namespaceId && "strike" == name)
    return new Strike();
    
if( 22 == namespaceId && "condense" == name)
    return new Condense();
    
if( 22 == namespaceId && "extend" == name)
    return new Extend();
    
if( 22 == namespaceId && "outline" == name)
    return new Outline();
    
if( 22 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 22 == namespaceId && "u" == name)
    return new Underline();
    
if( 22 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 22 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 22 == namespaceId && "color" == name)
    return new Color();
    
if( 22 == namespaceId && "rFont" == name)
    return new RunFont();
    
if( 22 == namespaceId && "family" == name)
    return new FontFamily();
    
if( 22 == namespaceId && "charset" == name)
    return new RunPropertyCharSet();
    
if( 22 == namespaceId && "scheme" == name)
    return new FontScheme();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RunProperties>(deep);
    }

   
}
/// <summary>
/// <para>Rich Text Run.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:r.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RunProperties &lt;x:rPr></description></item>
///<item><description>Text &lt;x:t></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RunProperties))]
    [ChildElementInfo(typeof(Text))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Run : OpenXmlCompositeElement
{
    private const string tagName = "r";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11215;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Run class.
    /// </summary>
    public Run():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Run(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Run class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Run(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rPr" == name)
    return new RunProperties();
    
if( 22 == namespaceId && "t" == name)
    return new Text();
    

    return null;
}

        private static readonly string[] eleTagNames = { "rPr","t" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Run Properties.</para>
    /// <para> Represents the following element tag in the schema: x:rPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RunProperties RunProperties
    {
        get 
        {
            return GetElement<RunProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Text.</para>
    /// <para> Represents the following element tag in the schema: x:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Text Text
    {
        get 
        {
            return GetElement<Text>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Run>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Run.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rPh.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Text &lt;x:t></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Text))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PhoneticRun : OpenXmlCompositeElement
{
    private const string tagName = "rPh";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11216;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sb","eb" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Base Text Start Index.</para>
    /// <para>Represents the following attribute in the schema: sb </para>
    /// </summary>
    [SchemaAttr(0, "sb")]
    public UInt32Value BaseTextStartIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Base Text End Index.</para>
    /// <para>Represents the following attribute in the schema: eb </para>
    /// </summary>
    [SchemaAttr(0, "eb")]
    public UInt32Value EndingBaseIndex
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PhoneticRun class.
    /// </summary>
    public PhoneticRun():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PhoneticRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PhoneticRun(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PhoneticRun class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PhoneticRun(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PhoneticRun class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PhoneticRun(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "t" == name)
    return new Text();
    

    return null;
}

        private static readonly string[] eleTagNames = { "t" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Text.</para>
    /// <para> Represents the following element tag in the schema: x:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Text Text
    {
        get 
        {
            return GetElement<Text>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sb" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "eb" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PhoneticRun>(deep);
    }

   
}
/// <summary>
/// <para>Phonetic Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:phoneticPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PhoneticProperties : OpenXmlLeafElement
{
    private const string tagName = "phoneticPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11217;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fontId","type","alignment" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Id.</para>
    /// <para>Represents the following attribute in the schema: fontId </para>
    /// </summary>
    [SchemaAttr(0, "fontId")]
    public UInt32Value FontId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Character Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Alignment.</para>
    /// <para>Represents the following attribute in the schema: alignment </para>
    /// </summary>
    [SchemaAttr(0, "alignment")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticAlignmentValues> Alignment
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticAlignmentValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PhoneticProperties class.
    /// </summary>
    public PhoneticProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fontId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticValues>();
    
if( 0 == namespaceId && "alignment" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PhoneticAlignmentValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PhoneticProperties>(deep);
    }

   
}
/// <summary>
/// <para>Header.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:header.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetIdMap &lt;x:sheetIdMap></description></item>
///<item><description>ReviewedList &lt;x:reviewedList></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetIdMap))]
    [ChildElementInfo(typeof(ReviewedList))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Header : OpenXmlCompositeElement
{
    private const string tagName = "header";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11218;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","dateTime","maxSheetId","userName","id","minRId","maxRId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,19,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Date Time.</para>
    /// <para>Represents the following attribute in the schema: dateTime </para>
    /// </summary>
    [SchemaAttr(0, "dateTime")]
    public DateTimeValue DateTime
    {
        get { return (DateTimeValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Last Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: maxSheetId </para>
    /// </summary>
    [SchemaAttr(0, "maxSheetId")]
    public UInt32Value MaxSheetId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> User Name.</para>
    /// <para>Represents the following attribute in the schema: userName </para>
    /// </summary>
    [SchemaAttr(0, "userName")]
    public StringValue UserName
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Relationship ID.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Revision Id.</para>
    /// <para>Represents the following attribute in the schema: minRId </para>
    /// </summary>
    [SchemaAttr(0, "minRId")]
    public UInt32Value MinRevisionId
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Max Revision Id.</para>
    /// <para>Represents the following attribute in the schema: maxRId </para>
    /// </summary>
    [SchemaAttr(0, "maxRId")]
    public UInt32Value MaxRevisionId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Header class.
    /// </summary>
    public Header():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Header class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Header(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Header class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Header(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Header class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Header(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetIdMap" == name)
    return new SheetIdMap();
    
if( 22 == namespaceId && "reviewedList" == name)
    return new ReviewedList();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sheetIdMap","reviewedList","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Sheet Id Map.</para>
    /// <para> Represents the following element tag in the schema: x:sheetIdMap </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetIdMap SheetIdMap
    {
        get 
        {
            return GetElement<SheetIdMap>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Reviewed List.</para>
    /// <para> Represents the following element tag in the schema: x:reviewedList </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ReviewedList ReviewedList
    {
        get 
        {
            return GetElement<ReviewedList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dateTime" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "maxSheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "userName" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minRId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "maxRId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Header>(deep);
    }

   
}
/// <summary>
/// <para>Revision Row Column Insert Delete.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rrc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Undo &lt;x:undo></description></item>
///<item><description>RevisionCellChange &lt;x:rcc></description></item>
///<item><description>RevisionFormat &lt;x:rfmt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Undo))]
    [ChildElementInfo(typeof(RevisionCellChange))]
    [ChildElementInfo(typeof(RevisionFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionRowColumn : OpenXmlCompositeElement
{
    private const string tagName = "rrc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11219;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sId","eol","ref","action","edge" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sId </para>
    /// </summary>
    [SchemaAttr(0, "sId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> End Of List.</para>
    /// <para>Represents the following attribute in the schema: eol </para>
    /// </summary>
    [SchemaAttr(0, "eol")]
    public BooleanValue EndOfList
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> User Action.</para>
    /// <para>Represents the following attribute in the schema: action </para>
    /// </summary>
    [SchemaAttr(0, "action")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RowColumnActionValues> Action
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.RowColumnActionValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Edge Deleted.</para>
    /// <para>Represents the following attribute in the schema: edge </para>
    /// </summary>
    [SchemaAttr(0, "edge")]
    public BooleanValue Edge
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionRowColumn class.
    /// </summary>
    public RevisionRowColumn():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionRowColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionRowColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionRowColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionRowColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionRowColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionRowColumn(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "undo" == name)
    return new Undo();
    
if( 22 == namespaceId && "rcc" == name)
    return new RevisionCellChange();
    
if( 22 == namespaceId && "rfmt" == name)
    return new RevisionFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "eol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "action" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.RowColumnActionValues>();
    
if( 0 == namespaceId && "edge" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionRowColumn>(deep);
    }

   
}
/// <summary>
/// <para>Revision Cell Move.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rm.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Undo &lt;x:undo></description></item>
///<item><description>RevisionCellChange &lt;x:rcc></description></item>
///<item><description>RevisionFormat &lt;x:rfmt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Undo))]
    [ChildElementInfo(typeof(RevisionCellChange))]
    [ChildElementInfo(typeof(RevisionFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionMove : OpenXmlCompositeElement
{
    private const string tagName = "rm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11220;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sheetId","source","destination","sourceSheetId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Source.</para>
    /// <para>Represents the following attribute in the schema: source </para>
    /// </summary>
    [SchemaAttr(0, "source")]
    public StringValue Source
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Destination.</para>
    /// <para>Represents the following attribute in the schema: destination </para>
    /// </summary>
    [SchemaAttr(0, "destination")]
    public StringValue Destination
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Source Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sourceSheetId </para>
    /// </summary>
    [SchemaAttr(0, "sourceSheetId")]
    public UInt32Value SourceSheetId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionMove class.
    /// </summary>
    public RevisionMove():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionMove class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionMove(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionMove class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionMove(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionMove class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionMove(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "undo" == name)
    return new Undo();
    
if( 22 == namespaceId && "rcc" == name)
    return new RevisionCellChange();
    
if( 22 == namespaceId && "rfmt" == name)
    return new RevisionFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "source" == name)
    return new StringValue();
    
if( 0 == namespaceId && "destination" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sourceSheetId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionMove>(deep);
    }

   
}
/// <summary>
/// <para>Revision Custom View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rcv.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionCustomView : OpenXmlLeafElement
{
    private const string tagName = "rcv";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11221;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","action" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> User Action.</para>
    /// <para>Represents the following attribute in the schema: action </para>
    /// </summary>
    [SchemaAttr(0, "action")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues> Action
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionCustomView class.
    /// </summary>
    public RevisionCustomView():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "action" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionCustomView>(deep);
    }

   
}
/// <summary>
/// <para>Revision Sheet Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rsnm.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionSheetName : OpenXmlCompositeElement
{
    private const string tagName = "rsnm";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11222;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sheetId","oldName","newName" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Old Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: oldName </para>
    /// </summary>
    [SchemaAttr(0, "oldName")]
    public StringValue OldName
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> New Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: newName </para>
    /// </summary>
    [SchemaAttr(0, "newName")]
    public StringValue NewName
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionSheetName class.
    /// </summary>
    public RevisionSheetName():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionSheetName class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionSheetName(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionSheetName class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionSheetName(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionSheetName class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionSheetName(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "oldName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "newName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionSheetName>(deep);
    }

   
}
/// <summary>
/// <para>Revision Insert Sheet.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ris.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionInsertSheet : OpenXmlLeafElement
{
    private const string tagName = "ris";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11223;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sheetId","name","sheetPosition" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Position.</para>
    /// <para>Represents the following attribute in the schema: sheetPosition </para>
    /// </summary>
    [SchemaAttr(0, "sheetPosition")]
    public UInt32Value SheetPosition
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionInsertSheet class.
    /// </summary>
    public RevisionInsertSheet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheetPosition" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionInsertSheet>(deep);
    }

   
}
/// <summary>
/// <para>Revision Cell Change.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rcc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OldCell &lt;x:oc></description></item>
///<item><description>NewCell &lt;x:nc></description></item>
///<item><description>OldDifferentialFormat &lt;x:odxf></description></item>
///<item><description>NewDifferentialFormat &lt;x:ndxf></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OldCell))]
    [ChildElementInfo(typeof(NewCell))]
    [ChildElementInfo(typeof(OldDifferentialFormat))]
    [ChildElementInfo(typeof(NewDifferentialFormat))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionCellChange : OpenXmlCompositeElement
{
    private const string tagName = "rcc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11224;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sId","odxf","xfDxf","s","dxf","numFmtId","quotePrefix","oldQuotePrefix","ph","oldPh","endOfListFormulaUpdate" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sId </para>
    /// </summary>
    [SchemaAttr(0, "sId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Old Formatting.</para>
    /// <para>Represents the following attribute in the schema: odxf </para>
    /// </summary>
    [SchemaAttr(0, "odxf")]
    public BooleanValue OldFormatting
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Row Column Formatting Change.</para>
    /// <para>Represents the following attribute in the schema: xfDxf </para>
    /// </summary>
    [SchemaAttr(0, "xfDxf")]
    public BooleanValue RowColumnFormattingAffected
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Style Revision.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public BooleanValue StyleRevision
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Formatting.</para>
    /// <para>Represents the following attribute in the schema: dxf </para>
    /// </summary>
    [SchemaAttr(0, "dxf")]
    public BooleanValue Format
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Number Format Id.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Quote Prefix.</para>
    /// <para>Represents the following attribute in the schema: quotePrefix </para>
    /// </summary>
    [SchemaAttr(0, "quotePrefix")]
    public BooleanValue QuotePrefix
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Old Quote Prefix.</para>
    /// <para>Represents the following attribute in the schema: oldQuotePrefix </para>
    /// </summary>
    [SchemaAttr(0, "oldQuotePrefix")]
    public BooleanValue OldQuotePrefix
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Phonetic Text.</para>
    /// <para>Represents the following attribute in the schema: ph </para>
    /// </summary>
    [SchemaAttr(0, "ph")]
    public BooleanValue HasPhoneticText
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Old Phonetic Text.</para>
    /// <para>Represents the following attribute in the schema: oldPh </para>
    /// </summary>
    [SchemaAttr(0, "oldPh")]
    public BooleanValue OldPhoneticText
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> End of List  Formula Update.</para>
    /// <para>Represents the following attribute in the schema: endOfListFormulaUpdate </para>
    /// </summary>
    [SchemaAttr(0, "endOfListFormulaUpdate")]
    public BooleanValue EndOfListFormulaUpdate
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionCellChange class.
    /// </summary>
    public RevisionCellChange():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionCellChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionCellChange(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionCellChange class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionCellChange(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionCellChange class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionCellChange(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "oc" == name)
    return new OldCell();
    
if( 22 == namespaceId && "nc" == name)
    return new NewCell();
    
if( 22 == namespaceId && "odxf" == name)
    return new OldDifferentialFormat();
    
if( 22 == namespaceId && "ndxf" == name)
    return new NewDifferentialFormat();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "oc","nc","odxf","ndxf","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Old Cell Data.</para>
    /// <para> Represents the following element tag in the schema: x:oc </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OldCell OldCell
    {
        get 
        {
            return GetElement<OldCell>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> New Cell Data.</para>
    /// <para> Represents the following element tag in the schema: x:nc </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public NewCell NewCell
    {
        get 
        {
            return GetElement<NewCell>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Old Formatting Information.</para>
    /// <para> Represents the following element tag in the schema: x:odxf </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OldDifferentialFormat OldDifferentialFormat
    {
        get 
        {
            return GetElement<OldDifferentialFormat>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> New Formatting Information.</para>
    /// <para> Represents the following element tag in the schema: x:ndxf </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public NewDifferentialFormat NewDifferentialFormat
    {
        get 
        {
            return GetElement<NewDifferentialFormat>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "odxf" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xfDxf" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "s" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dxf" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "quotePrefix" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "oldQuotePrefix" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ph" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "oldPh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "endOfListFormulaUpdate" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionCellChange>(deep);
    }

   
}
/// <summary>
/// <para>Revision Format.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rfmt.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DifferentialFormat &lt;x:dxf></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DifferentialFormat))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionFormat : OpenXmlCompositeElement
{
    private const string tagName = "rfmt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11225;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sheetId","xfDxf","s","sqref","start","length" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Row or Column Formatting Change.</para>
    /// <para>Represents the following attribute in the schema: xfDxf </para>
    /// </summary>
    [SchemaAttr(0, "xfDxf")]
    public BooleanValue RowOrColumnAffected
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Style.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public BooleanValue StyleAffected
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sequence Of References.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Start index.</para>
    /// <para>Represents the following attribute in the schema: start </para>
    /// </summary>
    [SchemaAttr(0, "start")]
    public UInt32Value Start
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Length.</para>
    /// <para>Represents the following attribute in the schema: length </para>
    /// </summary>
    [SchemaAttr(0, "length")]
    public UInt32Value Length
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionFormat class.
    /// </summary>
    public RevisionFormat():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionFormat(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dxf" == name)
    return new DifferentialFormat();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "dxf","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Formatting.</para>
    /// <para> Represents the following element tag in the schema: x:dxf </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DifferentialFormat DifferentialFormat
    {
        get 
        {
            return GetElement<DifferentialFormat>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "xfDxf" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "s" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    
if( 0 == namespaceId && "start" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "length" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionFormat>(deep);
    }

   
}
/// <summary>
/// <para>Revision AutoFormat.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:raf.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionAutoFormat : OpenXmlLeafElement
{
    private const string tagName = "raf";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11226;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sheetId","autoFormatId","applyNumberFormats","applyBorderFormats","applyFontFormats","applyPatternFormats","applyAlignmentFormats","applyWidthHeightFormats","ref" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Auto Format Id.</para>
    /// <para>Represents the following attribute in the schema: autoFormatId </para>
    /// </summary>
    [SchemaAttr(0, "autoFormatId")]
    public UInt32Value AutoFormatId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Apply Number Formats.</para>
    /// <para>Represents the following attribute in the schema: applyNumberFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyNumberFormats")]
    public BooleanValue ApplyNumberFormats
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Apply Border Formats.</para>
    /// <para>Represents the following attribute in the schema: applyBorderFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyBorderFormats")]
    public BooleanValue ApplyBorderFormats
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Apply Font Formats.</para>
    /// <para>Represents the following attribute in the schema: applyFontFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyFontFormats")]
    public BooleanValue ApplyFontFormats
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Apply Pattern Formats.</para>
    /// <para>Represents the following attribute in the schema: applyPatternFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyPatternFormats")]
    public BooleanValue ApplyPatternFormats
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Apply Alignment Formats.</para>
    /// <para>Represents the following attribute in the schema: applyAlignmentFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyAlignmentFormats")]
    public BooleanValue ApplyAlignmentFormats
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Apply Width / Height Formats.</para>
    /// <para>Represents the following attribute in the schema: applyWidthHeightFormats </para>
    /// </summary>
    [SchemaAttr(0, "applyWidthHeightFormats")]
    public BooleanValue ApplyWidthHeightFormats
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionAutoFormat class.
    /// </summary>
    public RevisionAutoFormat():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "autoFormatId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "applyNumberFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyBorderFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyFontFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyPatternFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyAlignmentFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyWidthHeightFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionAutoFormat>(deep);
    }

   
}
/// <summary>
/// <para>Revision Defined Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rdn.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Formula &lt;x:formula></description></item>
///<item><description>OldFormula &lt;x:oldFormula></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Formula))]
    [ChildElementInfo(typeof(OldFormula))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionDefinedName : OpenXmlCompositeElement
{
    private const string tagName = "rdn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11227;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","localSheetId","customView","name","function","oldFunction","functionGroupId","oldFunctionGroupId","shortcutKey","oldShortcutKey","hidden","oldHidden","customMenu","oldCustomMenu","description","oldDescription","help","oldHelp","statusBar","oldStatusBar","comment","oldComment" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Local Name Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: localSheetId </para>
    /// </summary>
    [SchemaAttr(0, "localSheetId")]
    public UInt32Value LocalSheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Custom View.</para>
    /// <para>Represents the following attribute in the schema: customView </para>
    /// </summary>
    [SchemaAttr(0, "customView")]
    public BooleanValue CustomView
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Function.</para>
    /// <para>Represents the following attribute in the schema: function </para>
    /// </summary>
    [SchemaAttr(0, "function")]
    public BooleanValue Function
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Old Function.</para>
    /// <para>Represents the following attribute in the schema: oldFunction </para>
    /// </summary>
    [SchemaAttr(0, "oldFunction")]
    public BooleanValue OldFunction
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Function Group Id.</para>
    /// <para>Represents the following attribute in the schema: functionGroupId </para>
    /// </summary>
    [SchemaAttr(0, "functionGroupId")]
    public ByteValue FunctionGroupId
    {
        get { return (ByteValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Old Function Group Id.</para>
    /// <para>Represents the following attribute in the schema: oldFunctionGroupId </para>
    /// </summary>
    [SchemaAttr(0, "oldFunctionGroupId")]
    public ByteValue OldFunctionGroupId
    {
        get { return (ByteValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Shortcut Key.</para>
    /// <para>Represents the following attribute in the schema: shortcutKey </para>
    /// </summary>
    [SchemaAttr(0, "shortcutKey")]
    public ByteValue ShortcutKey
    {
        get { return (ByteValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Old Short Cut Key.</para>
    /// <para>Represents the following attribute in the schema: oldShortcutKey </para>
    /// </summary>
    [SchemaAttr(0, "oldShortcutKey")]
    public ByteValue OldShortcutKey
    {
        get { return (ByteValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Named Range Hidden.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Old Hidden.</para>
    /// <para>Represents the following attribute in the schema: oldHidden </para>
    /// </summary>
    [SchemaAttr(0, "oldHidden")]
    public BooleanValue OldHidden
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> New Custom Menu.</para>
    /// <para>Represents the following attribute in the schema: customMenu </para>
    /// </summary>
    [SchemaAttr(0, "customMenu")]
    public StringValue CustomMenu
    {
        get { return (StringValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Old Custom Menu Text.</para>
    /// <para>Represents the following attribute in the schema: oldCustomMenu </para>
    /// </summary>
    [SchemaAttr(0, "oldCustomMenu")]
    public StringValue OldCustomMenu
    {
        get { return (StringValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Description.</para>
    /// <para>Represents the following attribute in the schema: description </para>
    /// </summary>
    [SchemaAttr(0, "description")]
    public StringValue Description
    {
        get { return (StringValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Old Description.</para>
    /// <para>Represents the following attribute in the schema: oldDescription </para>
    /// </summary>
    [SchemaAttr(0, "oldDescription")]
    public StringValue OldDescription
    {
        get { return (StringValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> New Help Topic.</para>
    /// <para>Represents the following attribute in the schema: help </para>
    /// </summary>
    [SchemaAttr(0, "help")]
    public StringValue Help
    {
        get { return (StringValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Old Help Topic.</para>
    /// <para>Represents the following attribute in the schema: oldHelp </para>
    /// </summary>
    [SchemaAttr(0, "oldHelp")]
    public StringValue OldHelp
    {
        get { return (StringValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Status Bar.</para>
    /// <para>Represents the following attribute in the schema: statusBar </para>
    /// </summary>
    [SchemaAttr(0, "statusBar")]
    public StringValue StatusBar
    {
        get { return (StringValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Old Status Bar.</para>
    /// <para>Represents the following attribute in the schema: oldStatusBar </para>
    /// </summary>
    [SchemaAttr(0, "oldStatusBar")]
    public StringValue OldStatusBar
    {
        get { return (StringValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    
    /// <summary>
    /// <para> Name Comment.</para>
    /// <para>Represents the following attribute in the schema: comment </para>
    /// </summary>
    [SchemaAttr(0, "comment")]
    public StringValue Comment
    {
        get { return (StringValue)Attributes[22]; }
        set { Attributes[22] = value; }
    }
    
    /// <summary>
    /// <para> Old Name Comment.</para>
    /// <para>Represents the following attribute in the schema: oldComment </para>
    /// </summary>
    [SchemaAttr(0, "oldComment")]
    public StringValue OldComment
    {
        get { return (StringValue)Attributes[23]; }
        set { Attributes[23] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionDefinedName class.
    /// </summary>
    public RevisionDefinedName():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RevisionDefinedName class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionDefinedName(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionDefinedName class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RevisionDefinedName(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RevisionDefinedName class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RevisionDefinedName(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "formula" == name)
    return new Formula();
    
if( 22 == namespaceId && "oldFormula" == name)
    return new OldFormula();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "formula","oldFormula","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Formula.</para>
    /// <para> Represents the following element tag in the schema: x:formula </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Formula Formula
    {
        get 
        {
            return GetElement<Formula>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Old Formula.</para>
    /// <para> Represents the following element tag in the schema: x:oldFormula </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OldFormula OldFormula
    {
        get 
        {
            return GetElement<OldFormula>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "localSheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "customView" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "function" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "oldFunction" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "functionGroupId" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "oldFunctionGroupId" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "shortcutKey" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "oldShortcutKey" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "oldHidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customMenu" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldCustomMenu" == name)
    return new StringValue();
    
if( 0 == namespaceId && "description" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldDescription" == name)
    return new StringValue();
    
if( 0 == namespaceId && "help" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldHelp" == name)
    return new StringValue();
    
if( 0 == namespaceId && "statusBar" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldStatusBar" == name)
    return new StringValue();
    
if( 0 == namespaceId && "comment" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldComment" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionDefinedName>(deep);
    }

   
}
/// <summary>
/// <para>Revision Cell Comment.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rcmt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionComment : OpenXmlLeafElement
{
    private const string tagName = "rcmt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11228;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sheetId","cell","guid","action","alwaysShow","old","hiddenRow","hiddenColumn","author","oldLength","newLength" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Cell.</para>
    /// <para>Represents the following attribute in the schema: cell </para>
    /// </summary>
    [SchemaAttr(0, "cell")]
    public StringValue Cell
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> User Action.</para>
    /// <para>Represents the following attribute in the schema: action </para>
    /// </summary>
    [SchemaAttr(0, "action")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues> Action
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Always Show Comment.</para>
    /// <para>Represents the following attribute in the schema: alwaysShow </para>
    /// </summary>
    [SchemaAttr(0, "alwaysShow")]
    public BooleanValue AlwaysShow
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Old Comment.</para>
    /// <para>Represents the following attribute in the schema: old </para>
    /// </summary>
    [SchemaAttr(0, "old")]
    public BooleanValue Old
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Comment In Hidden Row.</para>
    /// <para>Represents the following attribute in the schema: hiddenRow </para>
    /// </summary>
    [SchemaAttr(0, "hiddenRow")]
    public BooleanValue HiddenRow
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Column.</para>
    /// <para>Represents the following attribute in the schema: hiddenColumn </para>
    /// </summary>
    [SchemaAttr(0, "hiddenColumn")]
    public BooleanValue HiddenColumn
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Author.</para>
    /// <para>Represents the following attribute in the schema: author </para>
    /// </summary>
    [SchemaAttr(0, "author")]
    public StringValue Author
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Original Comment Length.</para>
    /// <para>Represents the following attribute in the schema: oldLength </para>
    /// </summary>
    [SchemaAttr(0, "oldLength")]
    public UInt32Value OldLength
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> New Comment Length.</para>
    /// <para>Represents the following attribute in the schema: newLength </para>
    /// </summary>
    [SchemaAttr(0, "newLength")]
    public UInt32Value NewLength
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionComment class.
    /// </summary>
    public RevisionComment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cell" == name)
    return new StringValue();
    
if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "action" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.RevisionActionValues>();
    
if( 0 == namespaceId && "alwaysShow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "old" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hiddenRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hiddenColumn" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "author" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oldLength" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "newLength" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionComment>(deep);
    }

   
}
/// <summary>
/// <para>Revision Query Table.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rqt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionQueryTable : OpenXmlLeafElement
{
    private const string tagName = "rqt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11229;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sheetId","ref","fieldId" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> QueryTable Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Field Id.</para>
    /// <para>Represents the following attribute in the schema: fieldId </para>
    /// </summary>
    [SchemaAttr(0, "fieldId")]
    public UInt32Value FieldId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionQueryTable class.
    /// </summary>
    public RevisionQueryTable():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "fieldId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionQueryTable>(deep);
    }

   
}
/// <summary>
/// <para>Revision Merge Conflict.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rcft.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RevisionConflict : OpenXmlLeafElement
{
    private const string tagName = "rcft";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11230;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId","ua","ra","sheetId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revision From Rejection.</para>
    /// <para>Represents the following attribute in the schema: ua </para>
    /// </summary>
    [SchemaAttr(0, "ua")]
    public BooleanValue Ua
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Revision Undo Rejected.</para>
    /// <para>Represents the following attribute in the schema: ra </para>
    /// </summary>
    [SchemaAttr(0, "ra")]
    public BooleanValue Ra
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RevisionConflict class.
    /// </summary>
    public RevisionConflict():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ua" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ra" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RevisionConflict>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Id Map.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetIdMap.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetId &lt;x:sheetId></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetId))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetIdMap : OpenXmlCompositeElement
{
    private const string tagName = "sheetIdMap";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11231;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetIdMap class.
    /// </summary>
    public SheetIdMap():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetIdMap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetIdMap(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetIdMap class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetIdMap(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetIdMap class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetIdMap(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetId" == name)
    return new SheetId();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetIdMap>(deep);
    }

   
}
/// <summary>
/// <para>Reviewed List.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:reviewedList.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Reviewed &lt;x:reviewed></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Reviewed))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ReviewedList : OpenXmlCompositeElement
{
    private const string tagName = "reviewedList";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11232;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reviewed Revisions Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ReviewedList class.
    /// </summary>
    public ReviewedList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ReviewedList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ReviewedList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ReviewedList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ReviewedList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ReviewedList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ReviewedList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "reviewed" == name)
    return new Reviewed();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ReviewedList>(deep);
    }

   
}
/// <summary>
/// <para>Reviewed.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:reviewed.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Reviewed : OpenXmlLeafElement
{
    private const string tagName = "reviewed";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11233;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rId" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> revision Id.</para>
    /// <para>Represents the following attribute in the schema: rId </para>
    /// </summary>
    [SchemaAttr(0, "rId")]
    public UInt32Value RevisionId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Reviewed class.
    /// </summary>
    public Reviewed():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Reviewed>(deep);
    }

   
}
/// <summary>
/// <para>Undo.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:undo.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Undo : OpenXmlLeafElement
{
    private const string tagName = "undo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11234;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "index","exp","ref3D","array","v","nf","cs","dr","dn","r","sId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Index.</para>
    /// <para>Represents the following attribute in the schema: index </para>
    /// </summary>
    [SchemaAttr(0, "index")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Expression.</para>
    /// <para>Represents the following attribute in the schema: exp </para>
    /// </summary>
    [SchemaAttr(0, "exp")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormulaExpressionValues> Expression
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormulaExpressionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Reference 3D.</para>
    /// <para>Represents the following attribute in the schema: ref3D </para>
    /// </summary>
    [SchemaAttr(0, "ref3D")]
    public BooleanValue Reference3D
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Array Entered.</para>
    /// <para>Represents the following attribute in the schema: array </para>
    /// </summary>
    [SchemaAttr(0, "array")]
    public BooleanValue Array
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Value Needed.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public BooleanValue Val
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Defined Name Formula.</para>
    /// <para>Represents the following attribute in the schema: nf </para>
    /// </summary>
    [SchemaAttr(0, "nf")]
    public BooleanValue DefinedNameFormula
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Cross Sheet Move.</para>
    /// <para>Represents the following attribute in the schema: cs </para>
    /// </summary>
    [SchemaAttr(0, "cs")]
    public BooleanValue CrossSheetMove
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Range.</para>
    /// <para>Represents the following attribute in the schema: dr </para>
    /// </summary>
    [SchemaAttr(0, "dr")]
    public StringValue DeletedRange
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Defined Name.</para>
    /// <para>Represents the following attribute in the schema: dn </para>
    /// </summary>
    [SchemaAttr(0, "dn")]
    public StringValue DefinedName
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Cell Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sId </para>
    /// </summary>
    [SchemaAttr(0, "sId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Undo class.
    /// </summary>
    public Undo():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "index" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "exp" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FormulaExpressionValues>();
    
if( 0 == namespaceId && "ref3D" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "array" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "v" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "nf" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "cs" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dr" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dn" == name)
    return new StringValue();
    
if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Undo>(deep);
    }

   
}
/// <summary>
/// <para>Old Cell Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormula &lt;x:f></description></item>
///<item><description>CellValue &lt;x:v></description></item>
///<item><description>InlineString &lt;x:is></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OldCell : CellType
{
    private const string tagName = "oc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11235;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OldCell class.
    /// </summary>
    public OldCell():base(){}
            /// <summary>
    ///Initializes a new instance of the OldCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OldCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OldCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OldCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OldCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OldCell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OldCell>(deep);
    }

}
/// <summary>
/// <para>Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:c.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormula &lt;x:f></description></item>
///<item><description>CellValue &lt;x:v></description></item>
///<item><description>InlineString &lt;x:is></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Cell : CellType
{
    private const string tagName = "c";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11403;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the Cell class.
    /// </summary>
    public Cell():base(){}
            /// <summary>
    ///Initializes a new instance of the Cell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Cell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Cell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Cell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Cell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Cell(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Cell>(deep);
    }

}
/// <summary>
/// Defines the CellType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormula &lt;x:f></description></item>
///<item><description>CellValue &lt;x:v></description></item>
///<item><description>InlineString &lt;x:is></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellFormula))]
    [ChildElementInfo(typeof(CellValue))]
    [ChildElementInfo(typeof(InlineString))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class CellType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "r","s","t","cm","vm","ph" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Style Index.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public UInt32Value StyleIndex
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Cell Data Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues> DataType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Cell Metadata Index.</para>
    /// <para>Represents the following attribute in the schema: cm </para>
    /// </summary>
    [SchemaAttr(0, "cm")]
    public UInt32Value CellMetaIndex
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Value Metadata Index.</para>
    /// <para>Represents the following attribute in the schema: vm </para>
    /// </summary>
    [SchemaAttr(0, "vm")]
    public UInt32Value ValueMetaIndex
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Show Phonetic.</para>
    /// <para>Represents the following attribute in the schema: ph </para>
    /// </summary>
    [SchemaAttr(0, "ph")]
    public BooleanValue ShowPhonetic
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "f" == name)
    return new CellFormula();
    
if( 22 == namespaceId && "v" == name)
    return new CellValue();
    
if( 22 == namespaceId && "is" == name)
    return new InlineString();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "f","v","is","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Formula.</para>
    /// <para> Represents the following element tag in the schema: x:f </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellFormula CellFormula
    {
        get 
        {
            return GetElement<CellFormula>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Cell Value.</para>
    /// <para> Represents the following element tag in the schema: x:v </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellValue CellValue
    {
        get 
        {
            return GetElement<CellValue>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Rich Text Inline.</para>
    /// <para> Represents the following element tag in the schema: x:is </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public InlineString InlineString
    {
        get 
        {
            return GetElement<InlineString>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "s" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>();
    
if( 0 == namespaceId && "cm" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "vm" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ph" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the CellType class.
    /// </summary>
    protected CellType(){}
    
            /// <summary>
    ///Initializes a new instance of the CellType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected CellType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected CellType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected CellType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>New Cell Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:nc.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormula &lt;x:f></description></item>
///<item><description>CellValue &lt;x:v></description></item>
///<item><description>InlineString &lt;x:is></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellFormula))]
    [ChildElementInfo(typeof(CellValue))]
    [ChildElementInfo(typeof(InlineString))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NewCell : OpenXmlCompositeElement
{
    private const string tagName = "nc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11236;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","s","t","cm","vm","ph" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Style Index.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public UInt32Value StyleIndex
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Cell Data Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues> DataType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Cell Metadata Index.</para>
    /// <para>Represents the following attribute in the schema: cm </para>
    /// </summary>
    [SchemaAttr(0, "cm")]
    public UInt32Value CellMetaIndex
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Value Metadata Index.</para>
    /// <para>Represents the following attribute in the schema: vm </para>
    /// </summary>
    [SchemaAttr(0, "vm")]
    public UInt32Value ValueMetaIndex
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Show Phonetic.</para>
    /// <para>Represents the following attribute in the schema: ph </para>
    /// </summary>
    [SchemaAttr(0, "ph")]
    public BooleanValue ShowPhonetic
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NewCell class.
    /// </summary>
    public NewCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NewCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NewCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NewCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NewCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NewCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NewCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "f" == name)
    return new CellFormula();
    
if( 22 == namespaceId && "v" == name)
    return new CellValue();
    
if( 22 == namespaceId && "is" == name)
    return new InlineString();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "f","v","is","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Formula.</para>
    /// <para> Represents the following element tag in the schema: x:f </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellFormula CellFormula
    {
        get 
        {
            return GetElement<CellFormula>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Cell Value.</para>
    /// <para> Represents the following element tag in the schema: x:v </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CellValue CellValue
    {
        get 
        {
            return GetElement<CellValue>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Rich Text Inline.</para>
    /// <para> Represents the following element tag in the schema: x:is </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public InlineString InlineString
    {
        get 
        {
            return GetElement<InlineString>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "s" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>();
    
if( 0 == namespaceId && "cm" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "vm" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ph" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NewCell>(deep);
    }

   
}
/// <summary>
/// <para>Old Formatting Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:odxf.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;x:font></description></item>
///<item><description>NumberingFormat &lt;x:numFmt></description></item>
///<item><description>Fill &lt;x:fill></description></item>
///<item><description>Alignment &lt;x:alignment></description></item>
///<item><description>Border &lt;x:border></description></item>
///<item><description>Protection &lt;x:protection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OldDifferentialFormat : DifferentialFormatType
{
    private const string tagName = "odxf";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11237;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the OldDifferentialFormat class.
    /// </summary>
    public OldDifferentialFormat():base(){}
            /// <summary>
    ///Initializes a new instance of the OldDifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OldDifferentialFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OldDifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OldDifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OldDifferentialFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OldDifferentialFormat(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OldDifferentialFormat>(deep);
    }

}
/// <summary>
/// <para>New Formatting Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ndxf.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;x:font></description></item>
///<item><description>NumberingFormat &lt;x:numFmt></description></item>
///<item><description>Fill &lt;x:fill></description></item>
///<item><description>Alignment &lt;x:alignment></description></item>
///<item><description>Border &lt;x:border></description></item>
///<item><description>Protection &lt;x:protection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NewDifferentialFormat : DifferentialFormatType
{
    private const string tagName = "ndxf";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11238;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the NewDifferentialFormat class.
    /// </summary>
    public NewDifferentialFormat():base(){}
            /// <summary>
    ///Initializes a new instance of the NewDifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NewDifferentialFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NewDifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NewDifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NewDifferentialFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NewDifferentialFormat(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NewDifferentialFormat>(deep);
    }

}
/// <summary>
/// <para>Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dxf.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;x:font></description></item>
///<item><description>NumberingFormat &lt;x:numFmt></description></item>
///<item><description>Fill &lt;x:fill></description></item>
///<item><description>Alignment &lt;x:alignment></description></item>
///<item><description>Border &lt;x:border></description></item>
///<item><description>Protection &lt;x:protection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DifferentialFormat : DifferentialFormatType
{
    private const string tagName = "dxf";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11239;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DifferentialFormat class.
    /// </summary>
    public DifferentialFormat():base(){}
            /// <summary>
    ///Initializes a new instance of the DifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DifferentialFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DifferentialFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DifferentialFormat(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DifferentialFormat>(deep);
    }

}
/// <summary>
/// Defines the DifferentialFormatType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;x:font></description></item>
///<item><description>NumberingFormat &lt;x:numFmt></description></item>
///<item><description>Fill &lt;x:fill></description></item>
///<item><description>Alignment &lt;x:alignment></description></item>
///<item><description>Border &lt;x:border></description></item>
///<item><description>Protection &lt;x:protection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Font))]
    [ChildElementInfo(typeof(NumberingFormat))]
    [ChildElementInfo(typeof(Fill))]
    [ChildElementInfo(typeof(Alignment))]
    [ChildElementInfo(typeof(Border))]
    [ChildElementInfo(typeof(Protection))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class DifferentialFormatType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "font" == name)
    return new Font();
    
if( 22 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    
if( 22 == namespaceId && "fill" == name)
    return new Fill();
    
if( 22 == namespaceId && "alignment" == name)
    return new Alignment();
    
if( 22 == namespaceId && "border" == name)
    return new Border();
    
if( 22 == namespaceId && "protection" == name)
    return new Protection();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "font","numFmt","fill","alignment","border","protection","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Font Properties.</para>
    /// <para> Represents the following element tag in the schema: x:font </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Font Font
    {
        get 
        {
            return GetElement<Font>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Number Format.</para>
    /// <para> Represents the following element tag in the schema: x:numFmt </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public NumberingFormat NumberingFormat
    {
        get 
        {
            return GetElement<NumberingFormat>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Fill.</para>
    /// <para> Represents the following element tag in the schema: x:fill </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Fill Fill
    {
        get 
        {
            return GetElement<Fill>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Alignment.</para>
    /// <para> Represents the following element tag in the schema: x:alignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Alignment Alignment
    {
        get 
        {
            return GetElement<Alignment>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Border Properties.</para>
    /// <para> Represents the following element tag in the schema: x:border </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Border Border
    {
        get 
        {
            return GetElement<Border>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Protection Properties.</para>
    /// <para> Represents the following element tag in the schema: x:protection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Protection Protection
    {
        get 
        {
            return GetElement<Protection>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormatType class.
    /// </summary>
    protected DifferentialFormatType(){}
    
            /// <summary>
    ///Initializes a new instance of the DifferentialFormatType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DifferentialFormatType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormatType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected DifferentialFormatType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormatType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected DifferentialFormatType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Sheet Id.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetId.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetId : OpenXmlLeafElement
{
    private const string tagName = "sheetId";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11240;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetId class.
    /// </summary>
    public SheetId():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetId>(deep);
    }

   
}
/// <summary>
/// <para>Formula.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:f.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellFormula : OpenXmlLeafTextElement
{
    private const string tagName = "f";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11241;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "t","aca","ref","dt2D","dtr","del1","del2","r1","r2","ca","si","bx","space" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,1 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Formula Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellFormulaValues> FormulaType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellFormulaValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Always Calculate Array.</para>
    /// <para>Represents the following attribute in the schema: aca </para>
    /// </summary>
    [SchemaAttr(0, "aca")]
    public BooleanValue AlwaysCalculateArray
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Range of Cells.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Data Table 2-D.</para>
    /// <para>Represents the following attribute in the schema: dt2D </para>
    /// </summary>
    [SchemaAttr(0, "dt2D")]
    public BooleanValue DataTable2D
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Data Table Row.</para>
    /// <para>Represents the following attribute in the schema: dtr </para>
    /// </summary>
    [SchemaAttr(0, "dtr")]
    public BooleanValue DataTableRow
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Input 1 Deleted.</para>
    /// <para>Represents the following attribute in the schema: del1 </para>
    /// </summary>
    [SchemaAttr(0, "del1")]
    public BooleanValue Input1Deleted
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Input 2 Deleted.</para>
    /// <para>Represents the following attribute in the schema: del2 </para>
    /// </summary>
    [SchemaAttr(0, "del2")]
    public BooleanValue Input2Deleted
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Data Table Cell 1.</para>
    /// <para>Represents the following attribute in the schema: r1 </para>
    /// </summary>
    [SchemaAttr(0, "r1")]
    public StringValue R1
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Input Cell 2.</para>
    /// <para>Represents the following attribute in the schema: r2 </para>
    /// </summary>
    [SchemaAttr(0, "r2")]
    public StringValue R2
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Calculate Cell.</para>
    /// <para>Represents the following attribute in the schema: ca </para>
    /// </summary>
    [SchemaAttr(0, "ca")]
    public BooleanValue CalculateCell
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Shared Group Index.</para>
    /// <para>Represents the following attribute in the schema: si </para>
    /// </summary>
    [SchemaAttr(0, "si")]
    public UInt32Value SharedIndex
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Assigns Value to Name.</para>
    /// <para>Represents the following attribute in the schema: bx </para>
    /// </summary>
    [SchemaAttr(0, "bx")]
    public BooleanValue Bx
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Content Contains Significant Whitespace.</para>
    /// <para>Represents the following attribute in the schema: xml:space </para>
    /// </summary>
///<remark> xmlns:xml=http://www.w3.org/XML/1998/namespace
///</remark>
    [SchemaAttr(1, "space")]
    public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues> Space
    {
        get { return (EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellFormula class.
    /// </summary>
    public CellFormula():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the CellFormula class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public CellFormula(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    
 
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellFormulaValues>();
    
if( 0 == namespaceId && "aca" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dt2D" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dtr" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "del1" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "del2" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "r1" == name)
    return new StringValue();
    
if( 0 == namespaceId && "r2" == name)
    return new StringValue();
    
if( 0 == namespaceId && "ca" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "si" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bx" == name)
    return new BooleanValue();
    
if( 1 == namespaceId && "space" == name)
    return new EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellFormula>(deep);
    }

   
}
/// <summary>
/// <para>User Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:userInfo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class UserInfo : OpenXmlCompositeElement
{
    private const string tagName = "userInfo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11246;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","name","id","dateTime" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> User Revisions GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> User Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> User Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public Int32Value Id
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Date Time.</para>
    /// <para>Represents the following attribute in the schema: dateTime </para>
    /// </summary>
    [SchemaAttr(0, "dateTime")]
    public DateTimeValue DateTime
    {
        get { return (DateTimeValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the UserInfo class.
    /// </summary>
    public UserInfo():base(){}
    
            /// <summary>
    ///Initializes a new instance of the UserInfo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public UserInfo(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the UserInfo class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public UserInfo(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the UserInfo class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public UserInfo(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "id" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "dateTime" == name)
    return new DateTimeValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<UserInfo>(deep);
    }

   
}
/// <summary>
/// <para>Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:row.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Cell &lt;x:c></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Cell))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Row : OpenXmlCompositeElement
{
    private const string tagName = "row";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11247;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","spans","s","customFormat","ht","hidden","customHeight","outlineLevel","collapsed","thickTop","thickBot","ph","dyDescent" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,55 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Row Index.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public UInt32Value RowIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Spans.</para>
    /// <para>Represents the following attribute in the schema: spans </para>
    /// </summary>
    [SchemaAttr(0, "spans")]
    public ListValue<StringValue> Spans
    {
        get { return (ListValue<StringValue>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Style Index.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public UInt32Value StyleIndex
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Custom Format.</para>
    /// <para>Represents the following attribute in the schema: customFormat </para>
    /// </summary>
    [SchemaAttr(0, "customFormat")]
    public BooleanValue CustomFormat
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Row Height.</para>
    /// <para>Represents the following attribute in the schema: ht </para>
    /// </summary>
    [SchemaAttr(0, "ht")]
    public DoubleValue Height
    {
        get { return (DoubleValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Hidden.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Custom Height.</para>
    /// <para>Represents the following attribute in the schema: customHeight </para>
    /// </summary>
    [SchemaAttr(0, "customHeight")]
    public BooleanValue CustomHeight
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Outline Level.</para>
    /// <para>Represents the following attribute in the schema: outlineLevel </para>
    /// </summary>
    [SchemaAttr(0, "outlineLevel")]
    public ByteValue OutlineLevel
    {
        get { return (ByteValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Collapsed.</para>
    /// <para>Represents the following attribute in the schema: collapsed </para>
    /// </summary>
    [SchemaAttr(0, "collapsed")]
    public BooleanValue Collapsed
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Thick Top Border.</para>
    /// <para>Represents the following attribute in the schema: thickTop </para>
    /// </summary>
    [SchemaAttr(0, "thickTop")]
    public BooleanValue ThickTop
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Thick Bottom.</para>
    /// <para>Represents the following attribute in the schema: thickBot </para>
    /// </summary>
    [SchemaAttr(0, "thickBot")]
    public BooleanValue ThickBot
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Show Phonetic.</para>
    /// <para>Represents the following attribute in the schema: ph </para>
    /// </summary>
    [SchemaAttr(0, "ph")]
    public BooleanValue ShowPhonetic
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> dyDescent.</para>
    /// <para>Represents the following attribute in the schema: x14ac:dyDescent </para>
    /// </summary>
///<remark> xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
///</remark>
    [SchemaAttr(55, "dyDescent")]
    public DoubleValue DyDescent
    {
        get { return (DoubleValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Row class.
    /// </summary>
    public Row():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Row class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Row(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Row class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Row(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Row class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Row(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "c" == name)
    return new Cell();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "spans" == name)
    return new ListValue<StringValue>();
    
if( 0 == namespaceId && "s" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "customFormat" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ht" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customHeight" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outlineLevel" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "collapsed" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "thickTop" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "thickBot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ph" == name)
    return new BooleanValue();
    
if( 55 == namespaceId && "dyDescent" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Row>(deep);
    }

   
}
/// <summary>
/// <para>Column Width and Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:col.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Column : OpenXmlLeafElement
{
    private const string tagName = "col";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11248;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "min","max","width","style","hidden","bestFit","customWidth","phonetic","outlineLevel","collapsed" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Minimum Column.</para>
    /// <para>Represents the following attribute in the schema: min </para>
    /// </summary>
    [SchemaAttr(0, "min")]
    public UInt32Value Min
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Column.</para>
    /// <para>Represents the following attribute in the schema: max </para>
    /// </summary>
    [SchemaAttr(0, "max")]
    public UInt32Value Max
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Column Width.</para>
    /// <para>Represents the following attribute in the schema: width </para>
    /// </summary>
    [SchemaAttr(0, "width")]
    public DoubleValue Width
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Style.</para>
    /// <para>Represents the following attribute in the schema: style </para>
    /// </summary>
    [SchemaAttr(0, "style")]
    public UInt32Value Style
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Columns.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Best Fit Column Width.</para>
    /// <para>Represents the following attribute in the schema: bestFit </para>
    /// </summary>
    [SchemaAttr(0, "bestFit")]
    public BooleanValue BestFit
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Custom Width.</para>
    /// <para>Represents the following attribute in the schema: customWidth </para>
    /// </summary>
    [SchemaAttr(0, "customWidth")]
    public BooleanValue CustomWidth
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Show Phonetic Information.</para>
    /// <para>Represents the following attribute in the schema: phonetic </para>
    /// </summary>
    [SchemaAttr(0, "phonetic")]
    public BooleanValue Phonetic
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Outline Level.</para>
    /// <para>Represents the following attribute in the schema: outlineLevel </para>
    /// </summary>
    [SchemaAttr(0, "outlineLevel")]
    public ByteValue OutlineLevel
    {
        get { return (ByteValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Collapsed.</para>
    /// <para>Represents the following attribute in the schema: collapsed </para>
    /// </summary>
    [SchemaAttr(0, "collapsed")]
    public BooleanValue Collapsed
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Column class.
    /// </summary>
    public Column():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "min" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "max" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "width" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "style" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "bestFit" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customWidth" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "phonetic" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outlineLevel" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "collapsed" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Column>(deep);
    }

   
}
/// <summary>
/// <para>Outline Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:outlinePr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OutlineProperties : OpenXmlLeafElement
{
    private const string tagName = "outlinePr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11250;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "applyStyles","summaryBelow","summaryRight","showOutlineSymbols" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Apply Styles in Outline.</para>
    /// <para>Represents the following attribute in the schema: applyStyles </para>
    /// </summary>
    [SchemaAttr(0, "applyStyles")]
    public BooleanValue ApplyStyles
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Summary Below.</para>
    /// <para>Represents the following attribute in the schema: summaryBelow </para>
    /// </summary>
    [SchemaAttr(0, "summaryBelow")]
    public BooleanValue SummaryBelow
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Summary Right.</para>
    /// <para>Represents the following attribute in the schema: summaryRight </para>
    /// </summary>
    [SchemaAttr(0, "summaryRight")]
    public BooleanValue SummaryRight
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Outline Symbols.</para>
    /// <para>Represents the following attribute in the schema: showOutlineSymbols </para>
    /// </summary>
    [SchemaAttr(0, "showOutlineSymbols")]
    public BooleanValue ShowOutlineSymbols
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OutlineProperties class.
    /// </summary>
    public OutlineProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "applyStyles" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "summaryBelow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "summaryRight" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showOutlineSymbols" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OutlineProperties>(deep);
    }

   
}
/// <summary>
/// <para>Page Setup Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageSetUpPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageSetupProperties : OpenXmlLeafElement
{
    private const string tagName = "pageSetUpPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11251;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "autoPageBreaks","fitToPage" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Show Auto Page Breaks.</para>
    /// <para>Represents the following attribute in the schema: autoPageBreaks </para>
    /// </summary>
    [SchemaAttr(0, "autoPageBreaks")]
    public BooleanValue AutoPageBreaks
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Fit To Page.</para>
    /// <para>Represents the following attribute in the schema: fitToPage </para>
    /// </summary>
    [SchemaAttr(0, "fitToPage")]
    public BooleanValue FitToPage
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageSetupProperties class.
    /// </summary>
    public PageSetupProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "autoPageBreaks" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fitToPage" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageSetupProperties>(deep);
    }

   
}
/// <summary>
/// <para>View Pane.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pane.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Pane : OpenXmlLeafElement
{
    private const string tagName = "pane";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11252;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "xSplit","ySplit","topLeftCell","activePane","state" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Split Position.</para>
    /// <para>Represents the following attribute in the schema: xSplit </para>
    /// </summary>
    [SchemaAttr(0, "xSplit")]
    public DoubleValue HorizontalSplit
    {
        get { return (DoubleValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Split Position.</para>
    /// <para>Represents the following attribute in the schema: ySplit </para>
    /// </summary>
    [SchemaAttr(0, "ySplit")]
    public DoubleValue VerticalSplit
    {
        get { return (DoubleValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Visible Cell.</para>
    /// <para>Represents the following attribute in the schema: topLeftCell </para>
    /// </summary>
    [SchemaAttr(0, "topLeftCell")]
    public StringValue TopLeftCell
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Active Pane.</para>
    /// <para>Represents the following attribute in the schema: activePane </para>
    /// </summary>
    [SchemaAttr(0, "activePane")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues> ActivePane
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Split State.</para>
    /// <para>Represents the following attribute in the schema: state </para>
    /// </summary>
    [SchemaAttr(0, "state")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneStateValues> State
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneStateValues>)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Pane class.
    /// </summary>
    public Pane():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "xSplit" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "ySplit" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "topLeftCell" == name)
    return new StringValue();
    
if( 0 == namespaceId && "activePane" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>();
    
if( 0 == namespaceId && "state" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneStateValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Pane>(deep);
    }

   
}
/// <summary>
/// <para>Selection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:selection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Selection : OpenXmlLeafElement
{
    private const string tagName = "selection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11253;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "pane","activeCell","activeCellId","sqref" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pane.</para>
    /// <para>Represents the following attribute in the schema: pane </para>
    /// </summary>
    [SchemaAttr(0, "pane")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues> Pane
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Active Cell Location.</para>
    /// <para>Represents the following attribute in the schema: activeCell </para>
    /// </summary>
    [SchemaAttr(0, "activeCell")]
    public StringValue ActiveCell
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Active Cell Index.</para>
    /// <para>Represents the following attribute in the schema: activeCellId </para>
    /// </summary>
    [SchemaAttr(0, "activeCellId")]
    public UInt32Value ActiveCellId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Sequence of References.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Selection class.
    /// </summary>
    public Selection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "pane" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>();
    
if( 0 == namespaceId && "activeCell" == name)
    return new StringValue();
    
if( 0 == namespaceId && "activeCellId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Selection>(deep);
    }

   
}
/// <summary>
/// <para>PivotTable Selection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotSelection.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotSelection : OpenXmlCompositeElement
{
    private const string tagName = "pivotSelection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11254;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "pane","showHeader","label","data","extendable","count","axis","dimension","start","min","max","activeRow","activeCol","previousRow","previousCol","click","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pane.</para>
    /// <para>Represents the following attribute in the schema: pane </para>
    /// </summary>
    [SchemaAttr(0, "pane")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues> Pane
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show Header.</para>
    /// <para>Represents the following attribute in the schema: showHeader </para>
    /// </summary>
    [SchemaAttr(0, "showHeader")]
    public BooleanValue ShowHeader
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Label.</para>
    /// <para>Represents the following attribute in the schema: label </para>
    /// </summary>
    [SchemaAttr(0, "label")]
    public BooleanValue Label
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Data Selection.</para>
    /// <para>Represents the following attribute in the schema: data </para>
    /// </summary>
    [SchemaAttr(0, "data")]
    public BooleanValue Data
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Extendable.</para>
    /// <para>Represents the following attribute in the schema: extendable </para>
    /// </summary>
    [SchemaAttr(0, "extendable")]
    public BooleanValue Extendable
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Selection Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Axis.</para>
    /// <para>Represents the following attribute in the schema: axis </para>
    /// </summary>
    [SchemaAttr(0, "axis")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues> Axis
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Dimension.</para>
    /// <para>Represents the following attribute in the schema: dimension </para>
    /// </summary>
    [SchemaAttr(0, "dimension")]
    public UInt32Value Dimension
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Start.</para>
    /// <para>Represents the following attribute in the schema: start </para>
    /// </summary>
    [SchemaAttr(0, "start")]
    public UInt32Value Start
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Minimum.</para>
    /// <para>Represents the following attribute in the schema: min </para>
    /// </summary>
    [SchemaAttr(0, "min")]
    public UInt32Value Min
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Maximum.</para>
    /// <para>Represents the following attribute in the schema: max </para>
    /// </summary>
    [SchemaAttr(0, "max")]
    public UInt32Value Max
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Active Row.</para>
    /// <para>Represents the following attribute in the schema: activeRow </para>
    /// </summary>
    [SchemaAttr(0, "activeRow")]
    public UInt32Value ActiveRow
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Active Column.</para>
    /// <para>Represents the following attribute in the schema: activeCol </para>
    /// </summary>
    [SchemaAttr(0, "activeCol")]
    public UInt32Value ActiveColumn
    {
        get { return (UInt32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Previous Row.</para>
    /// <para>Represents the following attribute in the schema: previousRow </para>
    /// </summary>
    [SchemaAttr(0, "previousRow")]
    public UInt32Value PreviousRow
    {
        get { return (UInt32Value)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Previous Column Selection.</para>
    /// <para>Represents the following attribute in the schema: previousCol </para>
    /// </summary>
    [SchemaAttr(0, "previousCol")]
    public UInt32Value PreviousColumn
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Click Count.</para>
    /// <para>Represents the following attribute in the schema: click </para>
    /// </summary>
    [SchemaAttr(0, "click")]
    public UInt32Value Click
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotSelection class.
    /// </summary>
    public PivotSelection():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotSelection class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotSelection(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotSelection class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotSelection(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotSelection class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotSelection(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotArea" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Pivot Area.</para>
    /// <para> Represents the following element tag in the schema: x:pivotArea </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotArea PivotArea
    {
        get 
        {
            return GetElement<PivotArea>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "pane" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PaneValues>();
    
if( 0 == namespaceId && "showHeader" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "label" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "data" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "extendable" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "axis" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PivotTableAxisValues>();
    
if( 0 == namespaceId && "dimension" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "start" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "min" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "max" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "activeRow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "activeCol" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "previousRow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "previousCol" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "click" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotSelection>(deep);
    }

   
}
/// <summary>
/// <para>Break.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:brk.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Break : OpenXmlLeafElement
{
    private const string tagName = "brk";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11255;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","min","max","man","pt" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Minimum.</para>
    /// <para>Represents the following attribute in the schema: min </para>
    /// </summary>
    [SchemaAttr(0, "min")]
    public UInt32Value Min
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Maximum.</para>
    /// <para>Represents the following attribute in the schema: max </para>
    /// </summary>
    [SchemaAttr(0, "max")]
    public UInt32Value Max
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Manual Page Break.</para>
    /// <para>Represents the following attribute in the schema: man </para>
    /// </summary>
    [SchemaAttr(0, "man")]
    public BooleanValue ManualPageBreak
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Pivot-Created Page Break.</para>
    /// <para>Represents the following attribute in the schema: pt </para>
    /// </summary>
    [SchemaAttr(0, "pt")]
    public BooleanValue PivotTablePageBreak
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Break class.
    /// </summary>
    public Break():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "min" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "max" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "man" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pt" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Break>(deep);
    }

   
}
/// <summary>
/// <para>Data Consolidation Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataRef.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataReference : OpenXmlLeafElement
{
    private const string tagName = "dataRef";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11256;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref","name","sheet","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Named Range.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: sheet </para>
    /// </summary>
    [SchemaAttr(0, "sheet")]
    public StringValue Sheet
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataReference class.
    /// </summary>
    public DataReference():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheet" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataReference>(deep);
    }

   
}
/// <summary>
/// <para>Horizontal Page Breaks.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rowBreaks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Break &lt;x:brk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowBreaks : PageBreakType
{
    private const string tagName = "rowBreaks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11257;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RowBreaks class.
    /// </summary>
    public RowBreaks():base(){}
            /// <summary>
    ///Initializes a new instance of the RowBreaks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowBreaks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RowBreaks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowBreaks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RowBreaks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RowBreaks(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowBreaks>(deep);
    }

}
/// <summary>
/// <para>Vertical Page Breaks.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colBreaks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Break &lt;x:brk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnBreaks : PageBreakType
{
    private const string tagName = "colBreaks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11258;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnBreaks class.
    /// </summary>
    public ColumnBreaks():base(){}
            /// <summary>
    ///Initializes a new instance of the ColumnBreaks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnBreaks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnBreaks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnBreaks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnBreaks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColumnBreaks(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnBreaks>(deep);
    }

}
/// <summary>
/// Defines the PageBreakType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Break &lt;x:brk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Break))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class PageBreakType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "count","manualBreakCount" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Page Break Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Manual Break Count.</para>
    /// <para>Represents the following attribute in the schema: manualBreakCount </para>
    /// </summary>
    [SchemaAttr(0, "manualBreakCount")]
    public UInt32Value ManualBreakCount
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "brk" == name)
    return new Break();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "manualBreakCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the PageBreakType class.
    /// </summary>
    protected PageBreakType(){}
    
            /// <summary>
    ///Initializes a new instance of the PageBreakType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected PageBreakType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PageBreakType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected PageBreakType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PageBreakType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected PageBreakType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Page Margins.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageMargins.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageMargins : OpenXmlLeafElement
{
    private const string tagName = "pageMargins";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11259;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "left","right","top","bottom","header","footer" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Left Page Margin.</para>
    /// <para>Represents the following attribute in the schema: left </para>
    /// </summary>
    [SchemaAttr(0, "left")]
    public DoubleValue Left
    {
        get { return (DoubleValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Right Page Margin.</para>
    /// <para>Represents the following attribute in the schema: right </para>
    /// </summary>
    [SchemaAttr(0, "right")]
    public DoubleValue Right
    {
        get { return (DoubleValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Top Page Margin.</para>
    /// <para>Represents the following attribute in the schema: top </para>
    /// </summary>
    [SchemaAttr(0, "top")]
    public DoubleValue Top
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Page Margin.</para>
    /// <para>Represents the following attribute in the schema: bottom </para>
    /// </summary>
    [SchemaAttr(0, "bottom")]
    public DoubleValue Bottom
    {
        get { return (DoubleValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Header Page Margin.</para>
    /// <para>Represents the following attribute in the schema: header </para>
    /// </summary>
    [SchemaAttr(0, "header")]
    public DoubleValue Header
    {
        get { return (DoubleValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Footer Page Margin.</para>
    /// <para>Represents the following attribute in the schema: footer </para>
    /// </summary>
    [SchemaAttr(0, "footer")]
    public DoubleValue Footer
    {
        get { return (DoubleValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageMargins class.
    /// </summary>
    public PageMargins():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "left" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "right" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "top" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "bottom" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "header" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "footer" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageMargins>(deep);
    }

   
}
/// <summary>
/// <para>Print Options.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:printOptions.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PrintOptions : OpenXmlLeafElement
{
    private const string tagName = "printOptions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11260;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "horizontalCentered","verticalCentered","headings","gridLines","gridLinesSet" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Centered.</para>
    /// <para>Represents the following attribute in the schema: horizontalCentered </para>
    /// </summary>
    [SchemaAttr(0, "horizontalCentered")]
    public BooleanValue HorizontalCentered
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Centered.</para>
    /// <para>Represents the following attribute in the schema: verticalCentered </para>
    /// </summary>
    [SchemaAttr(0, "verticalCentered")]
    public BooleanValue VerticalCentered
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Print Headings.</para>
    /// <para>Represents the following attribute in the schema: headings </para>
    /// </summary>
    [SchemaAttr(0, "headings")]
    public BooleanValue Headings
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Print Grid Lines.</para>
    /// <para>Represents the following attribute in the schema: gridLines </para>
    /// </summary>
    [SchemaAttr(0, "gridLines")]
    public BooleanValue GridLines
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Grid Lines Set.</para>
    /// <para>Represents the following attribute in the schema: gridLinesSet </para>
    /// </summary>
    [SchemaAttr(0, "gridLinesSet")]
    public BooleanValue GridLinesSet
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PrintOptions class.
    /// </summary>
    public PrintOptions():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "horizontalCentered" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "verticalCentered" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "headings" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "gridLines" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "gridLinesSet" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PrintOptions>(deep);
    }

   
}
/// <summary>
/// <para>Page Setup Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageSetup.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageSetup : OpenXmlLeafElement
{
    private const string tagName = "pageSetup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11261;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "paperSize","scale","firstPageNumber","fitToWidth","fitToHeight","pageOrder","orientation","usePrinterDefaults","blackAndWhite","draft","cellComments","useFirstPageNumber","errors","horizontalDpi","verticalDpi","copies","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Paper Size.</para>
    /// <para>Represents the following attribute in the schema: paperSize </para>
    /// </summary>
    [SchemaAttr(0, "paperSize")]
    public UInt32Value PaperSize
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Print Scale.</para>
    /// <para>Represents the following attribute in the schema: scale </para>
    /// </summary>
    [SchemaAttr(0, "scale")]
    public UInt32Value Scale
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> First Page Number.</para>
    /// <para>Represents the following attribute in the schema: firstPageNumber </para>
    /// </summary>
    [SchemaAttr(0, "firstPageNumber")]
    public UInt32Value FirstPageNumber
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Fit To Width.</para>
    /// <para>Represents the following attribute in the schema: fitToWidth </para>
    /// </summary>
    [SchemaAttr(0, "fitToWidth")]
    public UInt32Value FitToWidth
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Fit To Height.</para>
    /// <para>Represents the following attribute in the schema: fitToHeight </para>
    /// </summary>
    [SchemaAttr(0, "fitToHeight")]
    public UInt32Value FitToHeight
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Page Order.</para>
    /// <para>Represents the following attribute in the schema: pageOrder </para>
    /// </summary>
    [SchemaAttr(0, "pageOrder")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PageOrderValues> PageOrder
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PageOrderValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Orientation.</para>
    /// <para>Represents the following attribute in the schema: orientation </para>
    /// </summary>
    [SchemaAttr(0, "orientation")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues> Orientation
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Use Printer Defaults.</para>
    /// <para>Represents the following attribute in the schema: usePrinterDefaults </para>
    /// </summary>
    [SchemaAttr(0, "usePrinterDefaults")]
    public BooleanValue UsePrinterDefaults
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Black And White.</para>
    /// <para>Represents the following attribute in the schema: blackAndWhite </para>
    /// </summary>
    [SchemaAttr(0, "blackAndWhite")]
    public BooleanValue BlackAndWhite
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Draft.</para>
    /// <para>Represents the following attribute in the schema: draft </para>
    /// </summary>
    [SchemaAttr(0, "draft")]
    public BooleanValue Draft
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Print Cell Comments.</para>
    /// <para>Represents the following attribute in the schema: cellComments </para>
    /// </summary>
    [SchemaAttr(0, "cellComments")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellCommentsValues> CellComments
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellCommentsValues>)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Use First Page Number.</para>
    /// <para>Represents the following attribute in the schema: useFirstPageNumber </para>
    /// </summary>
    [SchemaAttr(0, "useFirstPageNumber")]
    public BooleanValue UseFirstPageNumber
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Print Error Handling.</para>
    /// <para>Represents the following attribute in the schema: errors </para>
    /// </summary>
    [SchemaAttr(0, "errors")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PrintErrorValues> Errors
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PrintErrorValues>)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal DPI.</para>
    /// <para>Represents the following attribute in the schema: horizontalDpi </para>
    /// </summary>
    [SchemaAttr(0, "horizontalDpi")]
    public UInt32Value HorizontalDpi
    {
        get { return (UInt32Value)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Vertical DPI.</para>
    /// <para>Represents the following attribute in the schema: verticalDpi </para>
    /// </summary>
    [SchemaAttr(0, "verticalDpi")]
    public UInt32Value VerticalDpi
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Number Of Copies.</para>
    /// <para>Represents the following attribute in the schema: copies </para>
    /// </summary>
    [SchemaAttr(0, "copies")]
    public UInt32Value Copies
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageSetup class.
    /// </summary>
    public PageSetup():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "paperSize" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "scale" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "firstPageNumber" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "fitToWidth" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "fitToHeight" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "pageOrder" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PageOrderValues>();
    
if( 0 == namespaceId && "orientation" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>();
    
if( 0 == namespaceId && "usePrinterDefaults" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "blackAndWhite" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "draft" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "cellComments" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellCommentsValues>();
    
if( 0 == namespaceId && "useFirstPageNumber" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "errors" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PrintErrorValues>();
    
if( 0 == namespaceId && "horizontalDpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "verticalDpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "copies" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageSetup>(deep);
    }

   
}
/// <summary>
/// <para>Header Footer Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:headerFooter.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OddHeader &lt;x:oddHeader></description></item>
///<item><description>OddFooter &lt;x:oddFooter></description></item>
///<item><description>EvenHeader &lt;x:evenHeader></description></item>
///<item><description>EvenFooter &lt;x:evenFooter></description></item>
///<item><description>FirstHeader &lt;x:firstHeader></description></item>
///<item><description>FirstFooter &lt;x:firstFooter></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OddHeader))]
    [ChildElementInfo(typeof(OddFooter))]
    [ChildElementInfo(typeof(EvenHeader))]
    [ChildElementInfo(typeof(EvenFooter))]
    [ChildElementInfo(typeof(FirstHeader))]
    [ChildElementInfo(typeof(FirstFooter))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HeaderFooter : OpenXmlCompositeElement
{
    private const string tagName = "headerFooter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11262;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "differentOddEven","differentFirst","scaleWithDoc","alignWithMargins" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Different Odd Even Header Footer.</para>
    /// <para>Represents the following attribute in the schema: differentOddEven </para>
    /// </summary>
    [SchemaAttr(0, "differentOddEven")]
    public BooleanValue DifferentOddEven
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Different First Page.</para>
    /// <para>Represents the following attribute in the schema: differentFirst </para>
    /// </summary>
    [SchemaAttr(0, "differentFirst")]
    public BooleanValue DifferentFirst
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Scale Header and Footer With Document.</para>
    /// <para>Represents the following attribute in the schema: scaleWithDoc </para>
    /// </summary>
    [SchemaAttr(0, "scaleWithDoc")]
    public BooleanValue ScaleWithDoc
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Align Margins.</para>
    /// <para>Represents the following attribute in the schema: alignWithMargins </para>
    /// </summary>
    [SchemaAttr(0, "alignWithMargins")]
    public BooleanValue AlignWithMargins
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the HeaderFooter class.
    /// </summary>
    public HeaderFooter():base(){}
    
            /// <summary>
    ///Initializes a new instance of the HeaderFooter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HeaderFooter(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderFooter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HeaderFooter(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HeaderFooter class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HeaderFooter(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "oddHeader" == name)
    return new OddHeader();
    
if( 22 == namespaceId && "oddFooter" == name)
    return new OddFooter();
    
if( 22 == namespaceId && "evenHeader" == name)
    return new EvenHeader();
    
if( 22 == namespaceId && "evenFooter" == name)
    return new EvenFooter();
    
if( 22 == namespaceId && "firstHeader" == name)
    return new FirstHeader();
    
if( 22 == namespaceId && "firstFooter" == name)
    return new FirstFooter();
    

    return null;
}

        private static readonly string[] eleTagNames = { "oddHeader","oddFooter","evenHeader","evenFooter","firstHeader","firstFooter" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Odd Header.</para>
    /// <para> Represents the following element tag in the schema: x:oddHeader </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OddHeader OddHeader
    {
        get 
        {
            return GetElement<OddHeader>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Odd Page Footer.</para>
    /// <para> Represents the following element tag in the schema: x:oddFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OddFooter OddFooter
    {
        get 
        {
            return GetElement<OddFooter>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Even Page Header.</para>
    /// <para> Represents the following element tag in the schema: x:evenHeader </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public EvenHeader EvenHeader
    {
        get 
        {
            return GetElement<EvenHeader>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Even Page Footer.</para>
    /// <para> Represents the following element tag in the schema: x:evenFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public EvenFooter EvenFooter
    {
        get 
        {
            return GetElement<EvenFooter>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> First Page Header.</para>
    /// <para> Represents the following element tag in the schema: x:firstHeader </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FirstHeader FirstHeader
    {
        get 
        {
            return GetElement<FirstHeader>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> First Page Footer.</para>
    /// <para> Represents the following element tag in the schema: x:firstFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FirstFooter FirstFooter
    {
        get 
        {
            return GetElement<FirstFooter>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "differentOddEven" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "differentFirst" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "scaleWithDoc" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "alignWithMargins" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HeaderFooter>(deep);
    }

   
}
/// <summary>
/// <para>AutoFilter Settings.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:autoFilter.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FilterColumn &lt;x:filterColumn></description></item>
///<item><description>SortState &lt;x:sortState></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FilterColumn))]
    [ChildElementInfo(typeof(SortState))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoFilter : OpenXmlCompositeElement
{
    private const string tagName = "autoFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11263;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Cell or Range Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the AutoFilter class.
    /// </summary>
    public AutoFilter():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AutoFilter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoFilter(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoFilter class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoFilter(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoFilter class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AutoFilter(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "filterColumn" == name)
    return new FilterColumn();
    
if( 22 == namespaceId && "sortState" == name)
    return new SortState();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoFilter>(deep);
    }

   
}
/// <summary>
/// <para>Conditional Formatting Rule.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cfRule.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Formula &lt;x:formula></description></item>
///<item><description>ColorScale &lt;x:colorScale></description></item>
///<item><description>DataBar &lt;x:dataBar></description></item>
///<item><description>IconSet &lt;x:iconSet></description></item>
///<item><description>ConditionalFormattingRuleExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Formula))]
    [ChildElementInfo(typeof(ColorScale))]
    [ChildElementInfo(typeof(DataBar))]
    [ChildElementInfo(typeof(IconSet))]
    [ChildElementInfo(typeof(ConditionalFormattingRuleExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormattingRule : OpenXmlCompositeElement
{
    private const string tagName = "cfRule";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11264;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","dxfId","priority","stopIfTrue","aboveAverage","percent","bottom","operator","text","timePeriod","rank","stdDev","equalAverage" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Differential Formatting Id.</para>
    /// <para>Represents the following attribute in the schema: dxfId </para>
    /// </summary>
    [SchemaAttr(0, "dxfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Priority.</para>
    /// <para>Represents the following attribute in the schema: priority </para>
    /// </summary>
    [SchemaAttr(0, "priority")]
    public Int32Value Priority
    {
        get { return (Int32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Stop If True.</para>
    /// <para>Represents the following attribute in the schema: stopIfTrue </para>
    /// </summary>
    [SchemaAttr(0, "stopIfTrue")]
    public BooleanValue StopIfTrue
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Above Or Below Average.</para>
    /// <para>Represents the following attribute in the schema: aboveAverage </para>
    /// </summary>
    [SchemaAttr(0, "aboveAverage")]
    public BooleanValue AboveAverage
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Top 10 Percent.</para>
    /// <para>Represents the following attribute in the schema: percent </para>
    /// </summary>
    [SchemaAttr(0, "percent")]
    public BooleanValue Percent
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Bottom N.</para>
    /// <para>Represents the following attribute in the schema: bottom </para>
    /// </summary>
    [SchemaAttr(0, "bottom")]
    public BooleanValue Bottom
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Operator.</para>
    /// <para>Represents the following attribute in the schema: operator </para>
    /// </summary>
    [SchemaAttr(0, "operator")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingOperatorValues> Operator
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingOperatorValues>)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Text.</para>
    /// <para>Represents the following attribute in the schema: text </para>
    /// </summary>
    [SchemaAttr(0, "text")]
    public StringValue Text
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Time Period.</para>
    /// <para>Represents the following attribute in the schema: timePeriod </para>
    /// </summary>
    [SchemaAttr(0, "timePeriod")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TimePeriodValues> TimePeriod
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TimePeriodValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Rank.</para>
    /// <para>Represents the following attribute in the schema: rank </para>
    /// </summary>
    [SchemaAttr(0, "rank")]
    public UInt32Value Rank
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> StdDev.</para>
    /// <para>Represents the following attribute in the schema: stdDev </para>
    /// </summary>
    [SchemaAttr(0, "stdDev")]
    public Int32Value StdDev
    {
        get { return (Int32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Equal Average.</para>
    /// <para>Represents the following attribute in the schema: equalAverage </para>
    /// </summary>
    [SchemaAttr(0, "equalAverage")]
    public BooleanValue EqualAverage
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRule class.
    /// </summary>
    public ConditionalFormattingRule():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormattingRule class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRule(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRule class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRule(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRule class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormattingRule(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "formula" == name)
    return new Formula();
    
if( 22 == namespaceId && "colorScale" == name)
    return new ColorScale();
    
if( 22 == namespaceId && "dataBar" == name)
    return new DataBar();
    
if( 22 == namespaceId && "iconSet" == name)
    return new IconSet();
    
if( 22 == namespaceId && "extLst" == name)
    return new ConditionalFormattingRuleExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValues>();
    
if( 0 == namespaceId && "dxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "priority" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "stopIfTrue" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "aboveAverage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "percent" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "bottom" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "operator" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormattingOperatorValues>();
    
if( 0 == namespaceId && "text" == name)
    return new StringValue();
    
if( 0 == namespaceId && "timePeriod" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TimePeriodValues>();
    
if( 0 == namespaceId && "rank" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "stdDev" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "equalAverage" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormattingRule>(deep);
    }

   
}
/// <summary>
/// <para>Hyperlink.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:hyperlink.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hyperlink : OpenXmlLeafElement
{
    private const string tagName = "hyperlink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11265;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref","id","location","tooltip","display" };
    private static byte[] attributeNamespaceIds = { 0,19,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Location.</para>
    /// <para>Represents the following attribute in the schema: location </para>
    /// </summary>
    [SchemaAttr(0, "location")]
    public StringValue Location
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Tool Tip.</para>
    /// <para>Represents the following attribute in the schema: tooltip </para>
    /// </summary>
    [SchemaAttr(0, "tooltip")]
    public StringValue Tooltip
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Display String.</para>
    /// <para>Represents the following attribute in the schema: display </para>
    /// </summary>
    [SchemaAttr(0, "display")]
    public StringValue Display
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Hyperlink class.
    /// </summary>
    public Hyperlink():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "location" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tooltip" == name)
    return new StringValue();
    
if( 0 == namespaceId && "display" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hyperlink>(deep);
    }

   
}
/// <summary>
/// <para>Conditional Format Value Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cfvo.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormatValueObject : OpenXmlCompositeElement
{
    private const string tagName = "cfvo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11266;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","val","gte" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObjectValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObjectValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Greater Than Or Equal.</para>
    /// <para>Represents the following attribute in the schema: gte </para>
    /// </summary>
    [SchemaAttr(0, "gte")]
    public BooleanValue GreaterThanOrEqual
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormatValueObject class.
    /// </summary>
    public ConditionalFormatValueObject():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormatValueObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormatValueObject(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormatValueObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormatValueObject(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormatValueObject class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormatValueObject(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ConditionalFormatValueObjectValues>();
    
if( 0 == namespaceId && "val" == name)
    return new StringValue();
    
if( 0 == namespaceId && "gte" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormatValueObject>(deep);
    }

   
}
/// <summary>
/// <para>Scenario.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:scenario.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>InputCells &lt;x:inputCells></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(InputCells))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Scenario : OpenXmlCompositeElement
{
    private const string tagName = "scenario";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11267;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","locked","hidden","count","user","comment" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Scenario Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Scenario Locked.</para>
    /// <para>Represents the following attribute in the schema: locked </para>
    /// </summary>
    [SchemaAttr(0, "locked")]
    public BooleanValue Locked
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Scenario.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Changing Cell Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> User Name.</para>
    /// <para>Represents the following attribute in the schema: user </para>
    /// </summary>
    [SchemaAttr(0, "user")]
    public StringValue User
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Scenario Comment.</para>
    /// <para>Represents the following attribute in the schema: comment </para>
    /// </summary>
    [SchemaAttr(0, "comment")]
    public StringValue Comment
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Scenario class.
    /// </summary>
    public Scenario():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Scenario class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scenario(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Scenario class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scenario(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Scenario class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Scenario(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "inputCells" == name)
    return new InputCells();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "locked" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "user" == name)
    return new StringValue();
    
if( 0 == namespaceId && "comment" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Scenario>(deep);
    }

   
}
/// <summary>
/// <para>Protected Range.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:protectedRange.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ProtectedRange : OpenXmlLeafElement
{
    private const string tagName = "protectedRange";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11268;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "password","algorithmName","hashValue","saltValue","spinCount","sqref","name","securityDescriptor" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> password.</para>
    /// <para>Represents the following attribute in the schema: password </para>
    /// </summary>
    [SchemaAttr(0, "password")]
    public HexBinaryValue Password
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> algorithmName.</para>
    /// <para>Represents the following attribute in the schema: algorithmName </para>
    /// </summary>
    [SchemaAttr(0, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> hashValue.</para>
    /// <para>Represents the following attribute in the schema: hashValue </para>
    /// </summary>
    [SchemaAttr(0, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> saltValue.</para>
    /// <para>Represents the following attribute in the schema: saltValue </para>
    /// </summary>
    [SchemaAttr(0, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> spinCount.</para>
    /// <para>Represents the following attribute in the schema: spinCount </para>
    /// </summary>
    [SchemaAttr(0, "spinCount")]
    public UInt32Value SpinCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> sqref.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> securityDescriptor.</para>
    /// <para>Represents the following attribute in the schema: securityDescriptor </para>
    /// </summary>
    [SchemaAttr(0, "securityDescriptor")]
    public StringValue SecurityDescriptor
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ProtectedRange class.
    /// </summary>
    public ProtectedRange():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "password" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "spinCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "securityDescriptor" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ProtectedRange>(deep);
    }

   
}
/// <summary>
/// <para>Cell Watch Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellWatch.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellWatch : OpenXmlLeafElement
{
    private const string tagName = "cellWatch";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11269;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellWatch class.
    /// </summary>
    public CellWatch():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellWatch>(deep);
    }

   
}
/// <summary>
/// <para>Chart Sheet Page Setup.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageSetup.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartSheetPageSetup : OpenXmlLeafElement
{
    private const string tagName = "pageSetup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11270;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "paperSize","firstPageNumber","orientation","usePrinterDefaults","blackAndWhite","draft","useFirstPageNumber","horizontalDpi","verticalDpi","copies","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Paper Size.</para>
    /// <para>Represents the following attribute in the schema: paperSize </para>
    /// </summary>
    [SchemaAttr(0, "paperSize")]
    public UInt32Value PaperSize
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> First Page Number.</para>
    /// <para>Represents the following attribute in the schema: firstPageNumber </para>
    /// </summary>
    [SchemaAttr(0, "firstPageNumber")]
    public UInt32Value FirstPageNumber
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Orientation.</para>
    /// <para>Represents the following attribute in the schema: orientation </para>
    /// </summary>
    [SchemaAttr(0, "orientation")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues> Orientation
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Use Printer Defaults.</para>
    /// <para>Represents the following attribute in the schema: usePrinterDefaults </para>
    /// </summary>
    [SchemaAttr(0, "usePrinterDefaults")]
    public BooleanValue UsePrinterDefaults
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Black And White.</para>
    /// <para>Represents the following attribute in the schema: blackAndWhite </para>
    /// </summary>
    [SchemaAttr(0, "blackAndWhite")]
    public BooleanValue BlackAndWhite
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Draft.</para>
    /// <para>Represents the following attribute in the schema: draft </para>
    /// </summary>
    [SchemaAttr(0, "draft")]
    public BooleanValue Draft
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Use First Page Number.</para>
    /// <para>Represents the following attribute in the schema: useFirstPageNumber </para>
    /// </summary>
    [SchemaAttr(0, "useFirstPageNumber")]
    public BooleanValue UseFirstPageNumber
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Horizontal DPI.</para>
    /// <para>Represents the following attribute in the schema: horizontalDpi </para>
    /// </summary>
    [SchemaAttr(0, "horizontalDpi")]
    public UInt32Value HorizontalDpi
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Vertical DPI.</para>
    /// <para>Represents the following attribute in the schema: verticalDpi </para>
    /// </summary>
    [SchemaAttr(0, "verticalDpi")]
    public UInt32Value VerticalDpi
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Number Of Copies.</para>
    /// <para>Represents the following attribute in the schema: copies </para>
    /// </summary>
    [SchemaAttr(0, "copies")]
    public UInt32Value Copies
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartSheetPageSetup class.
    /// </summary>
    public ChartSheetPageSetup():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "paperSize" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "firstPageNumber" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "orientation" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.OrientationValues>();
    
if( 0 == namespaceId && "usePrinterDefaults" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "blackAndWhite" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "draft" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "useFirstPageNumber" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "horizontalDpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "verticalDpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "copies" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartSheetPageSetup>(deep);
    }

   
}
/// <summary>
/// <para>Custom Property.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomProperty : OpenXmlLeafElement
{
    private const string tagName = "customPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11271;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","id" };
    private static byte[] attributeNamespaceIds = { 0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Custom Property Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomProperty class.
    /// </summary>
    public CustomProperty():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomProperty>(deep);
    }

   
}
/// <summary>
/// <para>Web Publishing Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPublishItem.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPublishItem : OpenXmlLeafElement
{
    private const string tagName = "webPublishItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11272;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","divId","sourceType","sourceRef","sourceObject","destinationFile","title","autoRepublish" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Destination Bookmark.</para>
    /// <para>Represents the following attribute in the schema: divId </para>
    /// </summary>
    [SchemaAttr(0, "divId")]
    public StringValue DivId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Web Source Type.</para>
    /// <para>Represents the following attribute in the schema: sourceType </para>
    /// </summary>
    [SchemaAttr(0, "sourceType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.WebSourceValues> SourceType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.WebSourceValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Source Id.</para>
    /// <para>Represents the following attribute in the schema: sourceRef </para>
    /// </summary>
    [SchemaAttr(0, "sourceRef")]
    public StringValue SourceRef
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Source Object Name.</para>
    /// <para>Represents the following attribute in the schema: sourceObject </para>
    /// </summary>
    [SchemaAttr(0, "sourceObject")]
    public StringValue SourceObject
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Destination File Name.</para>
    /// <para>Represents the following attribute in the schema: destinationFile </para>
    /// </summary>
    [SchemaAttr(0, "destinationFile")]
    public StringValue DestinationFile
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Title.</para>
    /// <para>Represents the following attribute in the schema: title </para>
    /// </summary>
    [SchemaAttr(0, "title")]
    public StringValue Title
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Automatically Publish.</para>
    /// <para>Represents the following attribute in the schema: autoRepublish </para>
    /// </summary>
    [SchemaAttr(0, "autoRepublish")]
    public BooleanValue AutoRepublish
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPublishItem class.
    /// </summary>
    public WebPublishItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "divId" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sourceType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.WebSourceValues>();
    
if( 0 == namespaceId && "sourceRef" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sourceObject" == name)
    return new StringValue();
    
if( 0 == namespaceId && "destinationFile" == name)
    return new StringValue();
    
if( 0 == namespaceId && "title" == name)
    return new StringValue();
    
if( 0 == namespaceId && "autoRepublish" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPublishItem>(deep);
    }

   
}
/// <summary>
/// <para>Table Part.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tablePart.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TablePart : OpenXmlLeafElement
{
    private const string tagName = "tablePart";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11273;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TablePart class.
    /// </summary>
    public TablePart():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TablePart>(deep);
    }

   
}
/// <summary>
/// <para>Chart Sheet View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartSheetView : OpenXmlCompositeElement
{
    private const string tagName = "sheetView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11274;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "tabSelected","zoomScale","workbookViewId","zoomToFit" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Tab Selected.</para>
    /// <para>Represents the following attribute in the schema: tabSelected </para>
    /// </summary>
    [SchemaAttr(0, "tabSelected")]
    public BooleanValue TabSelected
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Window Zoom Scale.</para>
    /// <para>Represents the following attribute in the schema: zoomScale </para>
    /// </summary>
    [SchemaAttr(0, "zoomScale")]
    public UInt32Value ZoomScale
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Workbook View Id.</para>
    /// <para>Represents the following attribute in the schema: workbookViewId </para>
    /// </summary>
    [SchemaAttr(0, "workbookViewId")]
    public UInt32Value WorkbookViewId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Zoom To Fit.</para>
    /// <para>Represents the following attribute in the schema: zoomToFit </para>
    /// </summary>
    [SchemaAttr(0, "zoomToFit")]
    public BooleanValue ZoomToFit
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartSheetView class.
    /// </summary>
    public ChartSheetView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ChartSheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ChartSheetView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "tabSelected" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "zoomScale" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "workbookViewId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "zoomToFit" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartSheetView>(deep);
    }

   
}
/// <summary>
/// <para>Custom Chart Sheet View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customSheetView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PageMargins &lt;x:pageMargins></description></item>
///<item><description>ChartSheetPageSetup &lt;x:pageSetup></description></item>
///<item><description>HeaderFooter &lt;x:headerFooter></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PageMargins))]
    [ChildElementInfo(typeof(ChartSheetPageSetup))]
    [ChildElementInfo(typeof(HeaderFooter))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomChartsheetView : OpenXmlCompositeElement
{
    private const string tagName = "customSheetView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11275;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","scale","state","zoomToFit" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Print Scale.</para>
    /// <para>Represents the following attribute in the schema: scale </para>
    /// </summary>
    [SchemaAttr(0, "scale")]
    public UInt32Value Scale
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Visible State.</para>
    /// <para>Represents the following attribute in the schema: state </para>
    /// </summary>
    [SchemaAttr(0, "state")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues> State
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Zoom To Fit.</para>
    /// <para>Represents the following attribute in the schema: zoomToFit </para>
    /// </summary>
    [SchemaAttr(0, "zoomToFit")]
    public BooleanValue ZoomToFit
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomChartsheetView class.
    /// </summary>
    public CustomChartsheetView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomChartsheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomChartsheetView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomChartsheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomChartsheetView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomChartsheetView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomChartsheetView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pageMargins" == name)
    return new PageMargins();
    
if( 22 == namespaceId && "pageSetup" == name)
    return new ChartSheetPageSetup();
    
if( 22 == namespaceId && "headerFooter" == name)
    return new HeaderFooter();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pageMargins","pageSetup","headerFooter" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> PageMargins.</para>
    /// <para> Represents the following element tag in the schema: x:pageMargins </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageMargins PageMargins
    {
        get 
        {
            return GetElement<PageMargins>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Chart Sheet Page Setup.</para>
    /// <para> Represents the following element tag in the schema: x:pageSetup </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ChartSheetPageSetup ChartSheetPageSetup
    {
        get 
        {
            return GetElement<ChartSheetPageSetup>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> HeaderFooter.</para>
    /// <para> Represents the following element tag in the schema: x:headerFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public HeaderFooter HeaderFooter
    {
        get 
        {
            return GetElement<HeaderFooter>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "scale" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "state" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>();
    
if( 0 == namespaceId && "zoomToFit" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomChartsheetView>(deep);
    }

   
}
/// <summary>
/// <para>Input Cells.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:inputCells.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class InputCells : OpenXmlLeafElement
{
    private const string tagName = "inputCells";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11276;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","deleted","undone","val","numFmtId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Deleted.</para>
    /// <para>Represents the following attribute in the schema: deleted </para>
    /// </summary>
    [SchemaAttr(0, "deleted")]
    public BooleanValue Deleted
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Undone.</para>
    /// <para>Represents the following attribute in the schema: undone </para>
    /// </summary>
    [SchemaAttr(0, "undone")]
    public BooleanValue Undone
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Number Format Id.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the InputCells class.
    /// </summary>
    public InputCells():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "deleted" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "undone" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "val" == name)
    return new StringValue();
    
if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<InputCells>(deep);
    }

   
}
/// <summary>
/// <para>Embedded Control.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:control.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ControlProperties &lt;x:controlPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ControlProperties),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Control : OpenXmlCompositeElement
{
    private const string tagName = "control";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11277;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "shapeId","id","name" };
    private static byte[] attributeNamespaceIds = { 0,19,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Shape Id.</para>
    /// <para>Represents the following attribute in the schema: shapeId </para>
    /// </summary>
    [SchemaAttr(0, "shapeId")]
    public UInt32Value ShapeId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Control Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Control class.
    /// </summary>
    public Control():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Control class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Control(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Control class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Control(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Control class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Control(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "controlPr" == name)
    return new ControlProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "controlPr" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ControlProperties.</para>
    /// <para> Represents the following element tag in the schema: x:controlPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ControlProperties ControlProperties
    {
        get 
        {
            return GetElement<ControlProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "shapeId" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Control>(deep);
    }

   
}
/// <summary>
/// <para>Ignored Error.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ignoredError.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IgnoredError : OpenXmlLeafElement
{
    private const string tagName = "ignoredError";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11278;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sqref","evalError","twoDigitTextYear","numberStoredAsText","formula","formulaRange","unlockedFormula","emptyCellReference","listDataValidation","calculatedColumn" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sequence of References.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Evaluation Error.</para>
    /// <para>Represents the following attribute in the schema: evalError </para>
    /// </summary>
    [SchemaAttr(0, "evalError")]
    public BooleanValue EvalError
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Two Digit Text Year.</para>
    /// <para>Represents the following attribute in the schema: twoDigitTextYear </para>
    /// </summary>
    [SchemaAttr(0, "twoDigitTextYear")]
    public BooleanValue TwoDigitTextYear
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Number Stored As Text.</para>
    /// <para>Represents the following attribute in the schema: numberStoredAsText </para>
    /// </summary>
    [SchemaAttr(0, "numberStoredAsText")]
    public BooleanValue NumberStoredAsText
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Formula.</para>
    /// <para>Represents the following attribute in the schema: formula </para>
    /// </summary>
    [SchemaAttr(0, "formula")]
    public BooleanValue Formula
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Formula Range.</para>
    /// <para>Represents the following attribute in the schema: formulaRange </para>
    /// </summary>
    [SchemaAttr(0, "formulaRange")]
    public BooleanValue FormulaRange
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Unlocked Formula.</para>
    /// <para>Represents the following attribute in the schema: unlockedFormula </para>
    /// </summary>
    [SchemaAttr(0, "unlockedFormula")]
    public BooleanValue UnlockedFormula
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Empty Cell Reference.</para>
    /// <para>Represents the following attribute in the schema: emptyCellReference </para>
    /// </summary>
    [SchemaAttr(0, "emptyCellReference")]
    public BooleanValue EmptyCellReference
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> List Data Validation.</para>
    /// <para>Represents the following attribute in the schema: listDataValidation </para>
    /// </summary>
    [SchemaAttr(0, "listDataValidation")]
    public BooleanValue ListDataValidation
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Calculated Column.</para>
    /// <para>Represents the following attribute in the schema: calculatedColumn </para>
    /// </summary>
    [SchemaAttr(0, "calculatedColumn")]
    public BooleanValue CalculatedColumn
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the IgnoredError class.
    /// </summary>
    public IgnoredError():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    
if( 0 == namespaceId && "evalError" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "twoDigitTextYear" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "numberStoredAsText" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "formula" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "formulaRange" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "unlockedFormula" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "emptyCellReference" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "listDataValidation" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "calculatedColumn" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IgnoredError>(deep);
    }

   
}
/// <summary>
/// <para>Merged Cell.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mergeCell.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MergeCell : OpenXmlLeafElement
{
    private const string tagName = "mergeCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11279;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MergeCell class.
    /// </summary>
    public MergeCell():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MergeCell>(deep);
    }

   
}
/// <summary>
/// <para>Data Validation.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataValidation.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.ExcelAc.List &lt;x12ac:list></description></item>
///<item><description>Formula1 &lt;x:formula1></description></item>
///<item><description>Formula2 &lt;x:formula2></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.ExcelAc.List),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(Formula1))]
    [ChildElementInfo(typeof(Formula2))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataValidation : OpenXmlCompositeElement
{
    private const string tagName = "dataValidation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11280;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","errorStyle","imeMode","operator","allowBlank","showDropDown","showInputMessage","showErrorMessage","errorTitle","error","promptTitle","prompt","sqref" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> errorStyle.</para>
    /// <para>Represents the following attribute in the schema: errorStyle </para>
    /// </summary>
    [SchemaAttr(0, "errorStyle")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationErrorStyleValues> ErrorStyle
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationErrorStyleValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> imeMode.</para>
    /// <para>Represents the following attribute in the schema: imeMode </para>
    /// </summary>
    [SchemaAttr(0, "imeMode")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationImeModeValues> ImeMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationImeModeValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> operator.</para>
    /// <para>Represents the following attribute in the schema: operator </para>
    /// </summary>
    [SchemaAttr(0, "operator")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationOperatorValues> Operator
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationOperatorValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> allowBlank.</para>
    /// <para>Represents the following attribute in the schema: allowBlank </para>
    /// </summary>
    [SchemaAttr(0, "allowBlank")]
    public BooleanValue AllowBlank
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> showDropDown.</para>
    /// <para>Represents the following attribute in the schema: showDropDown </para>
    /// </summary>
    [SchemaAttr(0, "showDropDown")]
    public BooleanValue ShowDropDown
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> showInputMessage.</para>
    /// <para>Represents the following attribute in the schema: showInputMessage </para>
    /// </summary>
    [SchemaAttr(0, "showInputMessage")]
    public BooleanValue ShowInputMessage
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> showErrorMessage.</para>
    /// <para>Represents the following attribute in the schema: showErrorMessage </para>
    /// </summary>
    [SchemaAttr(0, "showErrorMessage")]
    public BooleanValue ShowErrorMessage
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> errorTitle.</para>
    /// <para>Represents the following attribute in the schema: errorTitle </para>
    /// </summary>
    [SchemaAttr(0, "errorTitle")]
    public StringValue ErrorTitle
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> error.</para>
    /// <para>Represents the following attribute in the schema: error </para>
    /// </summary>
    [SchemaAttr(0, "error")]
    public StringValue Error
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> promptTitle.</para>
    /// <para>Represents the following attribute in the schema: promptTitle </para>
    /// </summary>
    [SchemaAttr(0, "promptTitle")]
    public StringValue PromptTitle
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> prompt.</para>
    /// <para>Represents the following attribute in the schema: prompt </para>
    /// </summary>
    [SchemaAttr(0, "prompt")]
    public StringValue Prompt
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> sqref.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataValidation class.
    /// </summary>
    public DataValidation():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataValidation class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataValidation(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataValidation class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataValidation(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataValidation class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataValidation(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 72 == namespaceId && "list" == name)
    return new DocumentFormat.OpenXml.Office2010.ExcelAc.List();
    
if( 22 == namespaceId && "formula1" == name)
    return new Formula1();
    
if( 22 == namespaceId && "formula2" == name)
    return new Formula2();
    

    return null;
}

        private static readonly string[] eleTagNames = { "list","formula1","formula2" };
    private static readonly byte[] eleNamespaceIds = { 72,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> List.</para>
    /// <para> Represents the following element tag in the schema: x12ac:list </para>
    /// </summary>
    /// <remark>
    /// xmlns:x12ac = http://schemas.microsoft.com/office/spreadsheetml/2011/1/ac
    /// </remark>
    public DocumentFormat.OpenXml.Office2010.ExcelAc.List List
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Office2010.ExcelAc.List>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Formula1.</para>
    /// <para> Represents the following element tag in the schema: x:formula1 </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Formula1 Formula1
    {
        get 
        {
            return GetElement<Formula1>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Formula2.</para>
    /// <para> Represents the following element tag in the schema: x:formula2 </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Formula2 Formula2
    {
        get 
        {
            return GetElement<Formula2>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationValues>();
    
if( 0 == namespaceId && "errorStyle" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationErrorStyleValues>();
    
if( 0 == namespaceId && "imeMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationImeModeValues>();
    
if( 0 == namespaceId && "operator" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataValidationOperatorValues>();
    
if( 0 == namespaceId && "allowBlank" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showDropDown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showInputMessage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showErrorMessage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "errorTitle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "error" == name)
    return new StringValue();
    
if( 0 == namespaceId && "promptTitle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "prompt" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataValidation>(deep);
    }

   
}
/// <summary>
/// <para>Worksheet View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Pane &lt;x:pane></description></item>
///<item><description>Selection &lt;x:selection></description></item>
///<item><description>PivotSelection &lt;x:pivotSelection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Pane))]
    [ChildElementInfo(typeof(Selection))]
    [ChildElementInfo(typeof(PivotSelection))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetView : OpenXmlCompositeElement
{
    private const string tagName = "sheetView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11281;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "windowProtection","showFormulas","showGridLines","showRowColHeaders","showZeros","rightToLeft","tabSelected","showRuler","showOutlineSymbols","defaultGridColor","showWhiteSpace","view","topLeftCell","colorId","zoomScale","zoomScaleNormal","zoomScaleSheetLayoutView","zoomScalePageLayoutView","workbookViewId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Window Protection.</para>
    /// <para>Represents the following attribute in the schema: windowProtection </para>
    /// </summary>
    [SchemaAttr(0, "windowProtection")]
    public BooleanValue WindowProtection
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show Formulas.</para>
    /// <para>Represents the following attribute in the schema: showFormulas </para>
    /// </summary>
    [SchemaAttr(0, "showFormulas")]
    public BooleanValue ShowFormulas
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Grid Lines.</para>
    /// <para>Represents the following attribute in the schema: showGridLines </para>
    /// </summary>
    [SchemaAttr(0, "showGridLines")]
    public BooleanValue ShowGridLines
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Headers.</para>
    /// <para>Represents the following attribute in the schema: showRowColHeaders </para>
    /// </summary>
    [SchemaAttr(0, "showRowColHeaders")]
    public BooleanValue ShowRowColHeaders
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Zero Values.</para>
    /// <para>Represents the following attribute in the schema: showZeros </para>
    /// </summary>
    [SchemaAttr(0, "showZeros")]
    public BooleanValue ShowZeros
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Right To Left.</para>
    /// <para>Represents the following attribute in the schema: rightToLeft </para>
    /// </summary>
    [SchemaAttr(0, "rightToLeft")]
    public BooleanValue RightToLeft
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Tab Selected.</para>
    /// <para>Represents the following attribute in the schema: tabSelected </para>
    /// </summary>
    [SchemaAttr(0, "tabSelected")]
    public BooleanValue TabSelected
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Show Ruler.</para>
    /// <para>Represents the following attribute in the schema: showRuler </para>
    /// </summary>
    [SchemaAttr(0, "showRuler")]
    public BooleanValue ShowRuler
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Show Outline Symbols.</para>
    /// <para>Represents the following attribute in the schema: showOutlineSymbols </para>
    /// </summary>
    [SchemaAttr(0, "showOutlineSymbols")]
    public BooleanValue ShowOutlineSymbols
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Default Grid Color.</para>
    /// <para>Represents the following attribute in the schema: defaultGridColor </para>
    /// </summary>
    [SchemaAttr(0, "defaultGridColor")]
    public BooleanValue DefaultGridColor
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Show White Space.</para>
    /// <para>Represents the following attribute in the schema: showWhiteSpace </para>
    /// </summary>
    [SchemaAttr(0, "showWhiteSpace")]
    public BooleanValue ShowWhiteSpace
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> View Type.</para>
    /// <para>Represents the following attribute in the schema: view </para>
    /// </summary>
    [SchemaAttr(0, "view")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues> View
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Visible Cell.</para>
    /// <para>Represents the following attribute in the schema: topLeftCell </para>
    /// </summary>
    [SchemaAttr(0, "topLeftCell")]
    public StringValue TopLeftCell
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Color Id.</para>
    /// <para>Represents the following attribute in the schema: colorId </para>
    /// </summary>
    [SchemaAttr(0, "colorId")]
    public UInt32Value ColorId
    {
        get { return (UInt32Value)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Zoom Scale.</para>
    /// <para>Represents the following attribute in the schema: zoomScale </para>
    /// </summary>
    [SchemaAttr(0, "zoomScale")]
    public UInt32Value ZoomScale
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Zoom Scale Normal View.</para>
    /// <para>Represents the following attribute in the schema: zoomScaleNormal </para>
    /// </summary>
    [SchemaAttr(0, "zoomScaleNormal")]
    public UInt32Value ZoomScaleNormal
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Zoom Scale Page Break Preview.</para>
    /// <para>Represents the following attribute in the schema: zoomScaleSheetLayoutView </para>
    /// </summary>
    [SchemaAttr(0, "zoomScaleSheetLayoutView")]
    public UInt32Value ZoomScaleSheetLayoutView
    {
        get { return (UInt32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Zoom Scale Page Layout View.</para>
    /// <para>Represents the following attribute in the schema: zoomScalePageLayoutView </para>
    /// </summary>
    [SchemaAttr(0, "zoomScalePageLayoutView")]
    public UInt32Value ZoomScalePageLayoutView
    {
        get { return (UInt32Value)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Workbook View Index.</para>
    /// <para>Represents the following attribute in the schema: workbookViewId </para>
    /// </summary>
    [SchemaAttr(0, "workbookViewId")]
    public UInt32Value WorkbookViewId
    {
        get { return (UInt32Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetView class.
    /// </summary>
    public SheetView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pane" == name)
    return new Pane();
    
if( 22 == namespaceId && "selection" == name)
    return new Selection();
    
if( 22 == namespaceId && "pivotSelection" == name)
    return new PivotSelection();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pane","selection","pivotSelection","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> View Pane.</para>
    /// <para> Represents the following element tag in the schema: x:pane </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Pane Pane
    {
        get 
        {
            return GetElement<Pane>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "windowProtection" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showFormulas" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showGridLines" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showRowColHeaders" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showZeros" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rightToLeft" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "tabSelected" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showRuler" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showOutlineSymbols" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultGridColor" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showWhiteSpace" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "view" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>();
    
if( 0 == namespaceId && "topLeftCell" == name)
    return new StringValue();
    
if( 0 == namespaceId && "colorId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "zoomScale" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "zoomScaleNormal" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "zoomScaleSheetLayoutView" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "zoomScalePageLayoutView" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "workbookViewId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetView>(deep);
    }

   
}
/// <summary>
/// <para>Custom Sheet View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customSheetView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Pane &lt;x:pane></description></item>
///<item><description>Selection &lt;x:selection></description></item>
///<item><description>RowBreaks &lt;x:rowBreaks></description></item>
///<item><description>ColumnBreaks &lt;x:colBreaks></description></item>
///<item><description>PageMargins &lt;x:pageMargins></description></item>
///<item><description>PrintOptions &lt;x:printOptions></description></item>
///<item><description>PageSetup &lt;x:pageSetup></description></item>
///<item><description>HeaderFooter &lt;x:headerFooter></description></item>
///<item><description>AutoFilter &lt;x:autoFilter></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Pane))]
    [ChildElementInfo(typeof(Selection))]
    [ChildElementInfo(typeof(RowBreaks))]
    [ChildElementInfo(typeof(ColumnBreaks))]
    [ChildElementInfo(typeof(PageMargins))]
    [ChildElementInfo(typeof(PrintOptions))]
    [ChildElementInfo(typeof(PageSetup))]
    [ChildElementInfo(typeof(HeaderFooter))]
    [ChildElementInfo(typeof(AutoFilter))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomSheetView : OpenXmlCompositeElement
{
    private const string tagName = "customSheetView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11282;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "guid","scale","colorId","showPageBreaks","showFormulas","showGridLines","showRowCol","outlineSymbols","zeroValues","fitToPage","printArea","filter","showAutoFilter","hiddenRows","hiddenColumns","state","filterUnique","view","showRuler","topLeftCell" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Print Scale.</para>
    /// <para>Represents the following attribute in the schema: scale </para>
    /// </summary>
    [SchemaAttr(0, "scale")]
    public UInt32Value Scale
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Color Id.</para>
    /// <para>Represents the following attribute in the schema: colorId </para>
    /// </summary>
    [SchemaAttr(0, "colorId")]
    public UInt32Value ColorId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Page Breaks.</para>
    /// <para>Represents the following attribute in the schema: showPageBreaks </para>
    /// </summary>
    [SchemaAttr(0, "showPageBreaks")]
    public BooleanValue ShowPageBreaks
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Formulas.</para>
    /// <para>Represents the following attribute in the schema: showFormulas </para>
    /// </summary>
    [SchemaAttr(0, "showFormulas")]
    public BooleanValue ShowFormulas
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Show Grid Lines.</para>
    /// <para>Represents the following attribute in the schema: showGridLines </para>
    /// </summary>
    [SchemaAttr(0, "showGridLines")]
    public BooleanValue ShowGridLines
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Show Headers.</para>
    /// <para>Represents the following attribute in the schema: showRowCol </para>
    /// </summary>
    [SchemaAttr(0, "showRowCol")]
    public BooleanValue ShowRowColumn
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Show Outline Symbols.</para>
    /// <para>Represents the following attribute in the schema: outlineSymbols </para>
    /// </summary>
    [SchemaAttr(0, "outlineSymbols")]
    public BooleanValue OutlineSymbols
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Show Zero Values.</para>
    /// <para>Represents the following attribute in the schema: zeroValues </para>
    /// </summary>
    [SchemaAttr(0, "zeroValues")]
    public BooleanValue ZeroValues
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Fit To Page.</para>
    /// <para>Represents the following attribute in the schema: fitToPage </para>
    /// </summary>
    [SchemaAttr(0, "fitToPage")]
    public BooleanValue FitToPage
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Print Area Defined.</para>
    /// <para>Represents the following attribute in the schema: printArea </para>
    /// </summary>
    [SchemaAttr(0, "printArea")]
    public BooleanValue PrintArea
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Filtered List.</para>
    /// <para>Represents the following attribute in the schema: filter </para>
    /// </summary>
    [SchemaAttr(0, "filter")]
    public BooleanValue Filter
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Show AutoFitler Drop Down Controls.</para>
    /// <para>Represents the following attribute in the schema: showAutoFilter </para>
    /// </summary>
    [SchemaAttr(0, "showAutoFilter")]
    public BooleanValue ShowAutoFilter
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Rows.</para>
    /// <para>Represents the following attribute in the schema: hiddenRows </para>
    /// </summary>
    [SchemaAttr(0, "hiddenRows")]
    public BooleanValue HiddenRows
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Columns.</para>
    /// <para>Represents the following attribute in the schema: hiddenColumns </para>
    /// </summary>
    [SchemaAttr(0, "hiddenColumns")]
    public BooleanValue HiddenColumns
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Visible State.</para>
    /// <para>Represents the following attribute in the schema: state </para>
    /// </summary>
    [SchemaAttr(0, "state")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues> State
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Filter.</para>
    /// <para>Represents the following attribute in the schema: filterUnique </para>
    /// </summary>
    [SchemaAttr(0, "filterUnique")]
    public BooleanValue FilterUnique
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> View Type.</para>
    /// <para>Represents the following attribute in the schema: view </para>
    /// </summary>
    [SchemaAttr(0, "view")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues> View
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Show Ruler.</para>
    /// <para>Represents the following attribute in the schema: showRuler </para>
    /// </summary>
    [SchemaAttr(0, "showRuler")]
    public BooleanValue ShowRuler
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Visible Cell.</para>
    /// <para>Represents the following attribute in the schema: topLeftCell </para>
    /// </summary>
    [SchemaAttr(0, "topLeftCell")]
    public StringValue TopLeftCell
    {
        get { return (StringValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomSheetView class.
    /// </summary>
    public CustomSheetView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomSheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomSheetView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomSheetView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomSheetView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomSheetView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomSheetView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pane" == name)
    return new Pane();
    
if( 22 == namespaceId && "selection" == name)
    return new Selection();
    
if( 22 == namespaceId && "rowBreaks" == name)
    return new RowBreaks();
    
if( 22 == namespaceId && "colBreaks" == name)
    return new ColumnBreaks();
    
if( 22 == namespaceId && "pageMargins" == name)
    return new PageMargins();
    
if( 22 == namespaceId && "printOptions" == name)
    return new PrintOptions();
    
if( 22 == namespaceId && "pageSetup" == name)
    return new PageSetup();
    
if( 22 == namespaceId && "headerFooter" == name)
    return new HeaderFooter();
    
if( 22 == namespaceId && "autoFilter" == name)
    return new AutoFilter();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pane","selection","rowBreaks","colBreaks","pageMargins","printOptions","pageSetup","headerFooter","autoFilter","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Pane Split Information.</para>
    /// <para> Represents the following element tag in the schema: x:pane </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Pane Pane
    {
        get 
        {
            return GetElement<Pane>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Selection.</para>
    /// <para> Represents the following element tag in the schema: x:selection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Selection Selection
    {
        get 
        {
            return GetElement<Selection>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Horizontal Page Breaks.</para>
    /// <para> Represents the following element tag in the schema: x:rowBreaks </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RowBreaks RowBreaks
    {
        get 
        {
            return GetElement<RowBreaks>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Vertical Page Breaks.</para>
    /// <para> Represents the following element tag in the schema: x:colBreaks </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ColumnBreaks ColumnBreaks
    {
        get 
        {
            return GetElement<ColumnBreaks>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Page Margins.</para>
    /// <para> Represents the following element tag in the schema: x:pageMargins </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageMargins PageMargins
    {
        get 
        {
            return GetElement<PageMargins>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Print Options.</para>
    /// <para> Represents the following element tag in the schema: x:printOptions </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PrintOptions PrintOptions
    {
        get 
        {
            return GetElement<PrintOptions>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Page Setup Settings.</para>
    /// <para> Represents the following element tag in the schema: x:pageSetup </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageSetup PageSetup
    {
        get 
        {
            return GetElement<PageSetup>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Header Footer Settings.</para>
    /// <para> Represents the following element tag in the schema: x:headerFooter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public HeaderFooter HeaderFooter
    {
        get 
        {
            return GetElement<HeaderFooter>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> AutoFilter Settings.</para>
    /// <para> Represents the following element tag in the schema: x:autoFilter </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public AutoFilter AutoFilter
    {
        get 
        {
            return GetElement<AutoFilter>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "scale" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "colorId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "showPageBreaks" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showFormulas" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showGridLines" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showRowCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outlineSymbols" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "zeroValues" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fitToPage" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "printArea" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "filter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showAutoFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hiddenRows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hiddenColumns" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "state" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>();
    
if( 0 == namespaceId && "filterUnique" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "view" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetViewValues>();
    
if( 0 == namespaceId && "showRuler" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "topLeftCell" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomSheetView>(deep);
    }

   
}
/// <summary>
/// <para>OLE Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleObject.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>EmbeddedObjectProperties &lt;x:objectPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(EmbeddedObjectProperties),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleObject : OpenXmlCompositeElement
{
    private const string tagName = "oleObject";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11283;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "progId","dvAspect","link","oleUpdate","autoLoad","shapeId","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLE ProgId.</para>
    /// <para>Represents the following attribute in the schema: progId </para>
    /// </summary>
    [SchemaAttr(0, "progId")]
    public StringValue ProgId
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Data or View Aspect.</para>
    /// <para>Represents the following attribute in the schema: dvAspect </para>
    /// </summary>
    [SchemaAttr(0, "dvAspect")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataViewAspectValues> DataOrViewAspect
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataViewAspectValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> OLE Link Moniker.</para>
    /// <para>Represents the following attribute in the schema: link </para>
    /// </summary>
    [SchemaAttr(0, "link")]
    public StringValue Link
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> OLE Update.</para>
    /// <para>Represents the following attribute in the schema: oleUpdate </para>
    /// </summary>
    [SchemaAttr(0, "oleUpdate")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.OleUpdateValues> OleUpdate
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.OleUpdateValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Auto Load.</para>
    /// <para>Represents the following attribute in the schema: autoLoad </para>
    /// </summary>
    [SchemaAttr(0, "autoLoad")]
    public BooleanValue AutoLoad
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Shape Id.</para>
    /// <para>Represents the following attribute in the schema: shapeId </para>
    /// </summary>
    [SchemaAttr(0, "shapeId")]
    public UInt32Value ShapeId
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OleObject class.
    /// </summary>
    public OleObject():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OleObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleObject(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OleObject class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleObject(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OleObject class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OleObject(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "objectPr" == name)
    return new EmbeddedObjectProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "objectPr" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> EmbeddedObjectProperties.</para>
    /// <para> Represents the following element tag in the schema: x:objectPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public EmbeddedObjectProperties EmbeddedObjectProperties
    {
        get 
        {
            return GetElement<EmbeddedObjectProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "progId" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dvAspect" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataViewAspectValues>();
    
if( 0 == namespaceId && "link" == name)
    return new StringValue();
    
if( 0 == namespaceId && "oleUpdate" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.OleUpdateValues>();
    
if( 0 == namespaceId && "autoLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "shapeId" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleObject>(deep);
    }

   
}
/// <summary>
/// <para>Metadata Types Collection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:metadataTypes.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataType &lt;x:metadataType></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MetadataType))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MetadataTypes : OpenXmlCompositeElement
{
    private const string tagName = "metadataTypes";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11290;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Metadata Type Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MetadataTypes class.
    /// </summary>
    public MetadataTypes():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MetadataTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataTypes(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataTypes class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataTypes(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataTypes class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MetadataTypes(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "metadataType" == name)
    return new MetadataType();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MetadataTypes>(deep);
    }

   
}
/// <summary>
/// <para>Metadata String Store.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:metadataStrings.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CharacterValue &lt;x:s></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CharacterValue))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MetadataStrings : OpenXmlCompositeElement
{
    private const string tagName = "metadataStrings";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11291;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> MDX Metadata String Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MetadataStrings class.
    /// </summary>
    public MetadataStrings():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MetadataStrings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataStrings(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataStrings class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataStrings(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataStrings class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MetadataStrings(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "s" == name)
    return new CharacterValue();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MetadataStrings>(deep);
    }

   
}
/// <summary>
/// <para>MDX Metadata Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mdxMetadata.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Mdx &lt;x:mdx></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Mdx))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MdxMetadata : OpenXmlCompositeElement
{
    private const string tagName = "mdxMetadata";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11292;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> MDX Metadata Record Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MdxMetadata class.
    /// </summary>
    public MdxMetadata():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MdxMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxMetadata(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxMetadata(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxMetadata class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MdxMetadata(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "mdx" == name)
    return new Mdx();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MdxMetadata>(deep);
    }

   
}
/// <summary>
/// <para>Future Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:futureMetadata.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FutureMetadataBlock &lt;x:bk></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FutureMetadataBlock))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FutureMetadata : OpenXmlCompositeElement
{
    private const string tagName = "futureMetadata";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11293;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","count" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Metadata Type Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Future Metadata Block Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FutureMetadata class.
    /// </summary>
    public FutureMetadata():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FutureMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FutureMetadata(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FutureMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FutureMetadata(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FutureMetadata class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FutureMetadata(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "bk" == name)
    return new FutureMetadataBlock();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FutureMetadata>(deep);
    }

   
}
/// <summary>
/// <para>Cell Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellMetadata.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataBlock &lt;x:bk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellMetadata : MetadataBlocksType
{
    private const string tagName = "cellMetadata";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11294;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CellMetadata class.
    /// </summary>
    public CellMetadata():base(){}
            /// <summary>
    ///Initializes a new instance of the CellMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellMetadata(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellMetadata(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellMetadata class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellMetadata(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellMetadata>(deep);
    }

}
/// <summary>
/// <para>Value Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:valueMetadata.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataBlock &lt;x:bk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ValueMetadata : MetadataBlocksType
{
    private const string tagName = "valueMetadata";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11295;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ValueMetadata class.
    /// </summary>
    public ValueMetadata():base(){}
            /// <summary>
    ///Initializes a new instance of the ValueMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ValueMetadata(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ValueMetadata class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ValueMetadata(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ValueMetadata class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ValueMetadata(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ValueMetadata>(deep);
    }

}
/// <summary>
/// Defines the MetadataBlocksType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataBlock &lt;x:bk></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MetadataBlock))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MetadataBlocksType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Metadata Block Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "bk" == name)
    return new MetadataBlock();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the MetadataBlocksType class.
    /// </summary>
    protected MetadataBlocksType(){}
    
            /// <summary>
    ///Initializes a new instance of the MetadataBlocksType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MetadataBlocksType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataBlocksType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MetadataBlocksType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataBlocksType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected MetadataBlocksType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Metadata Type Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:metadataType.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MetadataType : OpenXmlLeafElement
{
    private const string tagName = "metadataType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11296;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","minSupportedVersion","ghostRow","ghostCol","edit","delete","copy","pasteAll","pasteFormulas","pasteValues","pasteFormats","pasteComments","pasteDataValidation","pasteBorders","pasteColWidths","pasteNumberFormats","merge","splitFirst","splitAll","rowColShift","clearAll","clearFormats","clearContents","clearComments","assign","coerce","adjust","cellMeta" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Metadata Type Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Supported Version.</para>
    /// <para>Represents the following attribute in the schema: minSupportedVersion </para>
    /// </summary>
    [SchemaAttr(0, "minSupportedVersion")]
    public UInt32Value MinSupportedVersion
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Ghost Row.</para>
    /// <para>Represents the following attribute in the schema: ghostRow </para>
    /// </summary>
    [SchemaAttr(0, "ghostRow")]
    public BooleanValue GhostRow
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Ghost Column.</para>
    /// <para>Represents the following attribute in the schema: ghostCol </para>
    /// </summary>
    [SchemaAttr(0, "ghostCol")]
    public BooleanValue GhostColumn
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Edit.</para>
    /// <para>Represents the following attribute in the schema: edit </para>
    /// </summary>
    [SchemaAttr(0, "edit")]
    public BooleanValue Edit
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Cell Value Delete.</para>
    /// <para>Represents the following attribute in the schema: delete </para>
    /// </summary>
    [SchemaAttr(0, "delete")]
    public BooleanValue Delete
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Copy.</para>
    /// <para>Represents the following attribute in the schema: copy </para>
    /// </summary>
    [SchemaAttr(0, "copy")]
    public BooleanValue Copy
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste All.</para>
    /// <para>Represents the following attribute in the schema: pasteAll </para>
    /// </summary>
    [SchemaAttr(0, "pasteAll")]
    public BooleanValue PasteAll
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Formulas.</para>
    /// <para>Represents the following attribute in the schema: pasteFormulas </para>
    /// </summary>
    [SchemaAttr(0, "pasteFormulas")]
    public BooleanValue PasteFormulas
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Special Values.</para>
    /// <para>Represents the following attribute in the schema: pasteValues </para>
    /// </summary>
    [SchemaAttr(0, "pasteValues")]
    public BooleanValue PasteValues
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Formats.</para>
    /// <para>Represents the following attribute in the schema: pasteFormats </para>
    /// </summary>
    [SchemaAttr(0, "pasteFormats")]
    public BooleanValue PasteFormats
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Comments.</para>
    /// <para>Represents the following attribute in the schema: pasteComments </para>
    /// </summary>
    [SchemaAttr(0, "pasteComments")]
    public BooleanValue PasteComments
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Data Validation.</para>
    /// <para>Represents the following attribute in the schema: pasteDataValidation </para>
    /// </summary>
    [SchemaAttr(0, "pasteDataValidation")]
    public BooleanValue PasteDataValidation
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Borders.</para>
    /// <para>Represents the following attribute in the schema: pasteBorders </para>
    /// </summary>
    [SchemaAttr(0, "pasteBorders")]
    public BooleanValue PasteBorders
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Column Widths.</para>
    /// <para>Represents the following attribute in the schema: pasteColWidths </para>
    /// </summary>
    [SchemaAttr(0, "pasteColWidths")]
    public BooleanValue PasteColWidths
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Paste Number Formats.</para>
    /// <para>Represents the following attribute in the schema: pasteNumberFormats </para>
    /// </summary>
    [SchemaAttr(0, "pasteNumberFormats")]
    public BooleanValue PasteNumberFormats
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Merge.</para>
    /// <para>Represents the following attribute in the schema: merge </para>
    /// </summary>
    [SchemaAttr(0, "merge")]
    public BooleanValue Merge
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Meatadata Split First.</para>
    /// <para>Represents the following attribute in the schema: splitFirst </para>
    /// </summary>
    [SchemaAttr(0, "splitFirst")]
    public BooleanValue SplitFirst
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Split All.</para>
    /// <para>Represents the following attribute in the schema: splitAll </para>
    /// </summary>
    [SchemaAttr(0, "splitAll")]
    public BooleanValue SplitAll
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Insert Delete.</para>
    /// <para>Represents the following attribute in the schema: rowColShift </para>
    /// </summary>
    [SchemaAttr(0, "rowColShift")]
    public BooleanValue RowColumnShift
    {
        get { return (BooleanValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Clear All.</para>
    /// <para>Represents the following attribute in the schema: clearAll </para>
    /// </summary>
    [SchemaAttr(0, "clearAll")]
    public BooleanValue ClearAll
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Clear Formats.</para>
    /// <para>Represents the following attribute in the schema: clearFormats </para>
    /// </summary>
    [SchemaAttr(0, "clearFormats")]
    public BooleanValue ClearFormats
    {
        get { return (BooleanValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Clear Contents.</para>
    /// <para>Represents the following attribute in the schema: clearContents </para>
    /// </summary>
    [SchemaAttr(0, "clearContents")]
    public BooleanValue ClearContents
    {
        get { return (BooleanValue)Attributes[22]; }
        set { Attributes[22] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Clear Comments.</para>
    /// <para>Represents the following attribute in the schema: clearComments </para>
    /// </summary>
    [SchemaAttr(0, "clearComments")]
    public BooleanValue ClearComments
    {
        get { return (BooleanValue)Attributes[23]; }
        set { Attributes[23] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Formula Assignment.</para>
    /// <para>Represents the following attribute in the schema: assign </para>
    /// </summary>
    [SchemaAttr(0, "assign")]
    public BooleanValue Assign
    {
        get { return (BooleanValue)Attributes[24]; }
        set { Attributes[24] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Coercion.</para>
    /// <para>Represents the following attribute in the schema: coerce </para>
    /// </summary>
    [SchemaAttr(0, "coerce")]
    public BooleanValue Coerce
    {
        get { return (BooleanValue)Attributes[25]; }
        set { Attributes[25] = value; }
    }
    
    /// <summary>
    /// <para> Adjust Metadata.</para>
    /// <para>Represents the following attribute in the schema: adjust </para>
    /// </summary>
    [SchemaAttr(0, "adjust")]
    public BooleanValue Adjust
    {
        get { return (BooleanValue)Attributes[26]; }
        set { Attributes[26] = value; }
    }
    
    /// <summary>
    /// <para> Cell Metadata.</para>
    /// <para>Represents the following attribute in the schema: cellMeta </para>
    /// </summary>
    [SchemaAttr(0, "cellMeta")]
    public BooleanValue CellMeta
    {
        get { return (BooleanValue)Attributes[27]; }
        set { Attributes[27] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MetadataType class.
    /// </summary>
    public MetadataType():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "minSupportedVersion" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ghostRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "ghostCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "edit" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "delete" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "copy" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteAll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteFormulas" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteValues" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteComments" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteDataValidation" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteBorders" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteColWidths" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pasteNumberFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "merge" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "splitFirst" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "splitAll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowColShift" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "clearAll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "clearFormats" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "clearContents" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "clearComments" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "assign" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "coerce" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "adjust" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "cellMeta" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MetadataType>(deep);
    }

   
}
/// <summary>
/// <para>Metadata Block.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:bk.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MetadataRecord &lt;x:rc></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MetadataRecord))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MetadataBlock : OpenXmlCompositeElement
{
    private const string tagName = "bk";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11297;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the MetadataBlock class.
    /// </summary>
    public MetadataBlock():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MetadataBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataBlock(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MetadataBlock(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MetadataBlock class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MetadataBlock(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rc" == name)
    return new MetadataRecord();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MetadataBlock>(deep);
    }

   
}
/// <summary>
/// <para>Metadata Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rc.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MetadataRecord : OpenXmlLeafElement
{
    private const string tagName = "rc";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11298;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "t","v" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Metadata Record Type Index.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public UInt32Value TypeIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Metadata Record Value Index.</para>
    /// <para>Represents the following attribute in the schema: v </para>
    /// </summary>
    [SchemaAttr(0, "v")]
    public UInt32Value Val
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MetadataRecord class.
    /// </summary>
    public MetadataRecord():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "t" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "v" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MetadataRecord>(deep);
    }

   
}
/// <summary>
/// <para>Future Metadata Block.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:bk.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FutureMetadataBlock : OpenXmlCompositeElement
{
    private const string tagName = "bk";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11299;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the FutureMetadataBlock class.
    /// </summary>
    public FutureMetadataBlock():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FutureMetadataBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FutureMetadataBlock(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FutureMetadataBlock class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FutureMetadataBlock(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FutureMetadataBlock class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FutureMetadataBlock(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FutureMetadataBlock>(deep);
    }

   
}
/// <summary>
/// <para>MDX Metadata Record.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mdx.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MdxTuple &lt;x:t></description></item>
///<item><description>MdxSet &lt;x:ms></description></item>
///<item><description>MdxMemberProp &lt;x:p></description></item>
///<item><description>MdxKpi &lt;x:k></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MdxTuple))]
    [ChildElementInfo(typeof(MdxSet))]
    [ChildElementInfo(typeof(MdxMemberProp))]
    [ChildElementInfo(typeof(MdxKpi))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Mdx : OpenXmlCompositeElement
{
    private const string tagName = "mdx";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11300;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "n","f" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Connection Name Index.</para>
    /// <para>Represents the following attribute in the schema: n </para>
    /// </summary>
    [SchemaAttr(0, "n")]
    public UInt32Value NameIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Cube Function Tag.</para>
    /// <para>Represents the following attribute in the schema: f </para>
    /// </summary>
    [SchemaAttr(0, "f")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxFunctionValues> CubeFunction
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxFunctionValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Mdx class.
    /// </summary>
    public Mdx():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Mdx class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Mdx(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Mdx class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Mdx(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Mdx class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Mdx(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "t" == name)
    return new MdxTuple();
    
if( 22 == namespaceId && "ms" == name)
    return new MdxSet();
    
if( 22 == namespaceId && "p" == name)
    return new MdxMemberProp();
    
if( 22 == namespaceId && "k" == name)
    return new MdxKpi();
    

    return null;
}

        private static readonly string[] eleTagNames = { "t","ms","p","k" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Tuple MDX Metadata.</para>
    /// <para> Represents the following element tag in the schema: x:t </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MdxTuple MdxTuple
    {
        get 
        {
            return GetElement<MdxTuple>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Set MDX Metadata.</para>
    /// <para> Represents the following element tag in the schema: x:ms </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MdxSet MdxSet
    {
        get 
        {
            return GetElement<MdxSet>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Member Property MDX Metadata.</para>
    /// <para> Represents the following element tag in the schema: x:p </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MdxMemberProp MdxMemberProp
    {
        get 
        {
            return GetElement<MdxMemberProp>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> KPI MDX Metadata.</para>
    /// <para> Represents the following element tag in the schema: x:k </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MdxKpi MdxKpi
    {
        get 
        {
            return GetElement<MdxKpi>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "n" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "f" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxFunctionValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Mdx>(deep);
    }

   
}
/// <summary>
/// <para>Tuple MDX Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:t.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NameIndex &lt;x:n></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NameIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MdxTuple : OpenXmlCompositeElement
{
    private const string tagName = "t";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11301;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "c","ct","si","fi","bc","fc","i","u","st","b" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Member Index Count.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public UInt32Value MemberIndexCount
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Culture Currency.</para>
    /// <para>Represents the following attribute in the schema: ct </para>
    /// </summary>
    [SchemaAttr(0, "ct")]
    public StringValue CultureCurrency
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting String Index.</para>
    /// <para>Represents the following attribute in the schema: si </para>
    /// </summary>
    [SchemaAttr(0, "si")]
    public UInt32Value FormattingStringIndex
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Built-In Number Format Index.</para>
    /// <para>Represents the following attribute in the schema: fi </para>
    /// </summary>
    [SchemaAttr(0, "fi")]
    public UInt32Value FormatIndex
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Background Color.</para>
    /// <para>Represents the following attribute in the schema: bc </para>
    /// </summary>
    [SchemaAttr(0, "bc")]
    public HexBinaryValue BackgroundColor
    {
        get { return (HexBinaryValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Foreground Color.</para>
    /// <para>Represents the following attribute in the schema: fc </para>
    /// </summary>
    [SchemaAttr(0, "fc")]
    public HexBinaryValue ForegroundColor
    {
        get { return (HexBinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Italic Font.</para>
    /// <para>Represents the following attribute in the schema: i </para>
    /// </summary>
    [SchemaAttr(0, "i")]
    public BooleanValue Italic
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Underline Font.</para>
    /// <para>Represents the following attribute in the schema: u </para>
    /// </summary>
    [SchemaAttr(0, "u")]
    public BooleanValue Underline
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Strikethrough Font.</para>
    /// <para>Represents the following attribute in the schema: st </para>
    /// </summary>
    [SchemaAttr(0, "st")]
    public BooleanValue Strikethrough
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Server Formatting Bold Font.</para>
    /// <para>Represents the following attribute in the schema: b </para>
    /// </summary>
    [SchemaAttr(0, "b")]
    public BooleanValue Bold
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MdxTuple class.
    /// </summary>
    public MdxTuple():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MdxTuple class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxTuple(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxTuple class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxTuple(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxTuple class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MdxTuple(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "n" == name)
    return new NameIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "c" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "ct" == name)
    return new StringValue();
    
if( 0 == namespaceId && "si" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "fi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "bc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "fc" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "i" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "u" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "st" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "b" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MdxTuple>(deep);
    }

   
}
/// <summary>
/// <para>Set MDX Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ms.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NameIndex &lt;x:n></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NameIndex))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MdxSet : OpenXmlCompositeElement
{
    private const string tagName = "ms";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11302;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ns","c","o" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Set Definition Index.</para>
    /// <para>Represents the following attribute in the schema: ns </para>
    /// </summary>
    [SchemaAttr(0, "ns")]
    public UInt32Value SetDefinitionIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sort By Member Index Count.</para>
    /// <para>Represents the following attribute in the schema: c </para>
    /// </summary>
    [SchemaAttr(0, "c")]
    public UInt32Value MemberIndexCount
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Set Sort Order.</para>
    /// <para>Represents the following attribute in the schema: o </para>
    /// </summary>
    [SchemaAttr(0, "o")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxSetOrderValues> SortingOrder
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxSetOrderValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MdxSet class.
    /// </summary>
    public MdxSet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MdxSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxSet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MdxSet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MdxSet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MdxSet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "n" == name)
    return new NameIndex();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ns" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "c" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "o" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxSetOrderValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MdxSet>(deep);
    }

   
}
/// <summary>
/// <para>Member Property MDX Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:p.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MdxMemberProp : OpenXmlLeafElement
{
    private const string tagName = "p";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11303;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "n","np" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Member Unique Name Index.</para>
    /// <para>Represents the following attribute in the schema: n </para>
    /// </summary>
    [SchemaAttr(0, "n")]
    public UInt32Value NameIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Property Name Index.</para>
    /// <para>Represents the following attribute in the schema: np </para>
    /// </summary>
    [SchemaAttr(0, "np")]
    public UInt32Value PropertyNameIndex
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MdxMemberProp class.
    /// </summary>
    public MdxMemberProp():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "n" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "np" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MdxMemberProp>(deep);
    }

   
}
/// <summary>
/// <para>KPI MDX Metadata.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:k.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MdxKpi : OpenXmlLeafElement
{
    private const string tagName = "k";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11304;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "n","np","p" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Member Unique Name Index.</para>
    /// <para>Represents the following attribute in the schema: n </para>
    /// </summary>
    [SchemaAttr(0, "n")]
    public UInt32Value NameIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> KPI Index.</para>
    /// <para>Represents the following attribute in the schema: np </para>
    /// </summary>
    [SchemaAttr(0, "np")]
    public UInt32Value KpiIndex
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> KPI Property.</para>
    /// <para>Represents the following attribute in the schema: p </para>
    /// </summary>
    [SchemaAttr(0, "p")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxKPIPropertyValues> KpiProperty
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxKPIPropertyValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MdxKpi class.
    /// </summary>
    public MdxKpi():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "n" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "np" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "p" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.MdxKPIPropertyValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MdxKpi>(deep);
    }

   
}
/// <summary>
/// <para>Member Unique Name Index.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:n.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NameIndex : OpenXmlLeafElement
{
    private const string tagName = "n";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11305;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "x","s" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Index Value.</para>
    /// <para>Represents the following attribute in the schema: x </para>
    /// </summary>
    [SchemaAttr(0, "x")]
    public UInt32Value Index
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> String is a Set.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public BooleanValue IsASet
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NameIndex class.
    /// </summary>
    public NameIndex():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "x" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "s" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NameIndex>(deep);
    }

   
}
/// <summary>
/// <para>Table Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:singleXmlCell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>XmlCellProperties &lt;x:xmlCellPr></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(XmlCellProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SingleXmlCell : OpenXmlCompositeElement
{
    private const string tagName = "singleXmlCell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11306;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","r","connectionId" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Connection ID.</para>
    /// <para>Represents the following attribute in the schema: connectionId </para>
    /// </summary>
    [SchemaAttr(0, "connectionId")]
    public UInt32Value ConnectionId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SingleXmlCell class.
    /// </summary>
    public SingleXmlCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SingleXmlCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SingleXmlCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SingleXmlCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SingleXmlCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SingleXmlCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SingleXmlCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "xmlCellPr" == name)
    return new XmlCellProperties();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "xmlCellPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Cell Properties.</para>
    /// <para> Represents the following element tag in the schema: x:xmlCellPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public XmlCellProperties XmlCellProperties
    {
        get 
        {
            return GetElement<XmlCellProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "connectionId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SingleXmlCell>(deep);
    }

   
}
/// <summary>
/// <para>Cell Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:xmlCellPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>XmlProperties &lt;x:xmlPr></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(XmlProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class XmlCellProperties : OpenXmlCompositeElement
{
    private const string tagName = "xmlCellPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11307;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","uniqueName" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Field Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unique Table Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the XmlCellProperties class.
    /// </summary>
    public XmlCellProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the XmlCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlCellProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlCellProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlCellProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlCellProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public XmlCellProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "xmlPr" == name)
    return new XmlProperties();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "xmlPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Column XML Properties.</para>
    /// <para> Represents the following element tag in the schema: x:xmlPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public XmlProperties XmlProperties
    {
        get 
        {
            return GetElement<XmlProperties>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<XmlCellProperties>(deep);
    }

   
}
/// <summary>
/// <para>Column XML Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:xmlPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class XmlProperties : OpenXmlCompositeElement
{
    private const string tagName = "xmlPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11308;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "mapId","xpath","xmlDataType" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XML Map Id.</para>
    /// <para>Represents the following attribute in the schema: mapId </para>
    /// </summary>
    [SchemaAttr(0, "mapId")]
    public UInt32Value MapId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> XPath.</para>
    /// <para>Represents the following attribute in the schema: xpath </para>
    /// </summary>
    [SchemaAttr(0, "xpath")]
    public StringValue XPath
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> XML Data Type.</para>
    /// <para>Represents the following attribute in the schema: xmlDataType </para>
    /// </summary>
    [SchemaAttr(0, "xmlDataType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues> XmlDataType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the XmlProperties class.
    /// </summary>
    public XmlProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the XmlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public XmlProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "mapId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "xpath" == name)
    return new StringValue();
    
if( 0 == namespaceId && "xmlDataType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<XmlProperties>(deep);
    }

   
}
/// <summary>
/// <para>Pattern.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:patternFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ForegroundColor &lt;x:fgColor></description></item>
///<item><description>BackgroundColor &lt;x:bgColor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ForegroundColor))]
    [ChildElementInfo(typeof(BackgroundColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PatternFill : OpenXmlCompositeElement
{
    private const string tagName = "patternFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11309;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "patternType" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pattern Type.</para>
    /// <para>Represents the following attribute in the schema: patternType </para>
    /// </summary>
    [SchemaAttr(0, "patternType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.PatternValues> PatternType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.PatternValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PatternFill class.
    /// </summary>
    public PatternFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PatternFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PatternFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PatternFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PatternFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PatternFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PatternFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "fgColor" == name)
    return new ForegroundColor();
    
if( 22 == namespaceId && "bgColor" == name)
    return new BackgroundColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "fgColor","bgColor" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Foreground Color.</para>
    /// <para> Represents the following element tag in the schema: x:fgColor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ForegroundColor ForegroundColor
    {
        get 
        {
            return GetElement<ForegroundColor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Background Color.</para>
    /// <para> Represents the following element tag in the schema: x:bgColor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public BackgroundColor BackgroundColor
    {
        get 
        {
            return GetElement<BackgroundColor>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "patternType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.PatternValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PatternFill>(deep);
    }

   
}
/// <summary>
/// <para>Gradient.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:gradientFill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GradientStop &lt;x:stop></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GradientStop))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GradientFill : OpenXmlCompositeElement
{
    private const string tagName = "gradientFill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11310;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","degree","left","right","top","bottom" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Gradient Fill Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.GradientValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.GradientValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Linear Gradient Degree.</para>
    /// <para>Represents the following attribute in the schema: degree </para>
    /// </summary>
    [SchemaAttr(0, "degree")]
    public DoubleValue Degree
    {
        get { return (DoubleValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Left Convergence.</para>
    /// <para>Represents the following attribute in the schema: left </para>
    /// </summary>
    [SchemaAttr(0, "left")]
    public DoubleValue Left
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Right Convergence.</para>
    /// <para>Represents the following attribute in the schema: right </para>
    /// </summary>
    [SchemaAttr(0, "right")]
    public DoubleValue Right
    {
        get { return (DoubleValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Top Gradient Convergence.</para>
    /// <para>Represents the following attribute in the schema: top </para>
    /// </summary>
    [SchemaAttr(0, "top")]
    public DoubleValue Top
    {
        get { return (DoubleValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Bottom Convergence.</para>
    /// <para>Represents the following attribute in the schema: bottom </para>
    /// </summary>
    [SchemaAttr(0, "bottom")]
    public DoubleValue Bottom
    {
        get { return (DoubleValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GradientFill class.
    /// </summary>
    public GradientFill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientFill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientFill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientFill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientFill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GradientFill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "stop" == name)
    return new GradientStop();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.GradientValues>();
    
if( 0 == namespaceId && "degree" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "left" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "right" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "top" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "bottom" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GradientFill>(deep);
    }

   
}
/// <summary>
/// <para>Gradient Stop.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:stop.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Color))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GradientStop : OpenXmlCompositeElement
{
    private const string tagName = "stop";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11313;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "position" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Gradient Stop Position.</para>
    /// <para>Represents the following attribute in the schema: position </para>
    /// </summary>
    [SchemaAttr(0, "position")]
    public DoubleValue Position
    {
        get { return (DoubleValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GradientStop class.
    /// </summary>
    public GradientStop():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GradientStop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStop(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStop class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GradientStop(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GradientStop class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GradientStop(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "color" == name)
    return new Color();
    

    return null;
}

        private static readonly string[] eleTagNames = { "color" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: x:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "position" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GradientStop>(deep);
    }

   
}
/// <summary>
/// <para>Number Formats.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:numFmt.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingFormat : OpenXmlLeafElement
{
    private const string tagName = "numFmt";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11314;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "numFmtId","formatCode" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Number Format Id.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Number Format Code.</para>
    /// <para>Represents the following attribute in the schema: formatCode </para>
    /// </summary>
    [SchemaAttr(0, "formatCode")]
    public StringValue FormatCode
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingFormat class.
    /// </summary>
    public NumberingFormat():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "formatCode" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingFormat>(deep);
    }

   
}
/// <summary>
/// <para>Alignment.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:alignment.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Alignment : OpenXmlLeafElement
{
    private const string tagName = "alignment";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11315;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "horizontal","vertical","textRotation","wrapText","indent","relativeIndent","justifyLastLine","shrinkToFit","readingOrder","mergeCell" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Horizontal Alignment.</para>
    /// <para>Represents the following attribute in the schema: horizontal </para>
    /// </summary>
    [SchemaAttr(0, "horizontal")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.HorizontalAlignmentValues> Horizontal
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.HorizontalAlignmentValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Vertical Alignment.</para>
    /// <para>Represents the following attribute in the schema: vertical </para>
    /// </summary>
    [SchemaAttr(0, "vertical")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentValues> Vertical
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Text Rotation.</para>
    /// <para>Represents the following attribute in the schema: textRotation </para>
    /// </summary>
    [SchemaAttr(0, "textRotation")]
    public UInt32Value TextRotation
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Wrap Text.</para>
    /// <para>Represents the following attribute in the schema: wrapText </para>
    /// </summary>
    [SchemaAttr(0, "wrapText")]
    public BooleanValue WrapText
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Indent.</para>
    /// <para>Represents the following attribute in the schema: indent </para>
    /// </summary>
    [SchemaAttr(0, "indent")]
    public UInt32Value Indent
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Relative Indent.</para>
    /// <para>Represents the following attribute in the schema: relativeIndent </para>
    /// </summary>
    [SchemaAttr(0, "relativeIndent")]
    public Int32Value RelativeIndent
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Justify Last Line.</para>
    /// <para>Represents the following attribute in the schema: justifyLastLine </para>
    /// </summary>
    [SchemaAttr(0, "justifyLastLine")]
    public BooleanValue JustifyLastLine
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Shrink To Fit.</para>
    /// <para>Represents the following attribute in the schema: shrinkToFit </para>
    /// </summary>
    [SchemaAttr(0, "shrinkToFit")]
    public BooleanValue ShrinkToFit
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Reading Order.</para>
    /// <para>Represents the following attribute in the schema: readingOrder </para>
    /// </summary>
    [SchemaAttr(0, "readingOrder")]
    public UInt32Value ReadingOrder
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> mergeCell.</para>
    /// <para>Represents the following attribute in the schema: mergeCell </para>
    /// </summary>
    [SchemaAttr(0, "mergeCell")]
    public StringValue MergeCell
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Alignment class.
    /// </summary>
    public Alignment():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "horizontal" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.HorizontalAlignmentValues>();
    
if( 0 == namespaceId && "vertical" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.VerticalAlignmentValues>();
    
if( 0 == namespaceId && "textRotation" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "wrapText" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "indent" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "relativeIndent" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "justifyLastLine" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "shrinkToFit" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "readingOrder" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "mergeCell" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Alignment>(deep);
    }

   
}
/// <summary>
/// <para>Protection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:protection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Protection : OpenXmlLeafElement
{
    private const string tagName = "protection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11316;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "locked","hidden" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Cell Locked.</para>
    /// <para>Represents the following attribute in the schema: locked </para>
    /// </summary>
    [SchemaAttr(0, "locked")]
    public BooleanValue Locked
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Cell.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Protection class.
    /// </summary>
    public Protection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "locked" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Protection>(deep);
    }

   
}
/// <summary>
/// <para>Font Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:font.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Bold &lt;x:b></description></item>
///<item><description>Italic &lt;x:i></description></item>
///<item><description>Strike &lt;x:strike></description></item>
///<item><description>Condense &lt;x:condense></description></item>
///<item><description>Extend &lt;x:extend></description></item>
///<item><description>Outline &lt;x:outline></description></item>
///<item><description>Shadow &lt;x:shadow></description></item>
///<item><description>Underline &lt;x:u></description></item>
///<item><description>VerticalTextAlignment &lt;x:vertAlign></description></item>
///<item><description>FontSize &lt;x:sz></description></item>
///<item><description>Color &lt;x:color></description></item>
///<item><description>FontName &lt;x:name></description></item>
///<item><description>FontFamilyNumbering &lt;x:family></description></item>
///<item><description>FontCharSet &lt;x:charset></description></item>
///<item><description>FontScheme &lt;x:scheme></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Bold))]
    [ChildElementInfo(typeof(Italic))]
    [ChildElementInfo(typeof(Strike))]
    [ChildElementInfo(typeof(Condense))]
    [ChildElementInfo(typeof(Extend))]
    [ChildElementInfo(typeof(Outline))]
    [ChildElementInfo(typeof(Shadow))]
    [ChildElementInfo(typeof(Underline))]
    [ChildElementInfo(typeof(VerticalTextAlignment))]
    [ChildElementInfo(typeof(FontSize))]
    [ChildElementInfo(typeof(Color))]
    [ChildElementInfo(typeof(FontName))]
    [ChildElementInfo(typeof(FontFamilyNumbering))]
    [ChildElementInfo(typeof(FontCharSet))]
    [ChildElementInfo(typeof(FontScheme))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Font : OpenXmlCompositeElement
{
    private const string tagName = "font";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11317;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Font class.
    /// </summary>
    public Font():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Font class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Font(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Font class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Font(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Font class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Font(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "b" == name)
    return new Bold();
    
if( 22 == namespaceId && "i" == name)
    return new Italic();
    
if( 22 == namespaceId && "strike" == name)
    return new Strike();
    
if( 22 == namespaceId && "condense" == name)
    return new Condense();
    
if( 22 == namespaceId && "extend" == name)
    return new Extend();
    
if( 22 == namespaceId && "outline" == name)
    return new Outline();
    
if( 22 == namespaceId && "shadow" == name)
    return new Shadow();
    
if( 22 == namespaceId && "u" == name)
    return new Underline();
    
if( 22 == namespaceId && "vertAlign" == name)
    return new VerticalTextAlignment();
    
if( 22 == namespaceId && "sz" == name)
    return new FontSize();
    
if( 22 == namespaceId && "color" == name)
    return new Color();
    
if( 22 == namespaceId && "name" == name)
    return new FontName();
    
if( 22 == namespaceId && "family" == name)
    return new FontFamilyNumbering();
    
if( 22 == namespaceId && "charset" == name)
    return new FontCharSet();
    
if( 22 == namespaceId && "scheme" == name)
    return new FontScheme();
    

    return null;
}

        private static readonly string[] eleTagNames = { "b","i","strike","condense","extend","outline","shadow","u","vertAlign","sz","color","name","family","charset","scheme" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Bold.</para>
    /// <para> Represents the following element tag in the schema: x:b </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Bold Bold
    {
        get 
        {
            return GetElement<Bold>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Italic.</para>
    /// <para> Represents the following element tag in the schema: x:i </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Italic Italic
    {
        get 
        {
            return GetElement<Italic>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Strike Through.</para>
    /// <para> Represents the following element tag in the schema: x:strike </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Strike Strike
    {
        get 
        {
            return GetElement<Strike>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Condense.</para>
    /// <para> Represents the following element tag in the schema: x:condense </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Condense Condense
    {
        get 
        {
            return GetElement<Condense>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Extend.</para>
    /// <para> Represents the following element tag in the schema: x:extend </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Extend Extend
    {
        get 
        {
            return GetElement<Extend>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Outline.</para>
    /// <para> Represents the following element tag in the schema: x:outline </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Outline Outline
    {
        get 
        {
            return GetElement<Outline>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Shadow.</para>
    /// <para> Represents the following element tag in the schema: x:shadow </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Shadow Shadow
    {
        get 
        {
            return GetElement<Shadow>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Underline.</para>
    /// <para> Represents the following element tag in the schema: x:u </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Underline Underline
    {
        get 
        {
            return GetElement<Underline>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Text Vertical Alignment.</para>
    /// <para> Represents the following element tag in the schema: x:vertAlign </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public VerticalTextAlignment VerticalTextAlignment
    {
        get 
        {
            return GetElement<VerticalTextAlignment>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }
    /// <summary>
    /// <para> Font Size.</para>
    /// <para> Represents the following element tag in the schema: x:sz </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FontSize FontSize
    {
        get 
        {
            return GetElement<FontSize>(9);
        }
        set
        {
            SetElement(9, value);
        }
    }
    /// <summary>
    /// <para> Text Color.</para>
    /// <para> Represents the following element tag in the schema: x:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(10);
        }
        set
        {
            SetElement(10, value);
        }
    }
    /// <summary>
    /// <para> Font Name.</para>
    /// <para> Represents the following element tag in the schema: x:name </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FontName FontName
    {
        get 
        {
            return GetElement<FontName>(11);
        }
        set
        {
            SetElement(11, value);
        }
    }
    /// <summary>
    /// <para> Font Family.</para>
    /// <para> Represents the following element tag in the schema: x:family </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FontFamilyNumbering FontFamilyNumbering
    {
        get 
        {
            return GetElement<FontFamilyNumbering>(12);
        }
        set
        {
            SetElement(12, value);
        }
    }
    /// <summary>
    /// <para> Character Set.</para>
    /// <para> Represents the following element tag in the schema: x:charset </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FontCharSet FontCharSet
    {
        get 
        {
            return GetElement<FontCharSet>(13);
        }
        set
        {
            SetElement(13, value);
        }
    }
    /// <summary>
    /// <para> Scheme.</para>
    /// <para> Represents the following element tag in the schema: x:scheme </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FontScheme FontScheme
    {
        get 
        {
            return GetElement<FontScheme>(14);
        }
        set
        {
            SetElement(14, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Font>(deep);
    }

   
}
/// <summary>
/// <para>Fill.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fill.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PatternFill &lt;x:patternFill></description></item>
///<item><description>GradientFill &lt;x:gradientFill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PatternFill))]
    [ChildElementInfo(typeof(GradientFill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fill : OpenXmlCompositeElement
{
    private const string tagName = "fill";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11318;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Fill class.
    /// </summary>
    public Fill():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Fill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fill(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fill class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fill(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fill class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fill(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "patternFill" == name)
    return new PatternFill();
    
if( 22 == namespaceId && "gradientFill" == name)
    return new GradientFill();
    

    return null;
}

        private static readonly string[] eleTagNames = { "patternFill","gradientFill" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> Pattern.</para>
    /// <para> Represents the following element tag in the schema: x:patternFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PatternFill PatternFill
    {
        get 
        {
            return GetElement<PatternFill>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Gradient.</para>
    /// <para> Represents the following element tag in the schema: x:gradientFill </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public GradientFill GradientFill
    {
        get 
        {
            return GetElement<GradientFill>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fill>(deep);
    }

   
}
/// <summary>
/// <para>Border Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:border.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StartBorder &lt;x:start></description></item>
///<item><description>EndBorder &lt;x:end></description></item>
///<item><description>LeftBorder &lt;x:left></description></item>
///<item><description>RightBorder &lt;x:right></description></item>
///<item><description>TopBorder &lt;x:top></description></item>
///<item><description>BottomBorder &lt;x:bottom></description></item>
///<item><description>DiagonalBorder &lt;x:diagonal></description></item>
///<item><description>VerticalBorder &lt;x:vertical></description></item>
///<item><description>HorizontalBorder &lt;x:horizontal></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StartBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(EndBorder),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(LeftBorder))]
    [ChildElementInfo(typeof(RightBorder))]
    [ChildElementInfo(typeof(TopBorder))]
    [ChildElementInfo(typeof(BottomBorder))]
    [ChildElementInfo(typeof(DiagonalBorder))]
    [ChildElementInfo(typeof(VerticalBorder))]
    [ChildElementInfo(typeof(HorizontalBorder))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Border : OpenXmlCompositeElement
{
    private const string tagName = "border";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11319;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "diagonalUp","diagonalDown","outline" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Diagonal Up.</para>
    /// <para>Represents the following attribute in the schema: diagonalUp </para>
    /// </summary>
    [SchemaAttr(0, "diagonalUp")]
    public BooleanValue DiagonalUp
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Diagonal Down.</para>
    /// <para>Represents the following attribute in the schema: diagonalDown </para>
    /// </summary>
    [SchemaAttr(0, "diagonalDown")]
    public BooleanValue DiagonalDown
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Outline.</para>
    /// <para>Represents the following attribute in the schema: outline </para>
    /// </summary>
    [SchemaAttr(0, "outline")]
    public BooleanValue Outline
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Border class.
    /// </summary>
    public Border():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Border class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Border(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Border class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Border(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Border class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Border(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "start" == name)
    return new StartBorder();
    
if( 22 == namespaceId && "end" == name)
    return new EndBorder();
    
if( 22 == namespaceId && "left" == name)
    return new LeftBorder();
    
if( 22 == namespaceId && "right" == name)
    return new RightBorder();
    
if( 22 == namespaceId && "top" == name)
    return new TopBorder();
    
if( 22 == namespaceId && "bottom" == name)
    return new BottomBorder();
    
if( 22 == namespaceId && "diagonal" == name)
    return new DiagonalBorder();
    
if( 22 == namespaceId && "vertical" == name)
    return new VerticalBorder();
    
if( 22 == namespaceId && "horizontal" == name)
    return new HorizontalBorder();
    

    return null;
}

        private static readonly string[] eleTagNames = { "start","end","left","right","top","bottom","diagonal","vertical","horizontal" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> StartBorder.</para>
    /// <para> Represents the following element tag in the schema: x:start </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public StartBorder StartBorder
    {
        get 
        {
            return GetElement<StartBorder>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> EndBorder.</para>
    /// <para> Represents the following element tag in the schema: x:end </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public EndBorder EndBorder
    {
        get 
        {
            return GetElement<EndBorder>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Left Border.</para>
    /// <para> Represents the following element tag in the schema: x:left </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public LeftBorder LeftBorder
    {
        get 
        {
            return GetElement<LeftBorder>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Right Border.</para>
    /// <para> Represents the following element tag in the schema: x:right </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RightBorder RightBorder
    {
        get 
        {
            return GetElement<RightBorder>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Top Border.</para>
    /// <para> Represents the following element tag in the schema: x:top </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TopBorder TopBorder
    {
        get 
        {
            return GetElement<TopBorder>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }
    /// <summary>
    /// <para> Bottom Border.</para>
    /// <para> Represents the following element tag in the schema: x:bottom </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public BottomBorder BottomBorder
    {
        get 
        {
            return GetElement<BottomBorder>(5);
        }
        set
        {
            SetElement(5, value);
        }
    }
    /// <summary>
    /// <para> Diagonal.</para>
    /// <para> Represents the following element tag in the schema: x:diagonal </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DiagonalBorder DiagonalBorder
    {
        get 
        {
            return GetElement<DiagonalBorder>(6);
        }
        set
        {
            SetElement(6, value);
        }
    }
    /// <summary>
    /// <para> Vertical Inner Border.</para>
    /// <para> Represents the following element tag in the schema: x:vertical </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public VerticalBorder VerticalBorder
    {
        get 
        {
            return GetElement<VerticalBorder>(7);
        }
        set
        {
            SetElement(7, value);
        }
    }
    /// <summary>
    /// <para> Horizontal Inner Borders.</para>
    /// <para> Represents the following element tag in the schema: x:horizontal </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public HorizontalBorder HorizontalBorder
    {
        get 
        {
            return GetElement<HorizontalBorder>(8);
        }
        set
        {
            SetElement(8, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "diagonalUp" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "diagonalDown" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outline" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Border>(deep);
    }

   
}
/// <summary>
/// <para>Color Indexes.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:indexedColors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RgbColor &lt;x:rgbColor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RgbColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IndexedColors : OpenXmlCompositeElement
{
    private const string tagName = "indexedColors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11320;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the IndexedColors class.
    /// </summary>
    public IndexedColors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the IndexedColors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IndexedColors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the IndexedColors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IndexedColors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the IndexedColors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public IndexedColors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rgbColor" == name)
    return new RgbColor();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IndexedColors>(deep);
    }

   
}
/// <summary>
/// <para>MRU Colors.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mruColors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Color))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MruColors : OpenXmlCompositeElement
{
    private const string tagName = "mruColors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11321;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the MruColors class.
    /// </summary>
    public MruColors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MruColors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MruColors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MruColors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MruColors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MruColors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MruColors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "color" == name)
    return new Color();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MruColors>(deep);
    }

   
}
/// <summary>
/// <para>Table Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyleElement &lt;x:tableStyleElement></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyleElement))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyle : OpenXmlCompositeElement
{
    private const string tagName = "tableStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11322;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","pivot","table","count" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Style Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Pivot Style.</para>
    /// <para>Represents the following attribute in the schema: pivot </para>
    /// </summary>
    [SchemaAttr(0, "pivot")]
    public BooleanValue Pivot
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Table.</para>
    /// <para>Represents the following attribute in the schema: table </para>
    /// </summary>
    [SchemaAttr(0, "table")]
    public BooleanValue Table
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Table Style Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyle class.
    /// </summary>
    public TableStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tableStyleElement" == name)
    return new TableStyleElement();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "pivot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "table" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyle>(deep);
    }

   
}
/// <summary>
/// <para>RGB Color.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rgbColor.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RgbColor : OpenXmlLeafElement
{
    private const string tagName = "rgbColor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11323;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rgb" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Alpha Red Green Blue.</para>
    /// <para>Represents the following attribute in the schema: rgb </para>
    /// </summary>
    [SchemaAttr(0, "rgb")]
    public HexBinaryValue Rgb
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RgbColor class.
    /// </summary>
    public RgbColor():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rgb" == name)
    return new HexBinaryValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RgbColor>(deep);
    }

   
}
/// <summary>
/// <para>Cell Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellStyle.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellStyle : OpenXmlCompositeElement
{
    private const string tagName = "cellStyle";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11324;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","xfId","builtinId","iLevel","hidden","customBuiltin" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> User Defined Cell Style.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Format Id.</para>
    /// <para>Represents the following attribute in the schema: xfId </para>
    /// </summary>
    [SchemaAttr(0, "xfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Built-In Style Id.</para>
    /// <para>Represents the following attribute in the schema: builtinId </para>
    /// </summary>
    [SchemaAttr(0, "builtinId")]
    public UInt32Value BuiltinId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Outline Style.</para>
    /// <para>Represents the following attribute in the schema: iLevel </para>
    /// </summary>
    [SchemaAttr(0, "iLevel")]
    public UInt32Value OutlineLevel
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Style.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Custom Built In.</para>
    /// <para>Represents the following attribute in the schema: customBuiltin </para>
    /// </summary>
    [SchemaAttr(0, "customBuiltin")]
    public BooleanValue CustomBuiltin
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellStyle class.
    /// </summary>
    public CellStyle():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyle(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyle class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyle(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyle class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellStyle(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "xfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "builtinId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iLevel" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "customBuiltin" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellStyle>(deep);
    }

   
}
/// <summary>
/// <para>Formatting Elements.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:xf.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Alignment &lt;x:alignment></description></item>
///<item><description>Protection &lt;x:protection></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Alignment))]
    [ChildElementInfo(typeof(Protection))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellFormat : OpenXmlCompositeElement
{
    private const string tagName = "xf";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11325;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "numFmtId","fontId","fillId","borderId","xfId","quotePrefix","pivotButton","applyNumberFormat","applyFont","applyFill","applyBorder","applyAlignment","applyProtection" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Number Format Id.</para>
    /// <para>Represents the following attribute in the schema: numFmtId </para>
    /// </summary>
    [SchemaAttr(0, "numFmtId")]
    public UInt32Value NumberFormatId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Font Id.</para>
    /// <para>Represents the following attribute in the schema: fontId </para>
    /// </summary>
    [SchemaAttr(0, "fontId")]
    public UInt32Value FontId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Fill Id.</para>
    /// <para>Represents the following attribute in the schema: fillId </para>
    /// </summary>
    [SchemaAttr(0, "fillId")]
    public UInt32Value FillId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Border Id.</para>
    /// <para>Represents the following attribute in the schema: borderId </para>
    /// </summary>
    [SchemaAttr(0, "borderId")]
    public UInt32Value BorderId
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Format Id.</para>
    /// <para>Represents the following attribute in the schema: xfId </para>
    /// </summary>
    [SchemaAttr(0, "xfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Quote Prefix.</para>
    /// <para>Represents the following attribute in the schema: quotePrefix </para>
    /// </summary>
    [SchemaAttr(0, "quotePrefix")]
    public BooleanValue QuotePrefix
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Pivot Button.</para>
    /// <para>Represents the following attribute in the schema: pivotButton </para>
    /// </summary>
    [SchemaAttr(0, "pivotButton")]
    public BooleanValue PivotButton
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Apply Number Format.</para>
    /// <para>Represents the following attribute in the schema: applyNumberFormat </para>
    /// </summary>
    [SchemaAttr(0, "applyNumberFormat")]
    public BooleanValue ApplyNumberFormat
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Apply Font.</para>
    /// <para>Represents the following attribute in the schema: applyFont </para>
    /// </summary>
    [SchemaAttr(0, "applyFont")]
    public BooleanValue ApplyFont
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Apply Fill.</para>
    /// <para>Represents the following attribute in the schema: applyFill </para>
    /// </summary>
    [SchemaAttr(0, "applyFill")]
    public BooleanValue ApplyFill
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Apply Border.</para>
    /// <para>Represents the following attribute in the schema: applyBorder </para>
    /// </summary>
    [SchemaAttr(0, "applyBorder")]
    public BooleanValue ApplyBorder
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Apply Alignment.</para>
    /// <para>Represents the following attribute in the schema: applyAlignment </para>
    /// </summary>
    [SchemaAttr(0, "applyAlignment")]
    public BooleanValue ApplyAlignment
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Apply Protection.</para>
    /// <para>Represents the following attribute in the schema: applyProtection </para>
    /// </summary>
    [SchemaAttr(0, "applyProtection")]
    public BooleanValue ApplyProtection
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellFormat class.
    /// </summary>
    public CellFormat():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellFormat(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellFormat class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellFormat(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellFormat class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellFormat(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "alignment" == name)
    return new Alignment();
    
if( 22 == namespaceId && "protection" == name)
    return new Protection();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "alignment","protection","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Alignment.</para>
    /// <para> Represents the following element tag in the schema: x:alignment </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Alignment Alignment
    {
        get 
        {
            return GetElement<Alignment>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Protection.</para>
    /// <para> Represents the following element tag in the schema: x:protection </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Protection Protection
    {
        get 
        {
            return GetElement<Protection>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "numFmtId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "fontId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "fillId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "borderId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "xfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "quotePrefix" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pivotButton" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyNumberFormat" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyFont" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyFill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyBorder" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyAlignment" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "applyProtection" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellFormat>(deep);
    }

   
}
/// <summary>
/// <para>Font Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:name.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontName : OpenXmlLeafElement
{
    private const string tagName = "name";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11326;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> String Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontName class.
    /// </summary>
    public FontName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontName>(deep);
    }

   
}
/// <summary>
/// <para>Font Family.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:family.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontFamilyNumbering : OpenXmlLeafElement
{
    private const string tagName = "family";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11327;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontFamilyNumbering class.
    /// </summary>
    public FontFamilyNumbering():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontFamilyNumbering>(deep);
    }

   
}
/// <summary>
/// <para>Character Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:charset.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FontCharSet : OpenXmlLeafElement
{
    private const string tagName = "charset";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11328;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public Int32Value Val
    {
        get { return (Int32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FontCharSet class.
    /// </summary>
    public FontCharSet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new Int32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FontCharSet>(deep);
    }

   
}
/// <summary>
/// <para>Table Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableStyleElement.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleElement : OpenXmlLeafElement
{
    private const string tagName = "tableStyleElement";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11329;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","size","dxfId" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Style Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableStyleValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableStyleValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Band Size.</para>
    /// <para>Represents the following attribute in the schema: size </para>
    /// </summary>
    [SchemaAttr(0, "size")]
    public UInt32Value Size
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Formatting Id.</para>
    /// <para>Represents the following attribute in the schema: dxfId </para>
    /// </summary>
    [SchemaAttr(0, "dxfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleElement class.
    /// </summary>
    public TableStyleElement():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TableStyleValues>();
    
if( 0 == namespaceId && "size" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "dxfId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleElement>(deep);
    }

   
}
/// <summary>
/// <para>Supporting Workbook Sheet Names.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetNames.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetName &lt;x:sheetName></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetName))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetNames : OpenXmlCompositeElement
{
    private const string tagName = "sheetNames";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11330;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SheetNames class.
    /// </summary>
    public SheetNames():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetNames(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetNames(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetNames class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetNames(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetName" == name)
    return new SheetName();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetNames>(deep);
    }

   
}
/// <summary>
/// <para>Named Links.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:definedNames.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalDefinedName &lt;x:definedName></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalDefinedName))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalDefinedNames : OpenXmlCompositeElement
{
    private const string tagName = "definedNames";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11331;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExternalDefinedNames class.
    /// </summary>
    public ExternalDefinedNames():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalDefinedNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalDefinedNames(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalDefinedNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalDefinedNames(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalDefinedNames class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalDefinedNames(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "definedName" == name)
    return new ExternalDefinedName();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalDefinedNames>(deep);
    }

   
}
/// <summary>
/// <para>Cached Worksheet Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetDataSet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalSheetData &lt;x:sheetData></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalSheetData))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetDataSet : OpenXmlCompositeElement
{
    private const string tagName = "sheetDataSet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11332;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SheetDataSet class.
    /// </summary>
    public SheetDataSet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetDataSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetDataSet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetDataSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetDataSet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetDataSet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetDataSet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetData" == name)
    return new ExternalSheetData();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetDataSet>(deep);
    }

   
}
/// <summary>
/// <para>Defined Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:definedName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalDefinedName : OpenXmlLeafElement
{
    private const string tagName = "definedName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11333;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","refersTo","sheetId" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Defined Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Refers To.</para>
    /// <para>Represents the following attribute in the schema: refersTo </para>
    /// </summary>
    [SchemaAttr(0, "refersTo")]
    public StringValue RefersTo
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalDefinedName class.
    /// </summary>
    public ExternalDefinedName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "refersTo" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalDefinedName>(deep);
    }

   
}
/// <summary>
/// <para>External Sheet Data Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalRow &lt;x:row></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalRow))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalSheetData : OpenXmlCompositeElement
{
    private const string tagName = "sheetData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11334;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "sheetId","refreshError" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Last Refresh Resulted in Error.</para>
    /// <para>Represents the following attribute in the schema: refreshError </para>
    /// </summary>
    [SchemaAttr(0, "refreshError")]
    public BooleanValue RefreshError
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalSheetData class.
    /// </summary>
    public ExternalSheetData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalSheetData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalSheetData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalSheetData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalSheetData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalSheetData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalSheetData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "row" == name)
    return new ExternalRow();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "refreshError" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalSheetData>(deep);
    }

   
}
/// <summary>
/// <para>Row.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:row.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalCell &lt;x:cell></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalCell))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalRow : OpenXmlCompositeElement
{
    private const string tagName = "row";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11335;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Row.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public UInt32Value RowIndex
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalRow class.
    /// </summary>
    public ExternalRow():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalRow(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalRow class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalRow(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalRow class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalRow(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cell" == name)
    return new ExternalCell();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalRow>(deep);
    }

   
}
/// <summary>
/// <para>External Cell Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cell.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Xstring &lt;x:v></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Xstring))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalCell : OpenXmlCompositeElement
{
    private const string tagName = "cell";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11336;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","t","vm" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues> DataType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Value Metadata.</para>
    /// <para>Represents the following attribute in the schema: vm </para>
    /// </summary>
    [SchemaAttr(0, "vm")]
    public UInt32Value ValueMetaIndex
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalCell class.
    /// </summary>
    public ExternalCell():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalCell(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalCell class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalCell(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalCell class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalCell(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "v" == name)
    return new Xstring();
    

    return null;
}

        private static readonly string[] eleTagNames = { "v" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Value.</para>
    /// <para> Represents the following element tag in the schema: x:v </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Xstring Xstring
    {
        get 
        {
            return GetElement<Xstring>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CellValues>();
    
if( 0 == namespaceId && "vm" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalCell>(deep);
    }

   
}
/// <summary>
/// <para>DDE Items Collection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ddeItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DdeItem &lt;x:ddeItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DdeItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DdeItems : OpenXmlCompositeElement
{
    private const string tagName = "ddeItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11337;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DdeItems class.
    /// </summary>
    public DdeItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DdeItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DdeItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ddeItem" == name)
    return new DdeItem();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DdeItems>(deep);
    }

   
}
/// <summary>
/// <para>DDE Item definition.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ddeItem.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Values &lt;x:values></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Values))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DdeItem : OpenXmlCompositeElement
{
    private const string tagName = "ddeItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11338;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","ole","advise","preferPic" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> DDE Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> OLE.</para>
    /// <para>Represents the following attribute in the schema: ole </para>
    /// </summary>
    [SchemaAttr(0, "ole")]
    public BooleanValue UseOle
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Advise.</para>
    /// <para>Represents the following attribute in the schema: advise </para>
    /// </summary>
    [SchemaAttr(0, "advise")]
    public BooleanValue Advise
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Data is an Image.</para>
    /// <para>Represents the following attribute in the schema: preferPic </para>
    /// </summary>
    [SchemaAttr(0, "preferPic")]
    public BooleanValue PreferPicture
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DdeItem class.
    /// </summary>
    public DdeItem():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DdeItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeItem(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeItem class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeItem(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeItem class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DdeItem(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "values" == name)
    return new Values();
    

    return null;
}

        private static readonly string[] eleTagNames = { "values" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> DDE Name Values.</para>
    /// <para> Represents the following element tag in the schema: x:values </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Values Values
    {
        get 
        {
            return GetElement<Values>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "ole" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "advise" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "preferPic" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DdeItem>(deep);
    }

   
}
/// <summary>
/// <para>DDE Name Values.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:values.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Value &lt;x:value></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Value))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Values : OpenXmlCompositeElement
{
    private const string tagName = "values";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11339;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "rows","cols" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Rows.</para>
    /// <para>Represents the following attribute in the schema: rows </para>
    /// </summary>
    [SchemaAttr(0, "rows")]
    public UInt32Value Rows
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Columns.</para>
    /// <para>Represents the following attribute in the schema: cols </para>
    /// </summary>
    [SchemaAttr(0, "cols")]
    public UInt32Value Columns
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Values class.
    /// </summary>
    public Values():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Values class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Values(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Values class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Values(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Values class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Values(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "value" == name)
    return new Value();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "rows" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cols" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Values>(deep);
    }

   
}
/// <summary>
/// <para>Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:value.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DdeLinkValue &lt;x:val></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DdeLinkValue))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Value : OpenXmlCompositeElement
{
    private const string tagName = "value";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11340;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "t" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> DDE Value Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DdeValues> ValueType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DdeValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Value class.
    /// </summary>
    public Value():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Value class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Value(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Value class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Value(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Value class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Value(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "val" == name)
    return new DdeLinkValue();
    

    return null;
}

        private static readonly string[] eleTagNames = { "val" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> DDE Link Value.</para>
    /// <para> Represents the following element tag in the schema: x:val </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DdeLinkValue DdeLinkValue
    {
        get 
        {
            return GetElement<DdeLinkValue>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DdeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Value>(deep);
    }

   
}
/// <summary>
/// <para>OLE Link Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OleItem &lt;x:oleItem></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.OleItem &lt;x14:oleItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OleItem))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.OleItem),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleItems : OpenXmlCompositeElement
{
    private const string tagName = "oleItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11341;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the OleItems class.
    /// </summary>
    public OleItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OleItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OleItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OleItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OleItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "oleItem" == name)
    return new OleItem();
    
if( 53 == namespaceId && "oleItem" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.OleItem();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleItems>(deep);
    }

   
}
/// <summary>
/// <para>External Workbook.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:externalBook.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetNames &lt;x:sheetNames></description></item>
///<item><description>ExternalDefinedNames &lt;x:definedNames></description></item>
///<item><description>SheetDataSet &lt;x:sheetDataSet></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetNames))]
    [ChildElementInfo(typeof(ExternalDefinedNames))]
    [ChildElementInfo(typeof(SheetDataSet))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalBook : OpenXmlCompositeElement
{
    private const string tagName = "externalBook";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11342;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship to supporting book file path.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalBook class.
    /// </summary>
    public ExternalBook():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalBook class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalBook(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalBook class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalBook(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalBook class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalBook(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetNames" == name)
    return new SheetNames();
    
if( 22 == namespaceId && "definedNames" == name)
    return new ExternalDefinedNames();
    
if( 22 == namespaceId && "sheetDataSet" == name)
    return new SheetDataSet();
    

    return null;
}

        private static readonly string[] eleTagNames = { "sheetNames","definedNames","sheetDataSet" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Supporting Workbook Sheet Names.</para>
    /// <para> Represents the following element tag in the schema: x:sheetNames </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetNames SheetNames
    {
        get 
        {
            return GetElement<SheetNames>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Named Links.</para>
    /// <para> Represents the following element tag in the schema: x:definedNames </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExternalDefinedNames ExternalDefinedNames
    {
        get 
        {
            return GetElement<ExternalDefinedNames>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Cached Worksheet Data.</para>
    /// <para> Represents the following element tag in the schema: x:sheetDataSet </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SheetDataSet SheetDataSet
    {
        get 
        {
            return GetElement<SheetDataSet>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalBook>(deep);
    }

   
}
/// <summary>
/// <para>DDE Connection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ddeLink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DdeItems &lt;x:ddeItems></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DdeItems))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DdeLink : OpenXmlCompositeElement
{
    private const string tagName = "ddeLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11343;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ddeService","ddeTopic" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Service name.</para>
    /// <para>Represents the following attribute in the schema: ddeService </para>
    /// </summary>
    [SchemaAttr(0, "ddeService")]
    public StringValue DdeService
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Topic for DDE server.</para>
    /// <para>Represents the following attribute in the schema: ddeTopic </para>
    /// </summary>
    [SchemaAttr(0, "ddeTopic")]
    public StringValue DdeTopic
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DdeLink class.
    /// </summary>
    public DdeLink():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DdeLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeLink(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DdeLink(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DdeLink class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DdeLink(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ddeItems" == name)
    return new DdeItems();
    

    return null;
}

        private static readonly string[] eleTagNames = { "ddeItems" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> DDE Items Collection.</para>
    /// <para> Represents the following element tag in the schema: x:ddeItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DdeItems DdeItems
    {
        get 
        {
            return GetElement<DdeItems>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ddeService" == name)
    return new StringValue();
    
if( 0 == namespaceId && "ddeTopic" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DdeLink>(deep);
    }

   
}
/// <summary>
/// <para>OLE Link.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleLink.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OleItems &lt;x:oleItems></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OleItems))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleLink : OpenXmlCompositeElement
{
    private const string tagName = "oleLink";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11344;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","progId" };
    private static byte[] attributeNamespaceIds = { 19,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLE Link Relationship.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> OLE Link ProgID.</para>
    /// <para>Represents the following attribute in the schema: progId </para>
    /// </summary>
    [SchemaAttr(0, "progId")]
    public StringValue ProgId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OleLink class.
    /// </summary>
    public OleLink():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OleLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleLink(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OleLink class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleLink(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OleLink class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OleLink(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "oleItems" == name)
    return new OleItems();
    

    return null;
}

        private static readonly string[] eleTagNames = { "oleItems" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> OLE Link Items.</para>
    /// <para> Represents the following element tag in the schema: x:oleItems </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OleItems OleItems
    {
        get 
        {
            return GetElement<OleItems>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "progId" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleLink>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetName : OpenXmlLeafElement
{
    private const string tagName = "sheetName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11345;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Name Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetName class.
    /// </summary>
    public SheetName():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetName>(deep);
    }

   
}
/// <summary>
/// <para>Value.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:v.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Xstring : OpenXmlLeafTextElement
{
    private const string tagName = "v";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11346;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Xstring class.
    /// </summary>
    public Xstring():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the Xstring class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public Xstring(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    
 
    
    
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Xstring>(deep);
    }

   
}
/// <summary>
/// <para>Table Column.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableColumn.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculatedColumnFormula &lt;x:calculatedColumnFormula></description></item>
///<item><description>TotalsRowFormula &lt;x:totalsRowFormula></description></item>
///<item><description>XmlColumnProperties &lt;x:xmlColumnPr></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculatedColumnFormula))]
    [ChildElementInfo(typeof(TotalsRowFormula))]
    [ChildElementInfo(typeof(XmlColumnProperties))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableColumn : OpenXmlCompositeElement
{
    private const string tagName = "tableColumn";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11348;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","uniqueName","name","totalsRowFunction","totalsRowLabel","queryTableFieldId","headerRowDxfId","dataDxfId","totalsRowDxfId","headerRowCellStyle","dataCellStyle","totalsRowCellStyle" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Field Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Unique Name.</para>
    /// <para>Represents the following attribute in the schema: uniqueName </para>
    /// </summary>
    [SchemaAttr(0, "uniqueName")]
    public StringValue UniqueName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Column name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Function.</para>
    /// <para>Represents the following attribute in the schema: totalsRowFunction </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowFunction")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFunctionValues> TotalsRowFunction
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFunctionValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Label.</para>
    /// <para>Represents the following attribute in the schema: totalsRowLabel </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowLabel")]
    public StringValue TotalsRowLabel
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Query Table Field Id.</para>
    /// <para>Represents the following attribute in the schema: queryTableFieldId </para>
    /// </summary>
    [SchemaAttr(0, "queryTableFieldId")]
    public UInt32Value QueryTableFieldId
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Cell Format Id.</para>
    /// <para>Represents the following attribute in the schema: headerRowDxfId </para>
    /// </summary>
    [SchemaAttr(0, "headerRowDxfId")]
    public UInt32Value HeaderRowDifferentialFormattingId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Data and Insert Row Format Id.</para>
    /// <para>Represents the following attribute in the schema: dataDxfId </para>
    /// </summary>
    [SchemaAttr(0, "dataDxfId")]
    public UInt32Value DataFormatId
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Format Id.</para>
    /// <para>Represents the following attribute in the schema: totalsRowDxfId </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowDxfId")]
    public UInt32Value TotalsRowDifferentialFormattingId
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Header Row Cell Style.</para>
    /// <para>Represents the following attribute in the schema: headerRowCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "headerRowCellStyle")]
    public StringValue HeaderRowCellStyle
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Data Area Style Name.</para>
    /// <para>Represents the following attribute in the schema: dataCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "dataCellStyle")]
    public StringValue DataCellStyle
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Totals Row Style Name.</para>
    /// <para>Represents the following attribute in the schema: totalsRowCellStyle </para>
    /// </summary>
    [SchemaAttr(0, "totalsRowCellStyle")]
    public StringValue TotalsRowCellStyle
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableColumn class.
    /// </summary>
    public TableColumn():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableColumn(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableColumn class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableColumn(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableColumn class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableColumn(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "calculatedColumnFormula" == name)
    return new CalculatedColumnFormula();
    
if( 22 == namespaceId && "totalsRowFormula" == name)
    return new TotalsRowFormula();
    
if( 22 == namespaceId && "xmlColumnPr" == name)
    return new XmlColumnProperties();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "calculatedColumnFormula","totalsRowFormula","xmlColumnPr","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Calculated Column Formula.</para>
    /// <para> Represents the following element tag in the schema: x:calculatedColumnFormula </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CalculatedColumnFormula CalculatedColumnFormula
    {
        get 
        {
            return GetElement<CalculatedColumnFormula>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Totals Row Formula.</para>
    /// <para> Represents the following element tag in the schema: x:totalsRowFormula </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TotalsRowFormula TotalsRowFormula
    {
        get 
        {
            return GetElement<TotalsRowFormula>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> XML Column Properties.</para>
    /// <para> Represents the following element tag in the schema: x:xmlColumnPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public XmlColumnProperties XmlColumnProperties
    {
        get 
        {
            return GetElement<XmlColumnProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "uniqueName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "totalsRowFunction" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TotalsRowFunctionValues>();
    
if( 0 == namespaceId && "totalsRowLabel" == name)
    return new StringValue();
    
if( 0 == namespaceId && "queryTableFieldId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "headerRowDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "dataDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "totalsRowDxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "headerRowCellStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dataCellStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "totalsRowCellStyle" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableColumn>(deep);
    }

   
}
/// <summary>
/// <para>Calculated Column Formula.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calculatedColumnFormula.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedColumnFormula : TableFormulaType
{
    private const string tagName = "calculatedColumnFormula";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11349;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedColumnFormula class.
    /// </summary>
    public CalculatedColumnFormula():base(){}
    
           /// <summary>
    /// Initializes a new instance of the CalculatedColumnFormula class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public CalculatedColumnFormula(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedColumnFormula>(deep);
    }

}
/// <summary>
/// <para>Totals Row Formula.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:totalsRowFormula.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TotalsRowFormula : TableFormulaType
{
    private const string tagName = "totalsRowFormula";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11350;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TotalsRowFormula class.
    /// </summary>
    public TotalsRowFormula():base(){}
    
           /// <summary>
    /// Initializes a new instance of the TotalsRowFormula class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public TotalsRowFormula(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TotalsRowFormula>(deep);
    }

}
/// <summary>
/// Defines the TableFormulaType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class TableFormulaType : OpenXmlLeafTextElement
{
    private static string[] attributeTagNames = { "array","space" };
    private static byte[] attributeNamespaceIds = { 0,1 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Array.</para>
    /// <para>Represents the following attribute in the schema: array </para>
    /// </summary>
    [SchemaAttr(0, "array")]
    public BooleanValue Array
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> space.</para>
    /// <para>Represents the following attribute in the schema: xml:space </para>
    /// </summary>
///<remark> xmlns:xml=http://www.w3.org/XML/1998/namespace
///</remark>
    [SchemaAttr(1, "space")]
    public EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues> Space
    {
        get { return (EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "array" == name)
    return new BooleanValue();
    
if( 1 == namespaceId && "space" == name)
    return new EnumValue<DocumentFormat.OpenXml.SpaceProcessingModeValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the TableFormulaType class.
    /// </summary>
    protected TableFormulaType(){}
    
    
           /// <summary>
    /// Initializes a new instance of the TableFormulaType class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    protected TableFormulaType(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    

}
/// <summary>
/// <para>XML Column Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:xmlColumnPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class XmlColumnProperties : OpenXmlCompositeElement
{
    private const string tagName = "xmlColumnPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11351;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "mapId","xpath","denormalized","xmlDataType" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XML Map Id.</para>
    /// <para>Represents the following attribute in the schema: mapId </para>
    /// </summary>
    [SchemaAttr(0, "mapId")]
    public UInt32Value MapId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> XPath.</para>
    /// <para>Represents the following attribute in the schema: xpath </para>
    /// </summary>
    [SchemaAttr(0, "xpath")]
    public StringValue XPath
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Denormalized.</para>
    /// <para>Represents the following attribute in the schema: denormalized </para>
    /// </summary>
    [SchemaAttr(0, "denormalized")]
    public BooleanValue Denormalized
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> XML Data Type.</para>
    /// <para>Represents the following attribute in the schema: xmlDataType </para>
    /// </summary>
    [SchemaAttr(0, "xmlDataType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues> XmlDataType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the XmlColumnProperties class.
    /// </summary>
    public XmlColumnProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the XmlColumnProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlColumnProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlColumnProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public XmlColumnProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the XmlColumnProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public XmlColumnProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "mapId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "xpath" == name)
    return new StringValue();
    
if( 0 == namespaceId && "denormalized" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xmlDataType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.XmlDataValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<XmlColumnProperties>(deep);
    }

   
}
/// <summary>
/// <para>Volatile Dependency Type.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:volType.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Main &lt;x:main></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Main))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VolatileType : OpenXmlCompositeElement
{
    private const string tagName = "volType";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11352;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileDependencyValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileDependencyValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the VolatileType class.
    /// </summary>
    public VolatileType():base(){}
    
            /// <summary>
    ///Initializes a new instance of the VolatileType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VolatileType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the VolatileType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VolatileType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the VolatileType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public VolatileType(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "main" == name)
    return new Main();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileDependencyValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VolatileType>(deep);
    }

   
}
/// <summary>
/// <para>Main.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:main.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Topic &lt;x:tp></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Topic))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Main : OpenXmlCompositeElement
{
    private const string tagName = "main";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11353;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "first" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> First String.</para>
    /// <para>Represents the following attribute in the schema: first </para>
    /// </summary>
    [SchemaAttr(0, "first")]
    public StringValue First
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Main class.
    /// </summary>
    public Main():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Main class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Main(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Main class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Main(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Main class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Main(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tp" == name)
    return new Topic();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "first" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Main>(deep);
    }

   
}
/// <summary>
/// <para>Topic.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tp.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Xstring &lt;x:v></description></item>
///<item><description>Subtopic &lt;x:stp></description></item>
///<item><description>TopicReferences &lt;x:tr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Xstring))]
    [ChildElementInfo(typeof(Subtopic))]
    [ChildElementInfo(typeof(TopicReferences))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Topic : OpenXmlCompositeElement
{
    private const string tagName = "tp";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11354;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "t" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Type.</para>
    /// <para>Represents the following attribute in the schema: t </para>
    /// </summary>
    [SchemaAttr(0, "t")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileValues> ValueType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Topic class.
    /// </summary>
    public Topic():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Topic class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Topic(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Topic class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Topic(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Topic class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Topic(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "v" == name)
    return new Xstring();
    
if( 22 == namespaceId && "stp" == name)
    return new Subtopic();
    
if( 22 == namespaceId && "tr" == name)
    return new TopicReferences();
    

    return null;
}

        private static readonly string[] eleTagNames = { "v","stp","tr" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Topic Value.</para>
    /// <para> Represents the following element tag in the schema: x:v </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Xstring Xstring
    {
        get 
        {
            return GetElement<Xstring>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "t" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.VolatileValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Topic>(deep);
    }

   
}
/// <summary>
/// <para>References.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopicReferences : OpenXmlLeafElement
{
    private const string tagName = "tr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11356;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "r","s" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: r </para>
    /// </summary>
    [SchemaAttr(0, "r")]
    public StringValue CellReference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: s </para>
    /// </summary>
    [SchemaAttr(0, "s")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TopicReferences class.
    /// </summary>
    public TopicReferences():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "r" == name)
    return new StringValue();
    
if( 0 == namespaceId && "s" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopicReferences>(deep);
    }

   
}
/// <summary>
/// <para>PivotCache.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotCache.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCache : OpenXmlLeafElement
{
    private const string tagName = "pivotCache";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11357;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "cacheId","id" };
    private static byte[] attributeNamespaceIds = { 0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> PivotCache Id.</para>
    /// <para>Represents the following attribute in the schema: cacheId </para>
    /// </summary>
    [SchemaAttr(0, "cacheId")]
    public UInt32Value CacheId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotCache class.
    /// </summary>
    public PivotCache():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "cacheId" == name)
    return new UInt32Value();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCache>(deep);
    }

   
}
/// <summary>
/// <para>Web Publishing Object.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPublishObject.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPublishObject : OpenXmlLeafElement
{
    private const string tagName = "webPublishObject";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11358;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","divId","sourceObject","destinationFile","title","autoRepublish" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Id.</para>
    /// <para>Represents the following attribute in the schema: id </para>
    /// </summary>
    [SchemaAttr(0, "id")]
    public UInt32Value Id
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Div Id.</para>
    /// <para>Represents the following attribute in the schema: divId </para>
    /// </summary>
    [SchemaAttr(0, "divId")]
    public StringValue DivId
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Source Object.</para>
    /// <para>Represents the following attribute in the schema: sourceObject </para>
    /// </summary>
    [SchemaAttr(0, "sourceObject")]
    public StringValue SourceObject
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Destination File.</para>
    /// <para>Represents the following attribute in the schema: destinationFile </para>
    /// </summary>
    [SchemaAttr(0, "destinationFile")]
    public StringValue DestinationFile
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Title.</para>
    /// <para>Represents the following attribute in the schema: title </para>
    /// </summary>
    [SchemaAttr(0, "title")]
    public StringValue Title
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Auto Republish.</para>
    /// <para>Represents the following attribute in the schema: autoRepublish </para>
    /// </summary>
    [SchemaAttr(0, "autoRepublish")]
    public BooleanValue AutoRepublish
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPublishObject class.
    /// </summary>
    public WebPublishObject():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "id" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "divId" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sourceObject" == name)
    return new StringValue();
    
if( 0 == namespaceId && "destinationFile" == name)
    return new StringValue();
    
if( 0 == namespaceId && "title" == name)
    return new StringValue();
    
if( 0 == namespaceId && "autoRepublish" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPublishObject>(deep);
    }

   
}
/// <summary>
/// <para>External Reference.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:externalReference.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalReference : OpenXmlLeafElement
{
    private const string tagName = "externalReference";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11359;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ExternalReference class.
    /// </summary>
    public ExternalReference():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalReference>(deep);
    }

   
}
/// <summary>
/// <para>Custom Workbook View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customWorkbookView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomWorkbookView : OpenXmlCompositeElement
{
    private const string tagName = "customWorkbookView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11360;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","guid","autoUpdate","mergeInterval","changesSavedWin","onlySync","personalView","includePrintSettings","includeHiddenRowCol","maximized","minimized","showHorizontalScroll","showVerticalScroll","showSheetTabs","xWindow","yWindow","windowWidth","windowHeight","tabRatio","activeSheetId","showFormulaBar","showStatusbar","showComments","showObjects" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Custom View Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Custom View GUID.</para>
    /// <para>Represents the following attribute in the schema: guid </para>
    /// </summary>
    [SchemaAttr(0, "guid")]
    public StringValue Guid
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Auto Update.</para>
    /// <para>Represents the following attribute in the schema: autoUpdate </para>
    /// </summary>
    [SchemaAttr(0, "autoUpdate")]
    public BooleanValue AutoUpdate
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Merge Interval.</para>
    /// <para>Represents the following attribute in the schema: mergeInterval </para>
    /// </summary>
    [SchemaAttr(0, "mergeInterval")]
    public UInt32Value MergeInterval
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Changes Saved Win.</para>
    /// <para>Represents the following attribute in the schema: changesSavedWin </para>
    /// </summary>
    [SchemaAttr(0, "changesSavedWin")]
    public BooleanValue ChangesSavedWin
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Only Synch.</para>
    /// <para>Represents the following attribute in the schema: onlySync </para>
    /// </summary>
    [SchemaAttr(0, "onlySync")]
    public BooleanValue OnlySync
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Personal View.</para>
    /// <para>Represents the following attribute in the schema: personalView </para>
    /// </summary>
    [SchemaAttr(0, "personalView")]
    public BooleanValue PersonalView
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Include Print Settings.</para>
    /// <para>Represents the following attribute in the schema: includePrintSettings </para>
    /// </summary>
    [SchemaAttr(0, "includePrintSettings")]
    public BooleanValue IncludePrintSettings
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Include Hidden Rows and Columns.</para>
    /// <para>Represents the following attribute in the schema: includeHiddenRowCol </para>
    /// </summary>
    [SchemaAttr(0, "includeHiddenRowCol")]
    public BooleanValue IncludeHiddenRowColumn
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Maximized.</para>
    /// <para>Represents the following attribute in the schema: maximized </para>
    /// </summary>
    [SchemaAttr(0, "maximized")]
    public BooleanValue Maximized
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Minimized.</para>
    /// <para>Represents the following attribute in the schema: minimized </para>
    /// </summary>
    [SchemaAttr(0, "minimized")]
    public BooleanValue Minimized
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Show Horizontal Scroll.</para>
    /// <para>Represents the following attribute in the schema: showHorizontalScroll </para>
    /// </summary>
    [SchemaAttr(0, "showHorizontalScroll")]
    public BooleanValue ShowHorizontalScroll
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Show Vertical Scroll.</para>
    /// <para>Represents the following attribute in the schema: showVerticalScroll </para>
    /// </summary>
    [SchemaAttr(0, "showVerticalScroll")]
    public BooleanValue ShowVerticalScroll
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Show Sheet Tabs.</para>
    /// <para>Represents the following attribute in the schema: showSheetTabs </para>
    /// </summary>
    [SchemaAttr(0, "showSheetTabs")]
    public BooleanValue ShowSheetTabs
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Corner (X Coordinate).</para>
    /// <para>Represents the following attribute in the schema: xWindow </para>
    /// </summary>
    [SchemaAttr(0, "xWindow")]
    public Int32Value XWindow
    {
        get { return (Int32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Corner (Y Coordinate).</para>
    /// <para>Represents the following attribute in the schema: yWindow </para>
    /// </summary>
    [SchemaAttr(0, "yWindow")]
    public Int32Value YWindow
    {
        get { return (Int32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Window Width.</para>
    /// <para>Represents the following attribute in the schema: windowWidth </para>
    /// </summary>
    [SchemaAttr(0, "windowWidth")]
    public UInt32Value WindowWidth
    {
        get { return (UInt32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Window Height.</para>
    /// <para>Represents the following attribute in the schema: windowHeight </para>
    /// </summary>
    [SchemaAttr(0, "windowHeight")]
    public UInt32Value WindowHeight
    {
        get { return (UInt32Value)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Tab Ratio.</para>
    /// <para>Represents the following attribute in the schema: tabRatio </para>
    /// </summary>
    [SchemaAttr(0, "tabRatio")]
    public UInt32Value TabRatio
    {
        get { return (UInt32Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Active Sheet in Book View.</para>
    /// <para>Represents the following attribute in the schema: activeSheetId </para>
    /// </summary>
    [SchemaAttr(0, "activeSheetId")]
    public UInt32Value ActiveSheetId
    {
        get { return (UInt32Value)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Show Formula Bar.</para>
    /// <para>Represents the following attribute in the schema: showFormulaBar </para>
    /// </summary>
    [SchemaAttr(0, "showFormulaBar")]
    public BooleanValue ShowFormulaBar
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    
    /// <summary>
    /// <para> Show Status Bar.</para>
    /// <para>Represents the following attribute in the schema: showStatusbar </para>
    /// </summary>
    [SchemaAttr(0, "showStatusbar")]
    public BooleanValue ShowStatusbar
    {
        get { return (BooleanValue)Attributes[21]; }
        set { Attributes[21] = value; }
    }
    
    /// <summary>
    /// <para> Show Comments.</para>
    /// <para>Represents the following attribute in the schema: showComments </para>
    /// </summary>
    [SchemaAttr(0, "showComments")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CommentsValues> ShowComments
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CommentsValues>)Attributes[22]; }
        set { Attributes[22] = value; }
    }
    
    /// <summary>
    /// <para> Show Objects.</para>
    /// <para>Represents the following attribute in the schema: showObjects </para>
    /// </summary>
    [SchemaAttr(0, "showObjects")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues> ShowObjects
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>)Attributes[23]; }
        set { Attributes[23] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomWorkbookView class.
    /// </summary>
    public CustomWorkbookView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomWorkbookView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomWorkbookView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomWorkbookView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomWorkbookView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomWorkbookView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomWorkbookView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "guid" == name)
    return new StringValue();
    
if( 0 == namespaceId && "autoUpdate" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "mergeInterval" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "changesSavedWin" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "onlySync" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "personalView" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "includePrintSettings" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "includeHiddenRowCol" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "maximized" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "minimized" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showHorizontalScroll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showVerticalScroll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showSheetTabs" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xWindow" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "yWindow" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "windowWidth" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "windowHeight" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "tabRatio" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "activeSheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "showFormulaBar" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showStatusbar" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showComments" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CommentsValues>();
    
if( 0 == namespaceId && "showObjects" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomWorkbookView>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheet.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Sheet : OpenXmlLeafElement
{
    private const string tagName = "sheet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11361;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","sheetId","state","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Tab Id.</para>
    /// <para>Represents the following attribute in the schema: sheetId </para>
    /// </summary>
    [SchemaAttr(0, "sheetId")]
    public UInt32Value SheetId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Visible State.</para>
    /// <para>Represents the following attribute in the schema: state </para>
    /// </summary>
    [SchemaAttr(0, "state")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues> State
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Sheet class.
    /// </summary>
    public Sheet():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "state" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SheetStateValues>();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Sheet>(deep);
    }

   
}
/// <summary>
/// <para>Workbook View.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:workbookView.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorkbookView : OpenXmlCompositeElement
{
    private const string tagName = "workbookView";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11362;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "visibility","minimized","showHorizontalScroll","showVerticalScroll","showSheetTabs","xWindow","yWindow","windowWidth","windowHeight","tabRatio","firstSheet","activeTab","autoFilterDateGrouping" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Visibility.</para>
    /// <para>Represents the following attribute in the schema: visibility </para>
    /// </summary>
    [SchemaAttr(0, "visibility")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.VisibilityValues> Visibility
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.VisibilityValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Minimized.</para>
    /// <para>Represents the following attribute in the schema: minimized </para>
    /// </summary>
    [SchemaAttr(0, "minimized")]
    public BooleanValue Minimized
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Horizontal Scroll.</para>
    /// <para>Represents the following attribute in the schema: showHorizontalScroll </para>
    /// </summary>
    [SchemaAttr(0, "showHorizontalScroll")]
    public BooleanValue ShowHorizontalScroll
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Vertical Scroll.</para>
    /// <para>Represents the following attribute in the schema: showVerticalScroll </para>
    /// </summary>
    [SchemaAttr(0, "showVerticalScroll")]
    public BooleanValue ShowVerticalScroll
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Sheet Tabs.</para>
    /// <para>Represents the following attribute in the schema: showSheetTabs </para>
    /// </summary>
    [SchemaAttr(0, "showSheetTabs")]
    public BooleanValue ShowSheetTabs
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Upper Left Corner (X Coordinate).</para>
    /// <para>Represents the following attribute in the schema: xWindow </para>
    /// </summary>
    [SchemaAttr(0, "xWindow")]
    public Int32Value XWindow
    {
        get { return (Int32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Upper Left Corner (Y Coordinate).</para>
    /// <para>Represents the following attribute in the schema: yWindow </para>
    /// </summary>
    [SchemaAttr(0, "yWindow")]
    public Int32Value YWindow
    {
        get { return (Int32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Window Width.</para>
    /// <para>Represents the following attribute in the schema: windowWidth </para>
    /// </summary>
    [SchemaAttr(0, "windowWidth")]
    public UInt32Value WindowWidth
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Window Height.</para>
    /// <para>Represents the following attribute in the schema: windowHeight </para>
    /// </summary>
    [SchemaAttr(0, "windowHeight")]
    public UInt32Value WindowHeight
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Tab Ratio.</para>
    /// <para>Represents the following attribute in the schema: tabRatio </para>
    /// </summary>
    [SchemaAttr(0, "tabRatio")]
    public UInt32Value TabRatio
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> First Sheet.</para>
    /// <para>Represents the following attribute in the schema: firstSheet </para>
    /// </summary>
    [SchemaAttr(0, "firstSheet")]
    public UInt32Value FirstSheet
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Active Sheet Index.</para>
    /// <para>Represents the following attribute in the schema: activeTab </para>
    /// </summary>
    [SchemaAttr(0, "activeTab")]
    public UInt32Value ActiveTab
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> AutoFilter Date Grouping.</para>
    /// <para>Represents the following attribute in the schema: autoFilterDateGrouping </para>
    /// </summary>
    [SchemaAttr(0, "autoFilterDateGrouping")]
    public BooleanValue AutoFilterDateGrouping
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorkbookView class.
    /// </summary>
    public WorkbookView():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WorkbookView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookView(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookView class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookView(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookView class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WorkbookView(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "extLst" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "visibility" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.VisibilityValues>();
    
if( 0 == namespaceId && "minimized" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showHorizontalScroll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showVerticalScroll" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showSheetTabs" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xWindow" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "yWindow" == name)
    return new Int32Value();
    
if( 0 == namespaceId && "windowWidth" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "windowHeight" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "tabRatio" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "firstSheet" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "activeTab" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "autoFilterDateGrouping" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorkbookView>(deep);
    }

   
}
/// <summary>
/// <para>Defined Name.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:definedName.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefinedName : OpenXmlLeafTextElement
{
    private const string tagName = "definedName";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11363;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","comment","customMenu","description","help","statusBar","localSheetId","hidden","function","vbProcedure","xlm","functionGroupId","shortcutKey","publishToServer","workbookParameter" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Defined Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Comment.</para>
    /// <para>Represents the following attribute in the schema: comment </para>
    /// </summary>
    [SchemaAttr(0, "comment")]
    public StringValue Comment
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Custom Menu Text.</para>
    /// <para>Represents the following attribute in the schema: customMenu </para>
    /// </summary>
    [SchemaAttr(0, "customMenu")]
    public StringValue CustomMenu
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Description.</para>
    /// <para>Represents the following attribute in the schema: description </para>
    /// </summary>
    [SchemaAttr(0, "description")]
    public StringValue Description
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Help.</para>
    /// <para>Represents the following attribute in the schema: help </para>
    /// </summary>
    [SchemaAttr(0, "help")]
    public StringValue Help
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Status Bar.</para>
    /// <para>Represents the following attribute in the schema: statusBar </para>
    /// </summary>
    [SchemaAttr(0, "statusBar")]
    public StringValue StatusBar
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Local Name Sheet Id.</para>
    /// <para>Represents the following attribute in the schema: localSheetId </para>
    /// </summary>
    [SchemaAttr(0, "localSheetId")]
    public UInt32Value LocalSheetId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Hidden Name.</para>
    /// <para>Represents the following attribute in the schema: hidden </para>
    /// </summary>
    [SchemaAttr(0, "hidden")]
    public BooleanValue Hidden
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Function.</para>
    /// <para>Represents the following attribute in the schema: function </para>
    /// </summary>
    [SchemaAttr(0, "function")]
    public BooleanValue Function
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Procedure.</para>
    /// <para>Represents the following attribute in the schema: vbProcedure </para>
    /// </summary>
    [SchemaAttr(0, "vbProcedure")]
    public BooleanValue VbProcedure
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> External Function.</para>
    /// <para>Represents the following attribute in the schema: xlm </para>
    /// </summary>
    [SchemaAttr(0, "xlm")]
    public BooleanValue Xlm
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Function Group Id.</para>
    /// <para>Represents the following attribute in the schema: functionGroupId </para>
    /// </summary>
    [SchemaAttr(0, "functionGroupId")]
    public UInt32Value FunctionGroupId
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Shortcut Key.</para>
    /// <para>Represents the following attribute in the schema: shortcutKey </para>
    /// </summary>
    [SchemaAttr(0, "shortcutKey")]
    public StringValue ShortcutKey
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Publish To Server.</para>
    /// <para>Represents the following attribute in the schema: publishToServer </para>
    /// </summary>
    [SchemaAttr(0, "publishToServer")]
    public BooleanValue PublishToServer
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Workbook Parameter (Server).</para>
    /// <para>Represents the following attribute in the schema: workbookParameter </para>
    /// </summary>
    [SchemaAttr(0, "workbookParameter")]
    public BooleanValue WorkbookParameter
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DefinedName class.
    /// </summary>
    public DefinedName():base(){}
    
      
           /// <summary>
    /// Initializes a new instance of the DefinedName class with the specified text content.
    /// </summary>
    /// <param name="text">Specifies the text content of the element.</param>
    public DefinedName(string text):base(text)
    {
    }
    
    internal override OpenXmlSimpleType InnerTextToValue(string text)
    {
		
		return new StringValue(){ InnerText = text };
    }
    
 
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "comment" == name)
    return new StringValue();
    
if( 0 == namespaceId && "customMenu" == name)
    return new StringValue();
    
if( 0 == namespaceId && "description" == name)
    return new StringValue();
    
if( 0 == namespaceId && "help" == name)
    return new StringValue();
    
if( 0 == namespaceId && "statusBar" == name)
    return new StringValue();
    
if( 0 == namespaceId && "localSheetId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "hidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "function" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "vbProcedure" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xlm" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "functionGroupId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "shortcutKey" == name)
    return new StringValue();
    
if( 0 == namespaceId && "publishToServer" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "workbookParameter" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefinedName>(deep);
    }

   
}
/// <summary>
/// <para>Function Group.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:functionGroup.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FunctionGroup : OpenXmlLeafElement
{
    private const string tagName = "functionGroup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11364;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FunctionGroup class.
    /// </summary>
    public FunctionGroup():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FunctionGroup>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.Table &lt;x14:table></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.Table),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11365;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableExtension class.
    /// </summary>
    public TableExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "table" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.Table();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ObjectAnchor Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:anchor.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FromMarker &lt;x:from></description></item>
///<item><description>ToMarker &lt;x:to></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FromMarker),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(ToMarker),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class ObjectAnchor : OpenXmlCompositeElement
{
    private const string tagName = "anchor";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11366;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "moveWithCells","sizeWithCells","z-order" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> moveWithCells.</para>
    /// <para>Represents the following attribute in the schema: moveWithCells </para>
    /// </summary>
    [SchemaAttr(0, "moveWithCells")]
    public BooleanValue MoveWithCells
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> sizeWithCells.</para>
    /// <para>Represents the following attribute in the schema: sizeWithCells </para>
    /// </summary>
    [SchemaAttr(0, "sizeWithCells")]
    public BooleanValue SizeWithCells
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> z-order.</para>
    /// <para>Represents the following attribute in the schema: z-order </para>
    /// </summary>
    [SchemaAttr(0, "z-order")]
    public UInt32Value ZOrder
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ObjectAnchor class.
    /// </summary>
    public ObjectAnchor():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ObjectAnchor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ObjectAnchor(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ObjectAnchor class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ObjectAnchor(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ObjectAnchor class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ObjectAnchor(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "from" == name)
    return new FromMarker();
    
if( 22 == namespaceId && "to" == name)
    return new ToMarker();
    

    return null;
}

        private static readonly string[] eleTagNames = { "from","to" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> FromMarker.</para>
    /// <para> Represents the following element tag in the schema: x:from </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public FromMarker FromMarker
    {
        get 
        {
            return GetElement<FromMarker>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> ToMarker.</para>
    /// <para> Represents the following element tag in the schema: x:to </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ToMarker ToMarker
    {
        get 
        {
            return GetElement<ToMarker>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "moveWithCells" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sizeWithCells" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "z-order" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ObjectAnchor>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FromMarker Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:from.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId &lt;xdr:col></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset &lt;xdr:colOff></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId &lt;xdr:row></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset &lt;xdr:rowOff></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class FromMarker : MarkerType
{
    private const string tagName = "from";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11367;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the FromMarker class.
    /// </summary>
    public FromMarker():base(){}
            /// <summary>
    ///Initializes a new instance of the FromMarker class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FromMarker(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FromMarker class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FromMarker(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FromMarker class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FromMarker(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FromMarker>(deep);
    }

}
/// <summary>
/// <para>Defines the ToMarker Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:to.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId &lt;xdr:col></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset &lt;xdr:colOff></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId &lt;xdr:row></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset &lt;xdr:rowOff></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class ToMarker : MarkerType
{
    private const string tagName = "to";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11368;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the ToMarker class.
    /// </summary>
    public ToMarker():base(){}
            /// <summary>
    ///Initializes a new instance of the ToMarker class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ToMarker(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ToMarker class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ToMarker(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ToMarker class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ToMarker(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ToMarker>(deep);
    }

}
/// <summary>
/// Defines the MarkerType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId &lt;xdr:col></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset &lt;xdr:colOff></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId &lt;xdr:row></description></item>
///<item><description>DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset &lt;xdr:rowOff></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId))]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class MarkerType : OpenXmlCompositeElement
{
        
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 18 == namespaceId && "col" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId();
    
if( 18 == namespaceId && "colOff" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset();
    
if( 18 == namespaceId && "row" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId();
    
if( 18 == namespaceId && "rowOff" == name)
    return new DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset();
    

    return null;
}

        private static readonly string[] eleTagNames = { "col","colOff","row","rowOff" };
    private static readonly byte[] eleNamespaceIds = { 18,18,18,18 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Column).</para>
    /// <para> Represents the following element tag in the schema: xdr:col </para>
    /// </summary>
    /// <remark>
    /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId ColumnId
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnId>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Column Offset.</para>
    /// <para> Represents the following element tag in the schema: xdr:colOff </para>
    /// </summary>
    /// <remark>
    /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset ColumnOffset
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.ColumnOffset>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Row.</para>
    /// <para> Represents the following element tag in the schema: xdr:row </para>
    /// </summary>
    /// <remark>
    /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId RowId
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowId>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Row Offset.</para>
    /// <para> Represents the following element tag in the schema: xdr:rowOff </para>
    /// </summary>
    /// <remark>
    /// xmlns:xdr = http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing
    /// </remark>
    public DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset RowOffset
    {
        get 
        {
            return GetElement<DocumentFormat.OpenXml.Drawing.Spreadsheet.RowOffset>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    
    
    /// <summary>
    /// Initializes a new instance of the MarkerType class.
    /// </summary>
    protected MarkerType(){}
    
            /// <summary>
    ///Initializes a new instance of the MarkerType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MarkerType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MarkerType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected MarkerType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MarkerType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected MarkerType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the ConditionalFormattingRuleExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.Id &lt;x14:id></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.Id),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormattingRuleExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11369;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtension class.
    /// </summary>
    public ConditionalFormattingRuleExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormattingRuleExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRuleExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRuleExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormattingRuleExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "id" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.Id();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormattingRuleExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotHierarchyExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy &lt;x14:pivotHierarchy></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotHierarchyExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11370;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtension class.
    /// </summary>
    public PivotHierarchyExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotHierarchyExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchyExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchyExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotHierarchyExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "pivotHierarchy" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.PivotHierarchy();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotHierarchyExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotFieldExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.PivotField &lt;x14:pivotField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotField),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFieldExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11371;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotFieldExtension class.
    /// </summary>
    public PivotFieldExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFieldExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFieldExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFieldExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "pivotField" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.PivotField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFieldExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheSourceExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SourceConnection &lt;x14:sourceConnection></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SourceConnection),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheSourceExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11372;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheSourceExtension class.
    /// </summary>
    public CacheSourceExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheSourceExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSourceExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSourceExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSourceExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSourceExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheSourceExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "sourceConnection" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SourceConnection();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheSourceExtension>(deep);
    }

   
}
/// <summary>
/// <para>Table Columns.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableColumns.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableColumn &lt;x:tableColumn></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableColumn))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableColumns : OpenXmlCompositeElement
{
    private const string tagName = "tableColumns";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11373;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Column Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableColumns class.
    /// </summary>
    public TableColumns():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableColumns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableColumns(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableColumns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableColumns(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableColumns class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableColumns(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tableColumn" == name)
    return new TableColumn();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableColumns>(deep);
    }

   
}
/// <summary>
/// <para>Table Style.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableStyleInfo.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyleInfo : OpenXmlLeafElement
{
    private const string tagName = "tableStyleInfo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11374;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","showFirstColumn","showLastColumn","showRowStripes","showColumnStripes" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Style Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show First Column.</para>
    /// <para>Represents the following attribute in the schema: showFirstColumn </para>
    /// </summary>
    [SchemaAttr(0, "showFirstColumn")]
    public BooleanValue ShowFirstColumn
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Last Column.</para>
    /// <para>Represents the following attribute in the schema: showLastColumn </para>
    /// </summary>
    [SchemaAttr(0, "showLastColumn")]
    public BooleanValue ShowLastColumn
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Row Stripes.</para>
    /// <para>Represents the following attribute in the schema: showRowStripes </para>
    /// </summary>
    [SchemaAttr(0, "showRowStripes")]
    public BooleanValue ShowRowStripes
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Column Stripes.</para>
    /// <para>Represents the following attribute in the schema: showColumnStripes </para>
    /// </summary>
    [SchemaAttr(0, "showColumnStripes")]
    public BooleanValue ShowColumnStripes
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyleInfo class.
    /// </summary>
    public TableStyleInfo():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showFirstColumn" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showLastColumn" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showRowStripes" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showColumnStripes" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyleInfo>(deep);
    }

   
}
/// <summary>
/// <para>Future Feature Data Storage Area.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11375;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TableExtensionList class.
    /// </summary>
    public TableExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new TableExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>OLE Link Item.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleItem.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleItem : OpenXmlLeafElement
{
    private const string tagName = "oleItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11376;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","icon","advise","preferPic" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLE Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Icon.</para>
    /// <para>Represents the following attribute in the schema: icon </para>
    /// </summary>
    [SchemaAttr(0, "icon")]
    public BooleanValue Icon
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Advise.</para>
    /// <para>Represents the following attribute in the schema: advise </para>
    /// </summary>
    [SchemaAttr(0, "advise")]
    public BooleanValue Advise
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Object is an Image.</para>
    /// <para>Represents the following attribute in the schema: preferPic </para>
    /// </summary>
    [SchemaAttr(0, "preferPic")]
    public BooleanValue PreferPicture
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OleItem class.
    /// </summary>
    public OleItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "icon" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "advise" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "preferPic" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleItem>(deep);
    }

   
}
/// <summary>
/// <para>Defines the StartBorder Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:start.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class StartBorder : BorderPropertiesType
{
    private const string tagName = "start";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11377;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the StartBorder class.
    /// </summary>
    public StartBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the StartBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StartBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StartBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StartBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StartBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StartBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StartBorder>(deep);
    }

}
/// <summary>
/// <para>Defines the EndBorder Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:end.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class EndBorder : BorderPropertiesType
{
    private const string tagName = "end";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11378;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the EndBorder class.
    /// </summary>
    public EndBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the EndBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EndBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EndBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EndBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EndBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EndBorder>(deep);
    }

}
/// <summary>
/// <para>Left Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:left.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LeftBorder : BorderPropertiesType
{
    private const string tagName = "left";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11379;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LeftBorder class.
    /// </summary>
    public LeftBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the LeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public LeftBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the LeftBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public LeftBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LeftBorder>(deep);
    }

}
/// <summary>
/// <para>Right Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:right.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RightBorder : BorderPropertiesType
{
    private const string tagName = "right";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11380;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the RightBorder class.
    /// </summary>
    public RightBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the RightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RightBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RightBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RightBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RightBorder>(deep);
    }

}
/// <summary>
/// <para>Top Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:top.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TopBorder : BorderPropertiesType
{
    private const string tagName = "top";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11381;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the TopBorder class.
    /// </summary>
    public TopBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the TopBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TopBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TopBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TopBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TopBorder>(deep);
    }

}
/// <summary>
/// <para>Bottom Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:bottom.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BottomBorder : BorderPropertiesType
{
    private const string tagName = "bottom";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11382;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the BottomBorder class.
    /// </summary>
    public BottomBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the BottomBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BottomBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BottomBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BottomBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BottomBorder>(deep);
    }

}
/// <summary>
/// <para>Diagonal.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:diagonal.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DiagonalBorder : BorderPropertiesType
{
    private const string tagName = "diagonal";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11383;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the DiagonalBorder class.
    /// </summary>
    public DiagonalBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the DiagonalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DiagonalBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DiagonalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DiagonalBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DiagonalBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DiagonalBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DiagonalBorder>(deep);
    }

}
/// <summary>
/// <para>Vertical Inner Border.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:vertical.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class VerticalBorder : BorderPropertiesType
{
    private const string tagName = "vertical";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11384;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the VerticalBorder class.
    /// </summary>
    public VerticalBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the VerticalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VerticalBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the VerticalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public VerticalBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the VerticalBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public VerticalBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<VerticalBorder>(deep);
    }

}
/// <summary>
/// <para>Horizontal Inner Borders.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:horizontal.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class HorizontalBorder : BorderPropertiesType
{
    private const string tagName = "horizontal";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11385;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the HorizontalBorder class.
    /// </summary>
    public HorizontalBorder():base(){}
            /// <summary>
    ///Initializes a new instance of the HorizontalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HorizontalBorder(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the HorizontalBorder class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public HorizontalBorder(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the HorizontalBorder class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public HorizontalBorder(string outerXml)
        : base(outerXml)
    {
    }

    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<HorizontalBorder>(deep);
    }

}
/// <summary>
/// Defines the BorderPropertiesType class.
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Color))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class BorderPropertiesType : OpenXmlCompositeElement
{
    private static string[] attributeTagNames = { "style" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Line Style.</para>
    /// <para>Represents the following attribute in the schema: style </para>
    /// </summary>
    [SchemaAttr(0, "style")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.BorderStyleValues> Style
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.BorderStyleValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "color" == name)
    return new Color();
    

    return null;
}

        private static readonly string[] eleTagNames = { "color" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Color.</para>
    /// <para> Represents the following element tag in the schema: x:color </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Color Color
    {
        get 
        {
            return GetElement<Color>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "style" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.BorderStyleValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the BorderPropertiesType class.
    /// </summary>
    protected BorderPropertiesType(){}
    
            /// <summary>
    ///Initializes a new instance of the BorderPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected BorderPropertiesType(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BorderPropertiesType class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    protected BorderPropertiesType(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BorderPropertiesType class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    protected BorderPropertiesType(string outerXml)
        : base(outerXml)
    {
    }

    
}
/// <summary>
/// <para>Defines the ControlProperties Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:controlPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ObjectAnchor &lt;x:anchor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ObjectAnchor),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class ControlProperties : OpenXmlCompositeElement
{
    private const string tagName = "controlPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11386;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "locked","defaultSize","print","disabled","recalcAlways","uiObject","autoFill","autoLine","autoPict","macro","altText","linkedCell","listFillRange","cf","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> locked.</para>
    /// <para>Represents the following attribute in the schema: locked </para>
    /// </summary>
    [SchemaAttr(0, "locked")]
    public BooleanValue Locked
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> defaultSize.</para>
    /// <para>Represents the following attribute in the schema: defaultSize </para>
    /// </summary>
    [SchemaAttr(0, "defaultSize")]
    public BooleanValue DefaultSize
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> print.</para>
    /// <para>Represents the following attribute in the schema: print </para>
    /// </summary>
    [SchemaAttr(0, "print")]
    public BooleanValue Print
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> disabled.</para>
    /// <para>Represents the following attribute in the schema: disabled </para>
    /// </summary>
    [SchemaAttr(0, "disabled")]
    public BooleanValue Disabled
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> recalcAlways.</para>
    /// <para>Represents the following attribute in the schema: recalcAlways </para>
    /// </summary>
    [SchemaAttr(0, "recalcAlways")]
    public BooleanValue RecalcAlways
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> uiObject.</para>
    /// <para>Represents the following attribute in the schema: uiObject </para>
    /// </summary>
    [SchemaAttr(0, "uiObject")]
    public BooleanValue UiObject
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> autoFill.</para>
    /// <para>Represents the following attribute in the schema: autoFill </para>
    /// </summary>
    [SchemaAttr(0, "autoFill")]
    public BooleanValue AutoFill
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> autoLine.</para>
    /// <para>Represents the following attribute in the schema: autoLine </para>
    /// </summary>
    [SchemaAttr(0, "autoLine")]
    public BooleanValue AutoLine
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> autoPict.</para>
    /// <para>Represents the following attribute in the schema: autoPict </para>
    /// </summary>
    [SchemaAttr(0, "autoPict")]
    public BooleanValue AutoPict
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> macro.</para>
    /// <para>Represents the following attribute in the schema: macro </para>
    /// </summary>
    [SchemaAttr(0, "macro")]
    public StringValue Macro
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> altText.</para>
    /// <para>Represents the following attribute in the schema: altText </para>
    /// </summary>
    [SchemaAttr(0, "altText")]
    public StringValue AltText
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> linkedCell.</para>
    /// <para>Represents the following attribute in the schema: linkedCell </para>
    /// </summary>
    [SchemaAttr(0, "linkedCell")]
    public StringValue LinkedCell
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> listFillRange.</para>
    /// <para>Represents the following attribute in the schema: listFillRange </para>
    /// </summary>
    [SchemaAttr(0, "listFillRange")]
    public StringValue ListFillRange
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> cf.</para>
    /// <para>Represents the following attribute in the schema: cf </para>
    /// </summary>
    [SchemaAttr(0, "cf")]
    public StringValue Cf
    {
        get { return (StringValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ControlProperties class.
    /// </summary>
    public ControlProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ControlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ControlProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ControlProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ControlProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ControlProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ControlProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "anchor" == name)
    return new ObjectAnchor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "anchor" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ObjectAnchor.</para>
    /// <para> Represents the following element tag in the schema: x:anchor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ObjectAnchor ObjectAnchor
    {
        get 
        {
            return GetElement<ObjectAnchor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "locked" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultSize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "print" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disabled" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "recalcAlways" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "uiObject" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoFill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoLine" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoPict" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "macro" == name)
    return new StringValue();
    
if( 0 == namespaceId && "altText" == name)
    return new StringValue();
    
if( 0 == namespaceId && "linkedCell" == name)
    return new StringValue();
    
if( 0 == namespaceId && "listFillRange" == name)
    return new StringValue();
    
if( 0 == namespaceId && "cf" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ControlProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the EmbeddedObjectProperties Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:objectPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ObjectAnchor &lt;x:anchor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ObjectAnchor),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class EmbeddedObjectProperties : OpenXmlCompositeElement
{
    private const string tagName = "objectPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11387;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "locked","defaultSize","print","disabled","uiObject","autoFill","autoLine","autoPict","macro","altText","dde","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> locked.</para>
    /// <para>Represents the following attribute in the schema: locked </para>
    /// </summary>
    [SchemaAttr(0, "locked")]
    public BooleanValue Locked
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> defaultSize.</para>
    /// <para>Represents the following attribute in the schema: defaultSize </para>
    /// </summary>
    [SchemaAttr(0, "defaultSize")]
    public BooleanValue DefaultSize
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> print.</para>
    /// <para>Represents the following attribute in the schema: print </para>
    /// </summary>
    [SchemaAttr(0, "print")]
    public BooleanValue Print
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> disabled.</para>
    /// <para>Represents the following attribute in the schema: disabled </para>
    /// </summary>
    [SchemaAttr(0, "disabled")]
    public BooleanValue Disabled
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> uiObject.</para>
    /// <para>Represents the following attribute in the schema: uiObject </para>
    /// </summary>
    [SchemaAttr(0, "uiObject")]
    public BooleanValue UiObject
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> autoFill.</para>
    /// <para>Represents the following attribute in the schema: autoFill </para>
    /// </summary>
    [SchemaAttr(0, "autoFill")]
    public BooleanValue AutoFill
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> autoLine.</para>
    /// <para>Represents the following attribute in the schema: autoLine </para>
    /// </summary>
    [SchemaAttr(0, "autoLine")]
    public BooleanValue AutoLine
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> autoPict.</para>
    /// <para>Represents the following attribute in the schema: autoPict </para>
    /// </summary>
    [SchemaAttr(0, "autoPict")]
    public BooleanValue AutoPict
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> macro.</para>
    /// <para>Represents the following attribute in the schema: macro </para>
    /// </summary>
    [SchemaAttr(0, "macro")]
    public StringValue Macro
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> altText.</para>
    /// <para>Represents the following attribute in the schema: altText </para>
    /// </summary>
    [SchemaAttr(0, "altText")]
    public StringValue AltText
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> dde.</para>
    /// <para>Represents the following attribute in the schema: dde </para>
    /// </summary>
    [SchemaAttr(0, "dde")]
    public BooleanValue Dde
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the EmbeddedObjectProperties class.
    /// </summary>
    public EmbeddedObjectProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the EmbeddedObjectProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EmbeddedObjectProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the EmbeddedObjectProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public EmbeddedObjectProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the EmbeddedObjectProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public EmbeddedObjectProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "anchor" == name)
    return new ObjectAnchor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "anchor" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ObjectAnchor.</para>
    /// <para> Represents the following element tag in the schema: x:anchor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ObjectAnchor ObjectAnchor
    {
        get 
        {
            return GetElement<ObjectAnchor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "locked" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultSize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "print" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disabled" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "uiObject" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoFill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoLine" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoPict" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "macro" == name)
    return new StringValue();
    
if( 0 == namespaceId && "altText" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dde" == name)
    return new BooleanValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<EmbeddedObjectProperties>(deep);
    }

   
}
/// <summary>
/// <para>Chart Sheet Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TabColor &lt;x:tabColor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TabColor))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartSheetProperties : OpenXmlCompositeElement
{
    private const string tagName = "sheetPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11388;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "published","codeName" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Published.</para>
    /// <para>Represents the following attribute in the schema: published </para>
    /// </summary>
    [SchemaAttr(0, "published")]
    public BooleanValue Published
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Code Name.</para>
    /// <para>Represents the following attribute in the schema: codeName </para>
    /// </summary>
    [SchemaAttr(0, "codeName")]
    public StringValue CodeName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartSheetProperties class.
    /// </summary>
    public ChartSheetProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ChartSheetProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ChartSheetProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tabColor" == name)
    return new TabColor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tabColor" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TabColor.</para>
    /// <para> Represents the following element tag in the schema: x:tabColor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TabColor TabColor
    {
        get 
        {
            return GetElement<TabColor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "published" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "codeName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartSheetProperties>(deep);
    }

   
}
/// <summary>
/// <para>Chart Sheet Views.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ChartSheetView &lt;x:sheetView></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ChartSheetView))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartSheetViews : OpenXmlCompositeElement
{
    private const string tagName = "sheetViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11389;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetViews class.
    /// </summary>
    public ChartSheetViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ChartSheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartSheetViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartSheetViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ChartSheetViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetView" == name)
    return new ChartSheetView();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartSheetViews>(deep);
    }

   
}
/// <summary>
/// <para>Chart Sheet Protection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetProtection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartSheetProtection : OpenXmlLeafElement
{
    private const string tagName = "sheetProtection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11390;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "password","algorithmName","hashValue","saltValue","spinCount","content","objects" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Password.</para>
    /// <para>Represents the following attribute in the schema: password </para>
    /// </summary>
    [SchemaAttr(0, "password")]
    public HexBinaryValue Password
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Name.</para>
    /// <para>Represents the following attribute in the schema: algorithmName </para>
    /// </summary>
    [SchemaAttr(0, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash Value.</para>
    /// <para>Represents the following attribute in the schema: hashValue </para>
    /// </summary>
    [SchemaAttr(0, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Salt Value for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: saltValue </para>
    /// </summary>
    [SchemaAttr(0, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: spinCount </para>
    /// </summary>
    [SchemaAttr(0, "spinCount")]
    public UInt32Value SpinCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Contents.</para>
    /// <para>Represents the following attribute in the schema: content </para>
    /// </summary>
    [SchemaAttr(0, "content")]
    public BooleanValue Content
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Objects Locked.</para>
    /// <para>Represents the following attribute in the schema: objects </para>
    /// </summary>
    [SchemaAttr(0, "objects")]
    public BooleanValue Objects
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartSheetProtection class.
    /// </summary>
    public ChartSheetProtection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "password" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "spinCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "content" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "objects" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartSheetProtection>(deep);
    }

   
}
/// <summary>
/// <para>Custom Chart Sheet Views.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customSheetViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomChartsheetView &lt;x:customSheetView></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomChartsheetView))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomChartsheetViews : OpenXmlCompositeElement
{
    private const string tagName = "customSheetViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11391;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomChartsheetViews class.
    /// </summary>
    public CustomChartsheetViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomChartsheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomChartsheetViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomChartsheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomChartsheetViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomChartsheetViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomChartsheetViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "customSheetView" == name)
    return new CustomChartsheetView();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomChartsheetViews>(deep);
    }

   
}
/// <summary>
/// <para>Drawing.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:drawing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Drawing : OpenXmlLeafElement
{
    private const string tagName = "drawing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11392;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Drawing class.
    /// </summary>
    public Drawing():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Drawing>(deep);
    }

   
}
/// <summary>
/// <para>Defines the LegacyDrawing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:legacyDrawing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LegacyDrawing : LegacyDrawingType
{
    private const string tagName = "legacyDrawing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11393;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LegacyDrawing class.
    /// </summary>
    public LegacyDrawing():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LegacyDrawing>(deep);
    }

}
/// <summary>
/// <para>Legacy Drawing Reference in  Header Footer.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:legacyDrawingHF.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class LegacyDrawingHeaderFooter : LegacyDrawingType
{
    private const string tagName = "legacyDrawingHF";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11394;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    /// <summary>
    /// Initializes a new instance of the LegacyDrawingHeaderFooter class.
    /// </summary>
    public LegacyDrawingHeaderFooter():base(){}
    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<LegacyDrawingHeaderFooter>(deep);
    }

}
/// <summary>
/// Defines the LegacyDrawingType class.
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public abstract partial class LegacyDrawingType : OpenXmlLeafElement
{
    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    
    
        /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

    
    /// <summary>
    /// Initializes a new instance of the LegacyDrawingType class.
    /// </summary>
    protected LegacyDrawingType(){}
    
    
    
}
/// <summary>
/// <para>Defines the DrawingHeaderFooter Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:drawingHF.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DrawingHeaderFooter : OpenXmlLeafElement
{
    private const string tagName = "drawingHF";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11395;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id","lho","lhe","lhf","cho","che","chf","rho","rhe","rhf","lfo","lfe","lff","cfo","cfe","cff","rfo","rfe","rff" };
    private static byte[] attributeNamespaceIds = { 19,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> lho.</para>
    /// <para>Represents the following attribute in the schema: lho </para>
    /// </summary>
    [SchemaAttr(0, "lho")]
    public UInt32Value Lho
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> lhe.</para>
    /// <para>Represents the following attribute in the schema: lhe </para>
    /// </summary>
    [SchemaAttr(0, "lhe")]
    public UInt32Value Lhe
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> lhf.</para>
    /// <para>Represents the following attribute in the schema: lhf </para>
    /// </summary>
    [SchemaAttr(0, "lhf")]
    public UInt32Value Lhf
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> cho.</para>
    /// <para>Represents the following attribute in the schema: cho </para>
    /// </summary>
    [SchemaAttr(0, "cho")]
    public UInt32Value Cho
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> che.</para>
    /// <para>Represents the following attribute in the schema: che </para>
    /// </summary>
    [SchemaAttr(0, "che")]
    public UInt32Value Che
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> chf.</para>
    /// <para>Represents the following attribute in the schema: chf </para>
    /// </summary>
    [SchemaAttr(0, "chf")]
    public UInt32Value Chf
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> rho.</para>
    /// <para>Represents the following attribute in the schema: rho </para>
    /// </summary>
    [SchemaAttr(0, "rho")]
    public UInt32Value Rho
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> rhe.</para>
    /// <para>Represents the following attribute in the schema: rhe </para>
    /// </summary>
    [SchemaAttr(0, "rhe")]
    public UInt32Value Rhe
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> rhf.</para>
    /// <para>Represents the following attribute in the schema: rhf </para>
    /// </summary>
    [SchemaAttr(0, "rhf")]
    public UInt32Value Rhf
    {
        get { return (UInt32Value)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> lfo.</para>
    /// <para>Represents the following attribute in the schema: lfo </para>
    /// </summary>
    [SchemaAttr(0, "lfo")]
    public UInt32Value Lfo
    {
        get { return (UInt32Value)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> lfe.</para>
    /// <para>Represents the following attribute in the schema: lfe </para>
    /// </summary>
    [SchemaAttr(0, "lfe")]
    public UInt32Value Lfe
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> lff.</para>
    /// <para>Represents the following attribute in the schema: lff </para>
    /// </summary>
    [SchemaAttr(0, "lff")]
    public UInt32Value Lff
    {
        get { return (UInt32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> cfo.</para>
    /// <para>Represents the following attribute in the schema: cfo </para>
    /// </summary>
    [SchemaAttr(0, "cfo")]
    public UInt32Value Cfo
    {
        get { return (UInt32Value)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> cfe.</para>
    /// <para>Represents the following attribute in the schema: cfe </para>
    /// </summary>
    [SchemaAttr(0, "cfe")]
    public UInt32Value Cfe
    {
        get { return (UInt32Value)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> cff.</para>
    /// <para>Represents the following attribute in the schema: cff </para>
    /// </summary>
    [SchemaAttr(0, "cff")]
    public UInt32Value Cff
    {
        get { return (UInt32Value)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> rfo.</para>
    /// <para>Represents the following attribute in the schema: rfo </para>
    /// </summary>
    [SchemaAttr(0, "rfo")]
    public UInt32Value Rfo
    {
        get { return (UInt32Value)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> rfe.</para>
    /// <para>Represents the following attribute in the schema: rfe </para>
    /// </summary>
    [SchemaAttr(0, "rfe")]
    public UInt32Value Rfe
    {
        get { return (UInt32Value)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> rff.</para>
    /// <para>Represents the following attribute in the schema: rff </para>
    /// </summary>
    [SchemaAttr(0, "rff")]
    public UInt32Value Rff
    {
        get { return (UInt32Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DrawingHeaderFooter class.
    /// </summary>
    public DrawingHeaderFooter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    
if( 0 == namespaceId && "lho" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "lhe" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "lhf" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cho" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "che" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "chf" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rho" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rhe" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rhf" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "lfo" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "lfe" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "lff" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cfo" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cfe" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cff" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rfo" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rfe" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rff" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DrawingHeaderFooter>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Picture Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:picture.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Picture : OpenXmlLeafElement
{
    private const string tagName = "picture";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11396;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "id" };
    private static byte[] attributeNamespaceIds = { 19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Picture class.
    /// </summary>
    public Picture():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Picture>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WebPublishItems Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPublishItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WebPublishItem &lt;x:webPublishItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WebPublishItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPublishItems : OpenXmlCompositeElement
{
    private const string tagName = "webPublishItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11397;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Web Publishing Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPublishItems class.
    /// </summary>
    public WebPublishItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WebPublishItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebPublishItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WebPublishItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebPublishItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WebPublishItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WebPublishItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "webPublishItem" == name)
    return new WebPublishItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPublishItems>(deep);
    }

   
}
/// <summary>
/// <para>Color Scale.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colorScale.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatValueObject &lt;x:cfvo></description></item>
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatValueObject))]
    [ChildElementInfo(typeof(Color))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorScale : OpenXmlCompositeElement
{
    private const string tagName = "colorScale";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11398;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ColorScale class.
    /// </summary>
    public ColorScale():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColorScale class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorScale(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorScale class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColorScale(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColorScale class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColorScale(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cfvo" == name)
    return new ConditionalFormatValueObject();
    
if( 22 == namespaceId && "color" == name)
    return new Color();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorScale>(deep);
    }

   
}
/// <summary>
/// <para>Data Bar.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataBar.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatValueObject &lt;x:cfvo></description></item>
///<item><description>Color &lt;x:color></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatValueObject))]
    [ChildElementInfo(typeof(Color))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataBar : OpenXmlCompositeElement
{
    private const string tagName = "dataBar";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11399;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "minLength","maxLength","showValue" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Minimum Length.</para>
    /// <para>Represents the following attribute in the schema: minLength </para>
    /// </summary>
    [SchemaAttr(0, "minLength")]
    public UInt32Value MinLength
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Length.</para>
    /// <para>Represents the following attribute in the schema: maxLength </para>
    /// </summary>
    [SchemaAttr(0, "maxLength")]
    public UInt32Value MaxLength
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Values.</para>
    /// <para>Represents the following attribute in the schema: showValue </para>
    /// </summary>
    [SchemaAttr(0, "showValue")]
    public BooleanValue ShowValue
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataBar class.
    /// </summary>
    public DataBar():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataBar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataBar(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataBar class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataBar(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataBar class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataBar(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cfvo" == name)
    return new ConditionalFormatValueObject();
    
if( 22 == namespaceId && "color" == name)
    return new Color();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "minLength" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "maxLength" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "showValue" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataBar>(deep);
    }

   
}
/// <summary>
/// <para>Icon Set.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:iconSet.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormatValueObject &lt;x:cfvo></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormatValueObject))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IconSet : OpenXmlCompositeElement
{
    private const string tagName = "iconSet";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11400;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "iconSet","showValue","percent","reverse" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Icon Set.</para>
    /// <para>Represents the following attribute in the schema: iconSet </para>
    /// </summary>
    [SchemaAttr(0, "iconSet")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues> IconSetValue
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show Value.</para>
    /// <para>Represents the following attribute in the schema: showValue </para>
    /// </summary>
    [SchemaAttr(0, "showValue")]
    public BooleanValue ShowValue
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Percent.</para>
    /// <para>Represents the following attribute in the schema: percent </para>
    /// </summary>
    [SchemaAttr(0, "percent")]
    public BooleanValue Percent
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Reverse Icons.</para>
    /// <para>Represents the following attribute in the schema: reverse </para>
    /// </summary>
    [SchemaAttr(0, "reverse")]
    public BooleanValue Reverse
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the IconSet class.
    /// </summary>
    public IconSet():base(){}
    
            /// <summary>
    ///Initializes a new instance of the IconSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IconSet(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the IconSet class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IconSet(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the IconSet class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public IconSet(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cfvo" == name)
    return new ConditionalFormatValueObject();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "iconSet" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>();
    
if( 0 == namespaceId && "showValue" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "percent" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "reverse" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IconSet>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConditionalFormattingRuleExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormattingRuleExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormattingRuleExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormattingRuleExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11401;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class.
    /// </summary>
    public ConditionalFormattingRuleExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormattingRuleExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRuleExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormattingRuleExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormattingRuleExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormattingRuleExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new ConditionalFormattingRuleExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormattingRuleExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Data Consolidation References.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataRefs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataReference &lt;x:dataRef></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataReferences : OpenXmlCompositeElement
{
    private const string tagName = "dataRefs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11402;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Data Consolidation Reference Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataReferences class.
    /// </summary>
    public DataReferences():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataReferences(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataReferences(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataReferences class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataReferences(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dataRef" == name)
    return new DataReference();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataReferences>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TabColor &lt;x:tabColor></description></item>
///<item><description>OutlineProperties &lt;x:outlinePr></description></item>
///<item><description>PageSetupProperties &lt;x:pageSetUpPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TabColor))]
    [ChildElementInfo(typeof(OutlineProperties))]
    [ChildElementInfo(typeof(PageSetupProperties))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetProperties : OpenXmlCompositeElement
{
    private const string tagName = "sheetPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11404;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "syncHorizontal","syncVertical","syncRef","transitionEvaluation","transitionEntry","published","codeName","filterMode","enableFormatConditionsCalculation" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Synch Horizontal.</para>
    /// <para>Represents the following attribute in the schema: syncHorizontal </para>
    /// </summary>
    [SchemaAttr(0, "syncHorizontal")]
    public BooleanValue SyncHorizontal
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Synch Vertical.</para>
    /// <para>Represents the following attribute in the schema: syncVertical </para>
    /// </summary>
    [SchemaAttr(0, "syncVertical")]
    public BooleanValue SyncVertical
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Synch Reference.</para>
    /// <para>Represents the following attribute in the schema: syncRef </para>
    /// </summary>
    [SchemaAttr(0, "syncRef")]
    public StringValue SyncReference
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Transition Formula Evaluation.</para>
    /// <para>Represents the following attribute in the schema: transitionEvaluation </para>
    /// </summary>
    [SchemaAttr(0, "transitionEvaluation")]
    public BooleanValue TransitionEvaluation
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Transition Formula Entry.</para>
    /// <para>Represents the following attribute in the schema: transitionEntry </para>
    /// </summary>
    [SchemaAttr(0, "transitionEntry")]
    public BooleanValue TransitionEntry
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Published.</para>
    /// <para>Represents the following attribute in the schema: published </para>
    /// </summary>
    [SchemaAttr(0, "published")]
    public BooleanValue Published
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Code Name.</para>
    /// <para>Represents the following attribute in the schema: codeName </para>
    /// </summary>
    [SchemaAttr(0, "codeName")]
    public StringValue CodeName
    {
        get { return (StringValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Filter Mode.</para>
    /// <para>Represents the following attribute in the schema: filterMode </para>
    /// </summary>
    [SchemaAttr(0, "filterMode")]
    public BooleanValue FilterMode
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Enable Conditional Formatting Calculations.</para>
    /// <para>Represents the following attribute in the schema: enableFormatConditionsCalculation </para>
    /// </summary>
    [SchemaAttr(0, "enableFormatConditionsCalculation")]
    public BooleanValue EnableFormatConditionsCalculation
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetProperties class.
    /// </summary>
    public SheetProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tabColor" == name)
    return new TabColor();
    
if( 22 == namespaceId && "outlinePr" == name)
    return new OutlineProperties();
    
if( 22 == namespaceId && "pageSetUpPr" == name)
    return new PageSetupProperties();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tabColor","outlinePr","pageSetUpPr" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Sheet Tab Color.</para>
    /// <para> Represents the following element tag in the schema: x:tabColor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TabColor TabColor
    {
        get 
        {
            return GetElement<TabColor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Outline Properties.</para>
    /// <para> Represents the following element tag in the schema: x:outlinePr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public OutlineProperties OutlineProperties
    {
        get 
        {
            return GetElement<OutlineProperties>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Page Setup Properties.</para>
    /// <para> Represents the following element tag in the schema: x:pageSetUpPr </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PageSetupProperties PageSetupProperties
    {
        get 
        {
            return GetElement<PageSetupProperties>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "syncHorizontal" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "syncVertical" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "syncRef" == name)
    return new StringValue();
    
if( 0 == namespaceId && "transitionEvaluation" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "transitionEntry" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "published" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "codeName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "filterMode" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "enableFormatConditionsCalculation" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetProperties>(deep);
    }

   
}
/// <summary>
/// <para>Dialog Sheet Views.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>SheetView &lt;x:sheetView></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(SheetView))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetViews : OpenXmlCompositeElement
{
    private const string tagName = "sheetViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11405;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SheetViews class.
    /// </summary>
    public SheetViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheetView" == name)
    return new SheetView();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetViews>(deep);
    }

   
}
/// <summary>
/// <para>Dialog Sheet Format Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetFormatPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetFormatProperties : OpenXmlLeafElement
{
    private const string tagName = "sheetFormatPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11406;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "baseColWidth","defaultColWidth","defaultRowHeight","customHeight","zeroHeight","thickTop","thickBottom","outlineLevelRow","outlineLevelCol","dyDescent" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,55 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Base Column Width.</para>
    /// <para>Represents the following attribute in the schema: baseColWidth </para>
    /// </summary>
    [SchemaAttr(0, "baseColWidth")]
    public UInt32Value BaseColumnWidth
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Default Column Width.</para>
    /// <para>Represents the following attribute in the schema: defaultColWidth </para>
    /// </summary>
    [SchemaAttr(0, "defaultColWidth")]
    public DoubleValue DefaultColumnWidth
    {
        get { return (DoubleValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Default Row Height.</para>
    /// <para>Represents the following attribute in the schema: defaultRowHeight </para>
    /// </summary>
    [SchemaAttr(0, "defaultRowHeight")]
    public DoubleValue DefaultRowHeight
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Custom Height.</para>
    /// <para>Represents the following attribute in the schema: customHeight </para>
    /// </summary>
    [SchemaAttr(0, "customHeight")]
    public BooleanValue CustomHeight
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Hidden By Default.</para>
    /// <para>Represents the following attribute in the schema: zeroHeight </para>
    /// </summary>
    [SchemaAttr(0, "zeroHeight")]
    public BooleanValue ZeroHeight
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Thick Top Border.</para>
    /// <para>Represents the following attribute in the schema: thickTop </para>
    /// </summary>
    [SchemaAttr(0, "thickTop")]
    public BooleanValue ThickTop
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Thick Bottom Border.</para>
    /// <para>Represents the following attribute in the schema: thickBottom </para>
    /// </summary>
    [SchemaAttr(0, "thickBottom")]
    public BooleanValue ThickBottom
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Outline Row.</para>
    /// <para>Represents the following attribute in the schema: outlineLevelRow </para>
    /// </summary>
    [SchemaAttr(0, "outlineLevelRow")]
    public ByteValue OutlineLevelRow
    {
        get { return (ByteValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Column Outline Level.</para>
    /// <para>Represents the following attribute in the schema: outlineLevelCol </para>
    /// </summary>
    [SchemaAttr(0, "outlineLevelCol")]
    public ByteValue OutlineLevelColumn
    {
        get { return (ByteValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> dyDescent.</para>
    /// <para>Represents the following attribute in the schema: x14ac:dyDescent </para>
    /// </summary>
///<remark> xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
///</remark>
    [SchemaAttr(55, "dyDescent")]
    public DoubleValue DyDescent
    {
        get { return (DoubleValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetFormatProperties class.
    /// </summary>
    public SheetFormatProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "baseColWidth" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "defaultColWidth" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "defaultRowHeight" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "customHeight" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "zeroHeight" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "thickTop" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "thickBottom" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "outlineLevelRow" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "outlineLevelCol" == name)
    return new ByteValue();
    
if( 55 == namespaceId && "dyDescent" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetFormatProperties>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Protection.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetProtection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetProtection : OpenXmlLeafElement
{
    private const string tagName = "sheetProtection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11407;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "password","algorithmName","hashValue","saltValue","spinCount","sheet","objects","scenarios","formatCells","formatColumns","formatRows","insertColumns","insertRows","insertHyperlinks","deleteColumns","deleteRows","selectLockedCells","sort","autoFilter","pivotTables","selectUnlockedCells" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Password.</para>
    /// <para>Represents the following attribute in the schema: password </para>
    /// </summary>
    [SchemaAttr(0, "password")]
    public HexBinaryValue Password
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Name.</para>
    /// <para>Represents the following attribute in the schema: algorithmName </para>
    /// </summary>
    [SchemaAttr(0, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash Value.</para>
    /// <para>Represents the following attribute in the schema: hashValue </para>
    /// </summary>
    [SchemaAttr(0, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Salt Value for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: saltValue </para>
    /// </summary>
    [SchemaAttr(0, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: spinCount </para>
    /// </summary>
    [SchemaAttr(0, "spinCount")]
    public UInt32Value SpinCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Locked.</para>
    /// <para>Represents the following attribute in the schema: sheet </para>
    /// </summary>
    [SchemaAttr(0, "sheet")]
    public BooleanValue Sheet
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Objects Locked.</para>
    /// <para>Represents the following attribute in the schema: objects </para>
    /// </summary>
    [SchemaAttr(0, "objects")]
    public BooleanValue Objects
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Scenarios Locked.</para>
    /// <para>Represents the following attribute in the schema: scenarios </para>
    /// </summary>
    [SchemaAttr(0, "scenarios")]
    public BooleanValue Scenarios
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Format Cells Locked.</para>
    /// <para>Represents the following attribute in the schema: formatCells </para>
    /// </summary>
    [SchemaAttr(0, "formatCells")]
    public BooleanValue FormatCells
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Format Columns Locked.</para>
    /// <para>Represents the following attribute in the schema: formatColumns </para>
    /// </summary>
    [SchemaAttr(0, "formatColumns")]
    public BooleanValue FormatColumns
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Format Rows Locked.</para>
    /// <para>Represents the following attribute in the schema: formatRows </para>
    /// </summary>
    [SchemaAttr(0, "formatRows")]
    public BooleanValue FormatRows
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Insert Columns Locked.</para>
    /// <para>Represents the following attribute in the schema: insertColumns </para>
    /// </summary>
    [SchemaAttr(0, "insertColumns")]
    public BooleanValue InsertColumns
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Insert Rows Locked.</para>
    /// <para>Represents the following attribute in the schema: insertRows </para>
    /// </summary>
    [SchemaAttr(0, "insertRows")]
    public BooleanValue InsertRows
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Insert Hyperlinks Locked.</para>
    /// <para>Represents the following attribute in the schema: insertHyperlinks </para>
    /// </summary>
    [SchemaAttr(0, "insertHyperlinks")]
    public BooleanValue InsertHyperlinks
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Delete Columns Locked.</para>
    /// <para>Represents the following attribute in the schema: deleteColumns </para>
    /// </summary>
    [SchemaAttr(0, "deleteColumns")]
    public BooleanValue DeleteColumns
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Delete Rows Locked.</para>
    /// <para>Represents the following attribute in the schema: deleteRows </para>
    /// </summary>
    [SchemaAttr(0, "deleteRows")]
    public BooleanValue DeleteRows
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Select Locked Cells Locked.</para>
    /// <para>Represents the following attribute in the schema: selectLockedCells </para>
    /// </summary>
    [SchemaAttr(0, "selectLockedCells")]
    public BooleanValue SelectLockedCells
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Sort Locked.</para>
    /// <para>Represents the following attribute in the schema: sort </para>
    /// </summary>
    [SchemaAttr(0, "sort")]
    public BooleanValue Sort
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> AutoFilter Locked.</para>
    /// <para>Represents the following attribute in the schema: autoFilter </para>
    /// </summary>
    [SchemaAttr(0, "autoFilter")]
    public BooleanValue AutoFilter
    {
        get { return (BooleanValue)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    
    /// <summary>
    /// <para> Pivot Tables Locked.</para>
    /// <para>Represents the following attribute in the schema: pivotTables </para>
    /// </summary>
    [SchemaAttr(0, "pivotTables")]
    public BooleanValue PivotTables
    {
        get { return (BooleanValue)Attributes[19]; }
        set { Attributes[19] = value; }
    }
    
    /// <summary>
    /// <para> Select Unlocked Cells Locked.</para>
    /// <para>Represents the following attribute in the schema: selectUnlockedCells </para>
    /// </summary>
    [SchemaAttr(0, "selectUnlockedCells")]
    public BooleanValue SelectUnlockedCells
    {
        get { return (BooleanValue)Attributes[20]; }
        set { Attributes[20] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetProtection class.
    /// </summary>
    public SheetProtection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "password" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "spinCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sheet" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "objects" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "scenarios" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "formatCells" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "formatColumns" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "formatRows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertColumns" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertRows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "insertHyperlinks" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "deleteColumns" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "deleteRows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "selectLockedCells" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sort" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "pivotTables" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "selectUnlockedCells" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetProtection>(deep);
    }

   
}
/// <summary>
/// <para>Custom Sheet Views.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customSheetViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomSheetView &lt;x:customSheetView></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomSheetView))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomSheetViews : OpenXmlCompositeElement
{
    private const string tagName = "customSheetViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11408;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomSheetViews class.
    /// </summary>
    public CustomSheetViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomSheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomSheetViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomSheetViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomSheetViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomSheetViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomSheetViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "customSheetView" == name)
    return new CustomSheetView();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomSheetViews>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OleObjects Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleObjects.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>OleObject &lt;x:oleObject></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(OleObject))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleObjects : OpenXmlCompositeElement
{
    private const string tagName = "oleObjects";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11409;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the OleObjects class.
    /// </summary>
    public OleObjects():base(){}
    
            /// <summary>
    ///Initializes a new instance of the OleObjects class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleObjects(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the OleObjects class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public OleObjects(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the OleObjects class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public OleObjects(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "oleObject" == name)
    return new OleObject();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleObjects>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Controls Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:controls.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Control &lt;x:control></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Control))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Controls : OpenXmlCompositeElement
{
    private const string tagName = "controls";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11410;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Controls class.
    /// </summary>
    public Controls():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Controls class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Controls(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Controls class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Controls(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Controls class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Controls(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "control" == name)
    return new Control();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Controls>(deep);
    }

   
}
/// <summary>
/// <para>Macro Sheet Dimensions.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dimension.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetDimension : OpenXmlLeafElement
{
    private const string tagName = "dimension";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11411;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetDimension class.
    /// </summary>
    public SheetDimension():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetDimension>(deep);
    }

   
}
/// <summary>
/// <para>Column Information.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cols.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Column &lt;x:col></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Column))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Columns : OpenXmlCompositeElement
{
    private const string tagName = "cols";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11412;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Columns class.
    /// </summary>
    public Columns():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Columns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Columns(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Columns class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Columns(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Columns class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Columns(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "col" == name)
    return new Column();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Columns>(deep);
    }

   
}
/// <summary>
/// <para>Sheet Data.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetData.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Row &lt;x:row></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Row))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetData : OpenXmlCompositeElement
{
    private const string tagName = "sheetData";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11413;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the SheetData class.
    /// </summary>
    public SheetData():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SheetData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetData(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetData class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SheetData(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SheetData class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SheetData(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "row" == name)
    return new Row();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetData>(deep);
    }

   
}
/// <summary>
/// <para>Data Consolidation.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataConsolidate.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataReferences &lt;x:dataRefs></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataReferences))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataConsolidate : OpenXmlCompositeElement
{
    private const string tagName = "dataConsolidate";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11414;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "function","leftLabels","startLabels","topLabels","link" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Function Index.</para>
    /// <para>Represents the following attribute in the schema: function </para>
    /// </summary>
    [SchemaAttr(0, "function")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues> Function
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Use Left Column Labels.</para>
    /// <para>Represents the following attribute in the schema: leftLabels </para>
    /// </summary>
    [SchemaAttr(0, "leftLabels")]
    public BooleanValue LeftLabels
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> startLabels.</para>
    /// <para>Represents the following attribute in the schema: startLabels </para>
    /// </summary>
    [SchemaAttr(0, "startLabels")]
    public BooleanValue StartLabels
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Labels In Top Row.</para>
    /// <para>Represents the following attribute in the schema: topLabels </para>
    /// </summary>
    [SchemaAttr(0, "topLabels")]
    public BooleanValue TopLabels
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Link.</para>
    /// <para>Represents the following attribute in the schema: link </para>
    /// </summary>
    [SchemaAttr(0, "link")]
    public BooleanValue Link
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataConsolidate class.
    /// </summary>
    public DataConsolidate():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataConsolidate class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataConsolidate(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataConsolidate class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataConsolidate(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataConsolidate class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataConsolidate(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dataRefs" == name)
    return new DataReferences();
    

    return null;
}

        private static readonly string[] eleTagNames = { "dataRefs" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Data Consolidation References.</para>
    /// <para> Represents the following element tag in the schema: x:dataRefs </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public DataReferences DataReferences
    {
        get 
        {
            return GetElement<DataReferences>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "function" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DataConsolidateFunctionValues>();
    
if( 0 == namespaceId && "leftLabels" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "startLabels" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "topLabels" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "link" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataConsolidate>(deep);
    }

   
}
/// <summary>
/// <para>Conditional Formatting.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:conditionalFormatting.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormattingRule &lt;x:cfRule></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormattingRule))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormatting : OpenXmlCompositeElement
{
    private const string tagName = "conditionalFormatting";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11415;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "pivot","sqref" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> PivotTable Conditional Formatting.</para>
    /// <para>Represents the following attribute in the schema: pivot </para>
    /// </summary>
    [SchemaAttr(0, "pivot")]
    public BooleanValue Pivot
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sequence of Refernces.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormatting class.
    /// </summary>
    public ConditionalFormatting():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormatting class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormatting(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormatting class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormatting(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormatting class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormatting(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cfRule" == name)
    return new ConditionalFormattingRule();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "pivot" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormatting>(deep);
    }

   
}
/// <summary>
/// <para>Custom Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customProperties.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomProperty &lt;x:customPr></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomProperty))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomProperties : OpenXmlCompositeElement
{
    private const string tagName = "customProperties";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11416;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomProperties class.
    /// </summary>
    public CustomProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "customPr" == name)
    return new CustomProperty();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomProperties>(deep);
    }

   
}
/// <summary>
/// <para>OLAP Member Properties.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mps.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MemberProperty &lt;x:mp></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MemberProperty))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MemberProperties : OpenXmlCompositeElement
{
    private const string tagName = "mps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11417;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLAP Member Properties Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MemberProperties class.
    /// </summary>
    public MemberProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MemberProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MemberProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MemberProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MemberProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MemberProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MemberProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "mp" == name)
    return new MemberProperty();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MemberProperties>(deep);
    }

   
}
/// <summary>
/// <para>Members.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:members.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Member &lt;x:member></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Member))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Members : OpenXmlCompositeElement
{
    private const string tagName = "members";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11418;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count","level" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Hierarchy Level.</para>
    /// <para>Represents the following attribute in the schema: level </para>
    /// </summary>
    [SchemaAttr(0, "level")]
    public UInt32Value Level
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Members class.
    /// </summary>
    public Members():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Members class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Members(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Members class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Members(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Members class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Members(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "member" == name)
    return new Member();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "level" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Members>(deep);
    }

   
}
/// <summary>
/// <para>Future Feature Data Storage Area.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotHierarchyExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotHierarchyExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotHierarchyExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11419;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtensionList class.
    /// </summary>
    public PivotHierarchyExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotHierarchyExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchyExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchyExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchyExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotHierarchyExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new PivotHierarchyExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotHierarchyExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Field Items.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:items.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Item &lt;x:item></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Item))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Items : OpenXmlCompositeElement
{
    private const string tagName = "items";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11420;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Items class.
    /// </summary>
    public Items():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Items class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Items(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Items class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Items(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Items class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Items(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "item" == name)
    return new Item();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Items>(deep);
    }

   
}
/// <summary>
/// <para>AutoSort Scope.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:autoSortScope.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotArea &lt;x:pivotArea></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotArea))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class AutoSortScope : OpenXmlCompositeElement
{
    private const string tagName = "autoSortScope";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11421;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the AutoSortScope class.
    /// </summary>
    public AutoSortScope():base(){}
    
            /// <summary>
    ///Initializes a new instance of the AutoSortScope class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoSortScope(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoSortScope class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public AutoSortScope(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the AutoSortScope class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public AutoSortScope(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotArea" == name)
    return new PivotArea();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pivotArea" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Auto Sort Scope.</para>
    /// <para> Represents the following element tag in the schema: x:pivotArea </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public PivotArea PivotArea
    {
        get 
        {
            return GetElement<PivotArea>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<AutoSortScope>(deep);
    }

   
}
/// <summary>
/// <para>Future Feature Data Storage Area.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotFieldExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotFieldExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFieldExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11422;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotFieldExtensionList class.
    /// </summary>
    public PivotFieldExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFieldExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFieldExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFieldExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new PivotFieldExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFieldExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorksheetSource Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:worksheetSource.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorksheetSource : OpenXmlLeafElement
{
    private const string tagName = "worksheetSource";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11423;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref","name","sheet","id" };
    private static byte[] attributeNamespaceIds = { 0,0,0,19 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Named Range.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Sheet Name.</para>
    /// <para>Represents the following attribute in the schema: sheet </para>
    /// </summary>
    [SchemaAttr(0, "sheet")]
    public StringValue Sheet
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Relationship Id.</para>
    /// <para>Represents the following attribute in the schema: r:id </para>
    /// </summary>
///<remark> xmlns:r=http://schemas.openxmlformats.org/officeDocument/2006/relationships
///</remark>
    [SchemaAttr(19, "id")]
    public StringValue Id
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorksheetSource class.
    /// </summary>
    public WorksheetSource():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "sheet" == name)
    return new StringValue();
    
if( 19 == namespaceId && "id" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorksheetSource>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Consolidation Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:consolidation.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Pages &lt;x:pages></description></item>
///<item><description>RangeSets &lt;x:rangeSets></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Pages))]
    [ChildElementInfo(typeof(RangeSets))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Consolidation : OpenXmlCompositeElement
{
    private const string tagName = "consolidation";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11424;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "autoPage" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Auto Page.</para>
    /// <para>Represents the following attribute in the schema: autoPage </para>
    /// </summary>
    [SchemaAttr(0, "autoPage")]
    public BooleanValue AutoPage
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Consolidation class.
    /// </summary>
    public Consolidation():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Consolidation class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Consolidation(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Consolidation class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Consolidation(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Consolidation class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Consolidation(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pages" == name)
    return new Pages();
    
if( 22 == namespaceId && "rangeSets" == name)
    return new RangeSets();
    

    return null;
}

        private static readonly string[] eleTagNames = { "pages","rangeSets" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Page Item Values.</para>
    /// <para> Represents the following element tag in the schema: x:pages </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Pages Pages
    {
        get 
        {
            return GetElement<Pages>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Range Sets.</para>
    /// <para> Represents the following element tag in the schema: x:rangeSets </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public RangeSets RangeSets
    {
        get 
        {
            return GetElement<RangeSets>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "autoPage" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Consolidation>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheSourceExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheSourceExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheSourceExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheSourceExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11425;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CacheSourceExtensionList class.
    /// </summary>
    public CacheSourceExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheSourceExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSourceExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSourceExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSourceExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSourceExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheSourceExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new CacheSourceExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheSourceExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CommentProperties Class.</para>
///<para>This class is available in Office 2010 or above.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:commentPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ObjectAnchor &lt;x:anchor></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ObjectAnchor),(FileFormatVersions)14)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
[OfficeAvailability(FileFormatVersions.Office2010)]
public partial class CommentProperties : OpenXmlCompositeElement
{
    private const string tagName = "commentPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11427;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((14 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "locked","defaultSize","print","disabled","uiObject","autoFill","autoLine","altText","textHAlign","textVAlign","lockText","justLastX","autoScale","rowHidden","colHidden" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> locked.</para>
    /// <para>Represents the following attribute in the schema: locked </para>
    /// </summary>
    [SchemaAttr(0, "locked")]
    public BooleanValue Locked
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> defaultSize.</para>
    /// <para>Represents the following attribute in the schema: defaultSize </para>
    /// </summary>
    [SchemaAttr(0, "defaultSize")]
    public BooleanValue DefaultSize
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> print.</para>
    /// <para>Represents the following attribute in the schema: print </para>
    /// </summary>
    [SchemaAttr(0, "print")]
    public BooleanValue Print
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> disabled.</para>
    /// <para>Represents the following attribute in the schema: disabled </para>
    /// </summary>
    [SchemaAttr(0, "disabled")]
    public BooleanValue Disabled
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> uiObject.</para>
    /// <para>Represents the following attribute in the schema: uiObject </para>
    /// </summary>
    [SchemaAttr(0, "uiObject")]
    public BooleanValue UiObject
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> autoFill.</para>
    /// <para>Represents the following attribute in the schema: autoFill </para>
    /// </summary>
    [SchemaAttr(0, "autoFill")]
    public BooleanValue AutoFill
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> autoLine.</para>
    /// <para>Represents the following attribute in the schema: autoLine </para>
    /// </summary>
    [SchemaAttr(0, "autoLine")]
    public BooleanValue AutoLine
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> altText.</para>
    /// <para>Represents the following attribute in the schema: altText </para>
    /// </summary>
    [SchemaAttr(0, "altText")]
    public StringValue AltText
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> textHAlign.</para>
    /// <para>Represents the following attribute in the schema: textHAlign </para>
    /// </summary>
    [SchemaAttr(0, "textHAlign")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextHorizontalAlignmentValues> TextHAlign
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextHorizontalAlignmentValues>)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> textVAlign.</para>
    /// <para>Represents the following attribute in the schema: textVAlign </para>
    /// </summary>
    [SchemaAttr(0, "textVAlign")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextVerticalAlignmentValues> TextVAlign
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextVerticalAlignmentValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> lockText.</para>
    /// <para>Represents the following attribute in the schema: lockText </para>
    /// </summary>
    [SchemaAttr(0, "lockText")]
    public BooleanValue LockText
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> justLastX.</para>
    /// <para>Represents the following attribute in the schema: justLastX </para>
    /// </summary>
    [SchemaAttr(0, "justLastX")]
    public BooleanValue JustLastX
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> autoScale.</para>
    /// <para>Represents the following attribute in the schema: autoScale </para>
    /// </summary>
    [SchemaAttr(0, "autoScale")]
    public BooleanValue AutoScale
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> rowHidden.</para>
    /// <para>Represents the following attribute in the schema: rowHidden </para>
    /// </summary>
    [SchemaAttr(0, "rowHidden")]
    public BooleanValue RowHidden
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> colHidden.</para>
    /// <para>Represents the following attribute in the schema: colHidden </para>
    /// </summary>
    [SchemaAttr(0, "colHidden")]
    public BooleanValue ColHidden
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CommentProperties class.
    /// </summary>
    public CommentProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CommentProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CommentProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CommentProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CommentProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "anchor" == name)
    return new ObjectAnchor();
    

    return null;
}

        private static readonly string[] eleTagNames = { "anchor" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> ObjectAnchor.</para>
    /// <para> Represents the following element tag in the schema: x:anchor </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ObjectAnchor ObjectAnchor
    {
        get 
        {
            return GetElement<ObjectAnchor>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "locked" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultSize" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "print" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "disabled" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "uiObject" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoFill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoLine" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "altText" == name)
    return new StringValue();
    
if( 0 == namespaceId && "textHAlign" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextHorizontalAlignmentValues>();
    
if( 0 == namespaceId && "textVAlign" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TextVerticalAlignmentValues>();
    
if( 0 == namespaceId && "lockText" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "justLastX" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoScale" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowHidden" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "colHidden" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CommentProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SortCondition Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sortCondition.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SortCondition : OpenXmlLeafElement
{
    private const string tagName = "sortCondition";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11428;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "descending","sortBy","ref","customList","dxfId","iconSet","iconId" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Descending.</para>
    /// <para>Represents the following attribute in the schema: descending </para>
    /// </summary>
    [SchemaAttr(0, "descending")]
    public BooleanValue Descending
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Sort By.</para>
    /// <para>Represents the following attribute in the schema: sortBy </para>
    /// </summary>
    [SchemaAttr(0, "sortBy")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortByValues> SortBy
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortByValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Custom List.</para>
    /// <para>Represents the following attribute in the schema: customList </para>
    /// </summary>
    [SchemaAttr(0, "customList")]
    public StringValue CustomList
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Format Id.</para>
    /// <para>Represents the following attribute in the schema: dxfId </para>
    /// </summary>
    [SchemaAttr(0, "dxfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Icon Set.</para>
    /// <para>Represents the following attribute in the schema: iconSet </para>
    /// </summary>
    [SchemaAttr(0, "iconSet")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues> IconSet
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Icon Id.</para>
    /// <para>Represents the following attribute in the schema: iconId </para>
    /// </summary>
    [SchemaAttr(0, "iconId")]
    public UInt32Value IconId
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SortCondition class.
    /// </summary>
    public SortCondition():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "descending" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sortBy" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SortByValues>();
    
if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "customList" == name)
    return new StringValue();
    
if( 0 == namespaceId && "dxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iconSet" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>();
    
if( 0 == namespaceId && "iconId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SortCondition>(deep);
    }

   
}
/// <summary>
/// <para>Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:filter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Filter : OpenXmlLeafElement
{
    private const string tagName = "filter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11429;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "val" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Filter Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public StringValue Val
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Filter class.
    /// </summary>
    public Filter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "val" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Filter>(deep);
    }

   
}
/// <summary>
/// <para>Date Grouping.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dateGroupItem.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DateGroupItem : OpenXmlLeafElement
{
    private const string tagName = "dateGroupItem";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11430;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "year","month","day","hour","minute","second","dateTimeGrouping" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Year.</para>
    /// <para>Represents the following attribute in the schema: year </para>
    /// </summary>
    [SchemaAttr(0, "year")]
    public UInt16Value Year
    {
        get { return (UInt16Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Month.</para>
    /// <para>Represents the following attribute in the schema: month </para>
    /// </summary>
    [SchemaAttr(0, "month")]
    public UInt16Value Month
    {
        get { return (UInt16Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Day.</para>
    /// <para>Represents the following attribute in the schema: day </para>
    /// </summary>
    [SchemaAttr(0, "day")]
    public UInt16Value Day
    {
        get { return (UInt16Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Hour.</para>
    /// <para>Represents the following attribute in the schema: hour </para>
    /// </summary>
    [SchemaAttr(0, "hour")]
    public UInt16Value Hour
    {
        get { return (UInt16Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Minute.</para>
    /// <para>Represents the following attribute in the schema: minute </para>
    /// </summary>
    [SchemaAttr(0, "minute")]
    public UInt16Value Minute
    {
        get { return (UInt16Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Second.</para>
    /// <para>Represents the following attribute in the schema: second </para>
    /// </summary>
    [SchemaAttr(0, "second")]
    public UInt16Value Second
    {
        get { return (UInt16Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Date Time Grouping.</para>
    /// <para>Represents the following attribute in the schema: dateTimeGrouping </para>
    /// </summary>
    [SchemaAttr(0, "dateTimeGrouping")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DateTimeGroupingValues> DateTimeGrouping
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DateTimeGroupingValues>)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DateGroupItem class.
    /// </summary>
    public DateGroupItem():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "year" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "month" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "day" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "hour" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "minute" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "second" == name)
    return new UInt16Value();
    
if( 0 == namespaceId && "dateTimeGrouping" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DateTimeGroupingValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DateGroupItem>(deep);
    }

   
}
/// <summary>
/// <para>Filter Criteria.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:filters.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.Filter &lt;x14:filter></description></item>
///<item><description>Filter &lt;x:filter></description></item>
///<item><description>DateGroupItem &lt;x:dateGroupItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.Filter),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(Filter))]
    [ChildElementInfo(typeof(DateGroupItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Filters : OpenXmlCompositeElement
{
    private const string tagName = "filters";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11431;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "blank","calendarType" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Filter by Blank.</para>
    /// <para>Represents the following attribute in the schema: blank </para>
    /// </summary>
    [SchemaAttr(0, "blank")]
    public BooleanValue Blank
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Calendar Type.</para>
    /// <para>Represents the following attribute in the schema: calendarType </para>
    /// </summary>
    [SchemaAttr(0, "calendarType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalendarValues> CalendarType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalendarValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Filters class.
    /// </summary>
    public Filters():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Filters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Filters(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Filters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Filters(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Filters class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Filters(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "filter" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.Filter();
    
if( 22 == namespaceId && "filter" == name)
    return new Filter();
    
if( 22 == namespaceId && "dateGroupItem" == name)
    return new DateGroupItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "blank" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "calendarType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalendarValues>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Filters>(deep);
    }

   
}
/// <summary>
/// <para>Top 10.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:top10.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Top10 : OpenXmlLeafElement
{
    private const string tagName = "top10";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11432;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "top","percent","val","filterVal" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Top.</para>
    /// <para>Represents the following attribute in the schema: top </para>
    /// </summary>
    [SchemaAttr(0, "top")]
    public BooleanValue Top
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Filter by Percent.</para>
    /// <para>Represents the following attribute in the schema: percent </para>
    /// </summary>
    [SchemaAttr(0, "percent")]
    public BooleanValue Percent
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Top or Bottom Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public DoubleValue Val
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Filter Value.</para>
    /// <para>Represents the following attribute in the schema: filterVal </para>
    /// </summary>
    [SchemaAttr(0, "filterVal")]
    public DoubleValue FilterValue
    {
        get { return (DoubleValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Top10 class.
    /// </summary>
    public Top10():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "top" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "percent" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "val" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "filterVal" == name)
    return new DoubleValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Top10>(deep);
    }

   
}
/// <summary>
/// <para>Custom Filters.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customFilters.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomFilter &lt;x:customFilter></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomFilter))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomFilters : OpenXmlCompositeElement
{
    private const string tagName = "customFilters";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11433;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "and" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> And.</para>
    /// <para>Represents the following attribute in the schema: and </para>
    /// </summary>
    [SchemaAttr(0, "and")]
    public BooleanValue And
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CustomFilters class.
    /// </summary>
    public CustomFilters():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomFilters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomFilters(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomFilters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomFilters(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomFilters class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomFilters(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "customFilter" == name)
    return new CustomFilter();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "and" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomFilters>(deep);
    }

   
}
/// <summary>
/// <para>Dynamic Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dynamicFilter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DynamicFilter : OpenXmlLeafElement
{
    private const string tagName = "dynamicFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11434;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","val","maxVal","valIso","maxValIso" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Dynamic filter type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.DynamicFilterValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.DynamicFilterValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Value.</para>
    /// <para>Represents the following attribute in the schema: val </para>
    /// </summary>
    [SchemaAttr(0, "val")]
    public DoubleValue Val
    {
        get { return (DoubleValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Max Value.</para>
    /// <para>Represents the following attribute in the schema: maxVal </para>
    /// </summary>
    [SchemaAttr(0, "maxVal")]
    public DoubleValue MaxVal
    {
        get { return (DoubleValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> valIso.</para>
    /// <para>Represents the following attribute in the schema: valIso </para>
    /// </summary>
    [SchemaAttr(0, "valIso")]
    public DateTimeValue ValIso
    {
        get { return (DateTimeValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> maxValIso.</para>
    /// <para>Represents the following attribute in the schema: maxValIso </para>
    /// </summary>
    [SchemaAttr(0, "maxValIso")]
    public DateTimeValue MaxValIso
    {
        get { return (DateTimeValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DynamicFilter class.
    /// </summary>
    public DynamicFilter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.DynamicFilterValues>();
    
if( 0 == namespaceId && "val" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "maxVal" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "valIso" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "maxValIso" == name)
    return new DateTimeValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DynamicFilter>(deep);
    }

   
}
/// <summary>
/// <para>Color Filter Criteria.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colorFilter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColorFilter : OpenXmlLeafElement
{
    private const string tagName = "colorFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11435;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "dxfId","cellColor" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Differential Format Record Id.</para>
    /// <para>Represents the following attribute in the schema: dxfId </para>
    /// </summary>
    [SchemaAttr(0, "dxfId")]
    public UInt32Value FormatId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Filter By Cell Color.</para>
    /// <para>Represents the following attribute in the schema: cellColor </para>
    /// </summary>
    [SchemaAttr(0, "cellColor")]
    public BooleanValue CellColor
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColorFilter class.
    /// </summary>
    public ColorFilter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "dxfId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "cellColor" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColorFilter>(deep);
    }

   
}
/// <summary>
/// <para>Icon Filter.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:iconFilter.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IconFilter : OpenXmlLeafElement
{
    private const string tagName = "iconFilter";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11436;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "iconSet","iconId" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Icon Set.</para>
    /// <para>Represents the following attribute in the schema: iconSet </para>
    /// </summary>
    [SchemaAttr(0, "iconSet")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues> IconSet
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Icon Id.</para>
    /// <para>Represents the following attribute in the schema: iconId </para>
    /// </summary>
    [SchemaAttr(0, "iconId")]
    public UInt32Value IconId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the IconFilter class.
    /// </summary>
    public IconFilter():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "iconSet" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.IconSetValues>();
    
if( 0 == namespaceId && "iconId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IconFilter>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SlicerCacheDefinitionExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables &lt;x15:slicerCachePivotTables></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache &lt;x15:tableSlicerCache></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData &lt;x15:slicerCacheHideItemsWithNoData></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SlicerCacheDefinitionExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11437;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SlicerCacheDefinitionExtension class.
    /// </summary>
    public SlicerCacheDefinitionExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SlicerCacheDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SlicerCacheDefinitionExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SlicerCacheDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SlicerCacheDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SlicerCacheDefinitionExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SlicerCacheDefinitionExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 71 == namespaceId && "slicerCachePivotTables" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.SlicerCachePivotTables();
    
if( 71 == namespaceId && "tableSlicerCache" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TableSlicerCache();
    
if( 71 == namespaceId && "slicerCacheHideItemsWithNoData" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.SlicerCacheHideItemsWithNoData();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SlicerCacheDefinitionExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotFilterExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotFilter &lt;x15:pivotFilter></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState &lt;x15:movingPeriodState></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotFilter),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFilterExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11438;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotFilterExtension class.
    /// </summary>
    public PivotFilterExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFilterExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilterExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilterExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilterExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilterExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFilterExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 71 == namespaceId && "pivotFilter" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotFilter();
    
if( 71 == namespaceId && "movingPeriodState" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.MovingPeriodState();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFilterExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the QueryTableExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.QueryTable &lt;x15:queryTable></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.QueryTable),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11439;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryTableExtension class.
    /// </summary>
    public QueryTableExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 71 == namespaceId && "queryTable" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.QueryTable();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DatabaseProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dbPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DatabaseProperties : OpenXmlLeafElement
{
    private const string tagName = "dbPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11440;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "connection","command","serverCommand","commandType" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Connection String.</para>
    /// <para>Represents the following attribute in the schema: connection </para>
    /// </summary>
    [SchemaAttr(0, "connection")]
    public StringValue Connection
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Command Text.</para>
    /// <para>Represents the following attribute in the schema: command </para>
    /// </summary>
    [SchemaAttr(0, "command")]
    public StringValue Command
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Command Text.</para>
    /// <para>Represents the following attribute in the schema: serverCommand </para>
    /// </summary>
    [SchemaAttr(0, "serverCommand")]
    public StringValue ServerCommand
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> OLE DB Command Type.</para>
    /// <para>Represents the following attribute in the schema: commandType </para>
    /// </summary>
    [SchemaAttr(0, "commandType")]
    public UInt32Value CommandType
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DatabaseProperties class.
    /// </summary>
    public DatabaseProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "connection" == name)
    return new StringValue();
    
if( 0 == namespaceId && "command" == name)
    return new StringValue();
    
if( 0 == namespaceId && "serverCommand" == name)
    return new StringValue();
    
if( 0 == namespaceId && "commandType" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DatabaseProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OlapProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:olapPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OlapProperties : OpenXmlLeafElement
{
    private const string tagName = "olapPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11441;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "local","localConnection","localRefresh","sendLocale","rowDrillCount","serverFill","serverNumberFormat","serverFont","serverFontColor" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Local Cube.</para>
    /// <para>Represents the following attribute in the schema: local </para>
    /// </summary>
    [SchemaAttr(0, "local")]
    public BooleanValue Local
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Local Cube Connection.</para>
    /// <para>Represents the following attribute in the schema: localConnection </para>
    /// </summary>
    [SchemaAttr(0, "localConnection")]
    public StringValue LocalConnection
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Local Refresh.</para>
    /// <para>Represents the following attribute in the schema: localRefresh </para>
    /// </summary>
    [SchemaAttr(0, "localRefresh")]
    public BooleanValue LocalRefresh
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Send Locale to OLAP.</para>
    /// <para>Represents the following attribute in the schema: sendLocale </para>
    /// </summary>
    [SchemaAttr(0, "sendLocale")]
    public BooleanValue SendLocale
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Drill Through Count.</para>
    /// <para>Represents the following attribute in the schema: rowDrillCount </para>
    /// </summary>
    [SchemaAttr(0, "rowDrillCount")]
    public UInt32Value RowDrillCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> OLAP Fill Formatting.</para>
    /// <para>Represents the following attribute in the schema: serverFill </para>
    /// </summary>
    [SchemaAttr(0, "serverFill")]
    public BooleanValue ServerFill
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> OLAP Number Format.</para>
    /// <para>Represents the following attribute in the schema: serverNumberFormat </para>
    /// </summary>
    [SchemaAttr(0, "serverNumberFormat")]
    public BooleanValue ServerNumberFormat
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> OLAP Server Font.</para>
    /// <para>Represents the following attribute in the schema: serverFont </para>
    /// </summary>
    [SchemaAttr(0, "serverFont")]
    public BooleanValue ServerFont
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> OLAP Font Formatting.</para>
    /// <para>Represents the following attribute in the schema: serverFontColor </para>
    /// </summary>
    [SchemaAttr(0, "serverFontColor")]
    public BooleanValue ServerFontColor
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OlapProperties class.
    /// </summary>
    public OlapProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "local" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "localConnection" == name)
    return new StringValue();
    
if( 0 == namespaceId && "localRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sendLocale" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "rowDrillCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "serverFill" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "serverNumberFormat" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "serverFont" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "serverFontColor" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OlapProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WebQueryProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Tables &lt;x:tables></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Tables))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebQueryProperties : OpenXmlCompositeElement
{
    private const string tagName = "webPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11442;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "xml","sourceData","parsePre","consecutive","firstRow","xl97","textDates","xl2000","url","post","htmlTables","htmlFormat","editPage" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> XML Source.</para>
    /// <para>Represents the following attribute in the schema: xml </para>
    /// </summary>
    [SchemaAttr(0, "xml")]
    public BooleanValue XmlSource
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Import XML Source Data.</para>
    /// <para>Represents the following attribute in the schema: sourceData </para>
    /// </summary>
    [SchemaAttr(0, "sourceData")]
    public BooleanValue SourceData
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Parse PRE.</para>
    /// <para>Represents the following attribute in the schema: parsePre </para>
    /// </summary>
    [SchemaAttr(0, "parsePre")]
    public BooleanValue ParsePreTag
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Consecutive Delimiters.</para>
    /// <para>Represents the following attribute in the schema: consecutive </para>
    /// </summary>
    [SchemaAttr(0, "consecutive")]
    public BooleanValue Consecutive
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Use First Row.</para>
    /// <para>Represents the following attribute in the schema: firstRow </para>
    /// </summary>
    [SchemaAttr(0, "firstRow")]
    public BooleanValue FirstRow
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Created in Excel 97.</para>
    /// <para>Represents the following attribute in the schema: xl97 </para>
    /// </summary>
    [SchemaAttr(0, "xl97")]
    public BooleanValue CreatedInExcel97
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Dates as Text.</para>
    /// <para>Represents the following attribute in the schema: textDates </para>
    /// </summary>
    [SchemaAttr(0, "textDates")]
    public BooleanValue TextDates
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Refreshed in Excel 2000.</para>
    /// <para>Represents the following attribute in the schema: xl2000 </para>
    /// </summary>
    [SchemaAttr(0, "xl2000")]
    public BooleanValue RefreshedInExcel2000
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> URL.</para>
    /// <para>Represents the following attribute in the schema: url </para>
    /// </summary>
    [SchemaAttr(0, "url")]
    public StringValue Url
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Web Post.</para>
    /// <para>Represents the following attribute in the schema: post </para>
    /// </summary>
    [SchemaAttr(0, "post")]
    public StringValue Post
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> HTML Tables Only.</para>
    /// <para>Represents the following attribute in the schema: htmlTables </para>
    /// </summary>
    [SchemaAttr(0, "htmlTables")]
    public BooleanValue HtmlTables
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> HTML Formatting Handling.</para>
    /// <para>Represents the following attribute in the schema: htmlFormat </para>
    /// </summary>
    [SchemaAttr(0, "htmlFormat")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.HtmlFormattingValues> HtmlFormat
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.HtmlFormattingValues>)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Edit Query URL.</para>
    /// <para>Represents the following attribute in the schema: editPage </para>
    /// </summary>
    [SchemaAttr(0, "editPage")]
    public StringValue EditPage
    {
        get { return (StringValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebQueryProperties class.
    /// </summary>
    public WebQueryProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WebQueryProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebQueryProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WebQueryProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebQueryProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WebQueryProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WebQueryProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tables" == name)
    return new Tables();
    

    return null;
}

        private static readonly string[] eleTagNames = { "tables" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Tables.</para>
    /// <para> Represents the following element tag in the schema: x:tables </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Tables Tables
    {
        get 
        {
            return GetElement<Tables>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "xml" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "sourceData" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "parsePre" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "consecutive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "firstRow" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xl97" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "textDates" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xl2000" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "url" == name)
    return new StringValue();
    
if( 0 == namespaceId && "post" == name)
    return new StringValue();
    
if( 0 == namespaceId && "htmlTables" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "htmlFormat" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.HtmlFormattingValues>();
    
if( 0 == namespaceId && "editPage" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebQueryProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:textPr.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TextFields &lt;x:textFields></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TextFields))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextProperties : OpenXmlCompositeElement
{
    private const string tagName = "textPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11443;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "prompt","fileType","codePage","characterSet","firstRow","sourceFile","delimited","decimal","thousands","tab","space","comma","semicolon","consecutive","qualifier","delimiter" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> prompt.</para>
    /// <para>Represents the following attribute in the schema: prompt </para>
    /// </summary>
    [SchemaAttr(0, "prompt")]
    public BooleanValue Prompt
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> fileType.</para>
    /// <para>Represents the following attribute in the schema: fileType </para>
    /// </summary>
    [SchemaAttr(0, "fileType")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.FileTypeValues> FileType
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.FileTypeValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> codePage.</para>
    /// <para>Represents the following attribute in the schema: codePage </para>
    /// </summary>
    [SchemaAttr(0, "codePage")]
    public UInt32Value CodePage
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> characterSet.</para>
    /// <para>Represents the following attribute in the schema: characterSet </para>
    /// </summary>
    [SchemaAttr(0, "characterSet")]
    public StringValue TextCharacterSet
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> firstRow.</para>
    /// <para>Represents the following attribute in the schema: firstRow </para>
    /// </summary>
    [SchemaAttr(0, "firstRow")]
    public UInt32Value FirstRow
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> sourceFile.</para>
    /// <para>Represents the following attribute in the schema: sourceFile </para>
    /// </summary>
    [SchemaAttr(0, "sourceFile")]
    public StringValue SourceFile
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> delimited.</para>
    /// <para>Represents the following attribute in the schema: delimited </para>
    /// </summary>
    [SchemaAttr(0, "delimited")]
    public BooleanValue Delimited
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> decimal.</para>
    /// <para>Represents the following attribute in the schema: decimal </para>
    /// </summary>
    [SchemaAttr(0, "decimal")]
    public StringValue Decimal
    {
        get { return (StringValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> thousands.</para>
    /// <para>Represents the following attribute in the schema: thousands </para>
    /// </summary>
    [SchemaAttr(0, "thousands")]
    public StringValue Thousands
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> tab.</para>
    /// <para>Represents the following attribute in the schema: tab </para>
    /// </summary>
    [SchemaAttr(0, "tab")]
    public BooleanValue TabAsDelimiter
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> space.</para>
    /// <para>Represents the following attribute in the schema: space </para>
    /// </summary>
    [SchemaAttr(0, "space")]
    public BooleanValue Space
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> comma.</para>
    /// <para>Represents the following attribute in the schema: comma </para>
    /// </summary>
    [SchemaAttr(0, "comma")]
    public BooleanValue Comma
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> semicolon.</para>
    /// <para>Represents the following attribute in the schema: semicolon </para>
    /// </summary>
    [SchemaAttr(0, "semicolon")]
    public BooleanValue Semicolon
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> consecutive.</para>
    /// <para>Represents the following attribute in the schema: consecutive </para>
    /// </summary>
    [SchemaAttr(0, "consecutive")]
    public BooleanValue Consecutive
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> qualifier.</para>
    /// <para>Represents the following attribute in the schema: qualifier </para>
    /// </summary>
    [SchemaAttr(0, "qualifier")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.QualifierValues> Qualifier
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.QualifierValues>)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> delimiter.</para>
    /// <para>Represents the following attribute in the schema: delimiter </para>
    /// </summary>
    [SchemaAttr(0, "delimiter")]
    public StringValue Delimiter
    {
        get { return (StringValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextProperties class.
    /// </summary>
    public TextProperties():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextProperties(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextProperties class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextProperties(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextProperties class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextProperties(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "textFields" == name)
    return new TextFields();
    

    return null;
}

        private static readonly string[] eleTagNames = { "textFields" };
    private static readonly byte[] eleNamespaceIds = { 22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> TextFields.</para>
    /// <para> Represents the following element tag in the schema: x:textFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public TextFields TextFields
    {
        get 
        {
            return GetElement<TextFields>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "prompt" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fileType" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.FileTypeValues>();
    
if( 0 == namespaceId && "codePage" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "characterSet" == name)
    return new StringValue();
    
if( 0 == namespaceId && "firstRow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sourceFile" == name)
    return new StringValue();
    
if( 0 == namespaceId && "delimited" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "decimal" == name)
    return new StringValue();
    
if( 0 == namespaceId && "thousands" == name)
    return new StringValue();
    
if( 0 == namespaceId && "tab" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "space" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "comma" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "semicolon" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "consecutive" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "qualifier" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.QualifierValues>();
    
if( 0 == namespaceId && "delimiter" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Parameters Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:parameters.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Parameter &lt;x:parameter></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Parameter))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Parameters : OpenXmlCompositeElement
{
    private const string tagName = "parameters";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11444;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Parameter Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Parameters class.
    /// </summary>
    public Parameters():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Parameters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Parameters(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Parameters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Parameters(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Parameters class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Parameters(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "parameter" == name)
    return new Parameter();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Parameters>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConnectionExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConnectionExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConnectionExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11445;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ConnectionExtensionList class.
    /// </summary>
    public ConnectionExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new ConnectionExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConnectionExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.Connection &lt;x14:connection></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.Connection &lt;x15:connection></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.Connection),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.Connection),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConnectionExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11446;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConnectionExtension class.
    /// </summary>
    public ConnectionExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConnectionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConnectionExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConnectionExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConnectionExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "connection" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.Connection();
    
if( 71 == namespaceId && "connection" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.Connection();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConnectionExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TextFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:textFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TextField &lt;x:textField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TextField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TextFields : OpenXmlCompositeElement
{
    private const string tagName = "textFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11447;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Count of Fields.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TextFields class.
    /// </summary>
    public TextFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TextFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TextFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TextFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TextFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TextFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "textField" == name)
    return new TextField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TextFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheSource Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cacheSource.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WorksheetSource &lt;x:worksheetSource></description></item>
///<item><description>Consolidation &lt;x:consolidation></description></item>
///<item><description>CacheSourceExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WorksheetSource))]
    [ChildElementInfo(typeof(Consolidation))]
    [ChildElementInfo(typeof(CacheSourceExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheSource : OpenXmlCompositeElement
{
    private const string tagName = "cacheSource";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11448;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "type","connectionId" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> type.</para>
    /// <para>Represents the following attribute in the schema: type </para>
    /// </summary>
    [SchemaAttr(0, "type")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.SourceValues> Type
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.SourceValues>)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> connectionId.</para>
    /// <para>Represents the following attribute in the schema: connectionId </para>
    /// </summary>
    [SchemaAttr(0, "connectionId")]
    public UInt32Value ConnectionId
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheSource class.
    /// </summary>
    public CacheSource():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheSource class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSource(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSource class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheSource(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheSource class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheSource(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "worksheetSource" == name)
    return new WorksheetSource();
    
if( 22 == namespaceId && "consolidation" == name)
    return new Consolidation();
    
if( 22 == namespaceId && "extLst" == name)
    return new CacheSourceExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "worksheetSource","consolidation","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneChoice;}
    }
    
        /// <summary>
    /// <para> WorksheetSource.</para>
    /// <para> Represents the following element tag in the schema: x:worksheetSource </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public WorksheetSource WorksheetSource
    {
        get 
        {
            return GetElement<WorksheetSource>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Consolidation.</para>
    /// <para> Represents the following element tag in the schema: x:consolidation </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Consolidation Consolidation
    {
        get 
        {
            return GetElement<Consolidation>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> CacheSourceExtensionList.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public CacheSourceExtensionList CacheSourceExtensionList
    {
        get 
        {
            return GetElement<CacheSourceExtensionList>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "type" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.SourceValues>();
    
if( 0 == namespaceId && "connectionId" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheSource>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cacheFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheField &lt;x:cacheField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheFields : OpenXmlCompositeElement
{
    private const string tagName = "cacheFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11449;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheFields class.
    /// </summary>
    public CacheFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cacheField" == name)
    return new CacheField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheHierarchies Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cacheHierarchies.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheHierarchy &lt;x:cacheHierarchy></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheHierarchy))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheHierarchies : OpenXmlCompositeElement
{
    private const string tagName = "cacheHierarchies";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11450;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Hierarchy Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheHierarchies class.
    /// </summary>
    public CacheHierarchies():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheHierarchies class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchies(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchies class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchies(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchies class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheHierarchies(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cacheHierarchy" == name)
    return new CacheHierarchy();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheHierarchies>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Kpis Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:kpis.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Kpi &lt;x:kpi></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Kpi))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Kpis : OpenXmlCompositeElement
{
    private const string tagName = "kpis";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11451;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> KPI Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Kpis class.
    /// </summary>
    public Kpis():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Kpis class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Kpis(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Kpis class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Kpis(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Kpis class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Kpis(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "kpi" == name)
    return new Kpi();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Kpis>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TupleCache Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tupleCache.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Entries &lt;x:entries></description></item>
///<item><description>Sets &lt;x:sets></description></item>
///<item><description>QueryCache &lt;x:queryCache></description></item>
///<item><description>ServerFormats &lt;x:serverFormats></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Entries))]
    [ChildElementInfo(typeof(Sets))]
    [ChildElementInfo(typeof(QueryCache))]
    [ChildElementInfo(typeof(ServerFormats))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TupleCache : OpenXmlCompositeElement
{
    private const string tagName = "tupleCache";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11452;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the TupleCache class.
    /// </summary>
    public TupleCache():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TupleCache class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TupleCache(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TupleCache class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TupleCache(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TupleCache class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TupleCache(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "entries" == name)
    return new Entries();
    
if( 22 == namespaceId && "sets" == name)
    return new Sets();
    
if( 22 == namespaceId && "queryCache" == name)
    return new QueryCache();
    
if( 22 == namespaceId && "serverFormats" == name)
    return new ServerFormats();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "entries","sets","queryCache","serverFormats","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Entries.</para>
    /// <para> Represents the following element tag in the schema: x:entries </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Entries Entries
    {
        get 
        {
            return GetElement<Entries>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Sets.</para>
    /// <para> Represents the following element tag in the schema: x:sets </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public Sets Sets
    {
        get 
        {
            return GetElement<Sets>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> OLAP Query Cache.</para>
    /// <para> Represents the following element tag in the schema: x:queryCache </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public QueryCache QueryCache
    {
        get 
        {
            return GetElement<QueryCache>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Server Formats.</para>
    /// <para> Represents the following element tag in the schema: x:serverFormats </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ServerFormats ServerFormats
    {
        get 
        {
            return GetElement<ServerFormats>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(4);
        }
        set
        {
            SetElement(4, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TupleCache>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CalculatedItems Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calculatedItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculatedItem &lt;x:calculatedItem></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculatedItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedItems : OpenXmlCompositeElement
{
    private const string tagName = "calculatedItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11453;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Calculated Item Formula Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedItems class.
    /// </summary>
    public CalculatedItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "calculatedItem" == name)
    return new CalculatedItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedItems>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CalculatedMembers Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calculatedMembers.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculatedMember &lt;x:calculatedMember></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculatedMember))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedMembers : OpenXmlCompositeElement
{
    private const string tagName = "calculatedMembers";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11454;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Calculated Members Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedMembers class.
    /// </summary>
    public CalculatedMembers():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedMembers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMembers(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMembers class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMembers(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMembers class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedMembers(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "calculatedMember" == name)
    return new CalculatedMember();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedMembers>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Dimensions Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dimensions.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Dimension &lt;x:dimension></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Dimension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Dimensions : OpenXmlCompositeElement
{
    private const string tagName = "dimensions";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11455;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLAP Dimensions Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Dimensions class.
    /// </summary>
    public Dimensions():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Dimensions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dimensions(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Dimensions class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Dimensions(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Dimensions class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Dimensions(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dimension" == name)
    return new Dimension();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Dimensions>(deep);
    }

   
}
/// <summary>
/// <para>Defines the MeasureGroups Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:measureGroups.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MeasureGroup &lt;x:measureGroup></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MeasureGroup))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MeasureGroups : OpenXmlCompositeElement
{
    private const string tagName = "measureGroups";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11456;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Measure Group Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MeasureGroups class.
    /// </summary>
    public MeasureGroups():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MeasureGroups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MeasureGroups(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MeasureGroups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MeasureGroups(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MeasureGroups class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MeasureGroups(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "measureGroup" == name)
    return new MeasureGroup();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MeasureGroups>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Maps Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:maps.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MeasureDimensionMap &lt;x:map></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MeasureDimensionMap))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Maps : OpenXmlCompositeElement
{
    private const string tagName = "maps";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11457;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Measure Group Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Maps class.
    /// </summary>
    public Maps():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Maps class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Maps(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Maps class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Maps(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Maps class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Maps(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "map" == name)
    return new MeasureDimensionMap();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Maps>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotCacheDefinitionExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotCacheDefinitionExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotCacheDefinitionExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCacheDefinitionExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11458;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtensionList class.
    /// </summary>
    public PivotCacheDefinitionExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotCacheDefinitionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinitionExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinitionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCacheDefinitionExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new PivotCacheDefinitionExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCacheDefinitionExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotCacheDefinitionExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition &lt;x14:pivotCacheDefinition></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled &lt;x15:pivotCacheDecoupled></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition &lt;x15:timelinePivotCacheDefinition></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion &lt;x15:pivotCacheIdVersion></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCacheDefinitionExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11459;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtension class.
    /// </summary>
    public PivotCacheDefinitionExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotCacheDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinitionExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCacheDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCacheDefinitionExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCacheDefinitionExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "pivotCacheDefinition" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.PivotCacheDefinition();
    
if( 71 == namespaceId && "pivotCacheDecoupled" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotCacheDecoupled();
    
if( 71 == namespaceId && "timelinePivotCacheDefinition" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TimelinePivotCacheDefinition();
    
if( 71 == namespaceId && "pivotCacheIdVersion" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotCacheIdVersion();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCacheDefinitionExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SharedItems Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sharedItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MissingItem &lt;x:m></description></item>
///<item><description>NumberItem &lt;x:n></description></item>
///<item><description>BooleanItem &lt;x:b></description></item>
///<item><description>ErrorItem &lt;x:e></description></item>
///<item><description>StringItem &lt;x:s></description></item>
///<item><description>DateTimeItem &lt;x:d></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MissingItem))]
    [ChildElementInfo(typeof(NumberItem))]
    [ChildElementInfo(typeof(BooleanItem))]
    [ChildElementInfo(typeof(ErrorItem))]
    [ChildElementInfo(typeof(StringItem))]
    [ChildElementInfo(typeof(DateTimeItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SharedItems : OpenXmlCompositeElement
{
    private const string tagName = "sharedItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11460;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "containsSemiMixedTypes","containsNonDate","containsDate","containsString","containsBlank","containsMixedTypes","containsNumber","containsInteger","minValue","maxValue","minDate","maxDate","count","longText" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Contains Semi Mixed Data Types.</para>
    /// <para>Represents the following attribute in the schema: containsSemiMixedTypes </para>
    /// </summary>
    [SchemaAttr(0, "containsSemiMixedTypes")]
    public BooleanValue ContainsSemiMixedTypes
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Contains Non Date.</para>
    /// <para>Represents the following attribute in the schema: containsNonDate </para>
    /// </summary>
    [SchemaAttr(0, "containsNonDate")]
    public BooleanValue ContainsNonDate
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Contains Date.</para>
    /// <para>Represents the following attribute in the schema: containsDate </para>
    /// </summary>
    [SchemaAttr(0, "containsDate")]
    public BooleanValue ContainsDate
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Contains String.</para>
    /// <para>Represents the following attribute in the schema: containsString </para>
    /// </summary>
    [SchemaAttr(0, "containsString")]
    public BooleanValue ContainsString
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Contains Blank.</para>
    /// <para>Represents the following attribute in the schema: containsBlank </para>
    /// </summary>
    [SchemaAttr(0, "containsBlank")]
    public BooleanValue ContainsBlank
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Contains Mixed Data Types.</para>
    /// <para>Represents the following attribute in the schema: containsMixedTypes </para>
    /// </summary>
    [SchemaAttr(0, "containsMixedTypes")]
    public BooleanValue ContainsMixedTypes
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Contains Numbers.</para>
    /// <para>Represents the following attribute in the schema: containsNumber </para>
    /// </summary>
    [SchemaAttr(0, "containsNumber")]
    public BooleanValue ContainsNumber
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Contains Integer.</para>
    /// <para>Represents the following attribute in the schema: containsInteger </para>
    /// </summary>
    [SchemaAttr(0, "containsInteger")]
    public BooleanValue ContainsInteger
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Numeric Value.</para>
    /// <para>Represents the following attribute in the schema: minValue </para>
    /// </summary>
    [SchemaAttr(0, "minValue")]
    public DoubleValue MinValue
    {
        get { return (DoubleValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Numeric Value.</para>
    /// <para>Represents the following attribute in the schema: maxValue </para>
    /// </summary>
    [SchemaAttr(0, "maxValue")]
    public DoubleValue MaxValue
    {
        get { return (DoubleValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Date Time.</para>
    /// <para>Represents the following attribute in the schema: minDate </para>
    /// </summary>
    [SchemaAttr(0, "minDate")]
    public DateTimeValue MinDate
    {
        get { return (DateTimeValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Maximum Date Time Value.</para>
    /// <para>Represents the following attribute in the schema: maxDate </para>
    /// </summary>
    [SchemaAttr(0, "maxDate")]
    public DateTimeValue MaxDate
    {
        get { return (DateTimeValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Shared Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Long Text.</para>
    /// <para>Represents the following attribute in the schema: longText </para>
    /// </summary>
    [SchemaAttr(0, "longText")]
    public BooleanValue LongText
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SharedItems class.
    /// </summary>
    public SharedItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the SharedItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public SharedItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the SharedItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public SharedItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "m" == name)
    return new MissingItem();
    
if( 22 == namespaceId && "n" == name)
    return new NumberItem();
    
if( 22 == namespaceId && "b" == name)
    return new BooleanItem();
    
if( 22 == namespaceId && "e" == name)
    return new ErrorItem();
    
if( 22 == namespaceId && "s" == name)
    return new StringItem();
    
if( 22 == namespaceId && "d" == name)
    return new DateTimeItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "containsSemiMixedTypes" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsNonDate" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsDate" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsString" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsBlank" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsMixedTypes" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsNumber" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "containsInteger" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "minValue" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "maxValue" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "minDate" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "maxDate" == name)
    return new DateTimeValue();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "longText" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SharedItems>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FieldGroup Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fieldGroup.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RangeProperties &lt;x:rangePr></description></item>
///<item><description>DiscreteProperties &lt;x:discretePr></description></item>
///<item><description>GroupItems &lt;x:groupItems></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RangeProperties))]
    [ChildElementInfo(typeof(DiscreteProperties))]
    [ChildElementInfo(typeof(GroupItems))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldGroup : OpenXmlCompositeElement
{
    private const string tagName = "fieldGroup";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11461;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "par","base" };
    private static byte[] attributeNamespaceIds = { 0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Parent.</para>
    /// <para>Represents the following attribute in the schema: par </para>
    /// </summary>
    [SchemaAttr(0, "par")]
    public UInt32Value ParentId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Field Base.</para>
    /// <para>Represents the following attribute in the schema: base </para>
    /// </summary>
    [SchemaAttr(0, "base")]
    public UInt32Value Base
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldGroup class.
    /// </summary>
    public FieldGroup():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FieldGroup class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldGroup(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldGroup class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldGroup(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldGroup class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FieldGroup(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rangePr" == name)
    return new RangeProperties();
    
if( 22 == namespaceId && "discretePr" == name)
    return new DiscreteProperties();
    
if( 22 == namespaceId && "groupItems" == name)
    return new GroupItems();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "par" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "base" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldGroup>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheFieldExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheFieldExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheFieldExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheFieldExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11463;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CacheFieldExtensionList class.
    /// </summary>
    public CacheFieldExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFieldExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFieldExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheFieldExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new CacheFieldExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheFieldExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheFieldExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.CacheField &lt;x14:cacheField></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames &lt;x15:cachedUniqueNames></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.CacheField),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheFieldExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11464;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheFieldExtension class.
    /// </summary>
    public CacheFieldExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFieldExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheFieldExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheFieldExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "cacheField" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.CacheField();
    
if( 71 == namespaceId && "cachedUniqueNames" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.CachedUniqueNames();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheFieldExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FieldsUsage Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fieldsUsage.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FieldUsage &lt;x:fieldUsage></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FieldUsage))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FieldsUsage : OpenXmlCompositeElement
{
    private const string tagName = "fieldsUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11465;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FieldsUsage class.
    /// </summary>
    public FieldsUsage():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FieldsUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldsUsage(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldsUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FieldsUsage(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FieldsUsage class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FieldsUsage(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "fieldUsage" == name)
    return new FieldUsage();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FieldsUsage>(deep);
    }

   
}
/// <summary>
/// <para>Defines the GroupLevels Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:groupLevels.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>GroupLevel &lt;x:groupLevel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(GroupLevel))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class GroupLevels : OpenXmlCompositeElement
{
    private const string tagName = "groupLevels";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11466;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Grouping Level Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the GroupLevels class.
    /// </summary>
    public GroupLevels():base(){}
    
            /// <summary>
    ///Initializes a new instance of the GroupLevels class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupLevels(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupLevels class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public GroupLevels(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the GroupLevels class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public GroupLevels(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "groupLevel" == name)
    return new GroupLevel();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<GroupLevels>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheHierarchyExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CacheHierarchyExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CacheHierarchyExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheHierarchyExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11467;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtensionList class.
    /// </summary>
    public CacheHierarchyExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheHierarchyExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchyExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchyExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheHierarchyExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new CacheHierarchyExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheHierarchyExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CacheHierarchyExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy &lt;x14:cacheHierarchy></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy &lt;x15:cacheHierarchy></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CacheHierarchyExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11468;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtension class.
    /// </summary>
    public CacheHierarchyExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CacheHierarchyExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchyExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CacheHierarchyExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CacheHierarchyExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CacheHierarchyExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "cacheHierarchy" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.CacheHierarchy();
    
if( 71 == namespaceId && "cacheHierarchy" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.CacheHierarchy();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CacheHierarchyExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CalculatedMemberExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CalculatedMemberExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CalculatedMemberExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedMemberExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11469;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtensionList class.
    /// </summary>
    public CalculatedMemberExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedMemberExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMemberExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMemberExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedMemberExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new CalculatedMemberExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedMemberExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CalculatedMemberExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember &lt;x14:calculatedMember></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember &lt;x15:calculatedMember></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculatedMemberExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11470;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtension class.
    /// </summary>
    public CalculatedMemberExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CalculatedMemberExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMemberExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CalculatedMemberExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CalculatedMemberExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CalculatedMemberExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "calculatedMember" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.CalculatedMember();
    
if( 71 == namespaceId && "calculatedMember" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.CalculatedMember();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculatedMemberExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Location Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:location.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Location : OpenXmlLeafElement
{
    private const string tagName = "location";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11471;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref","firstHeaderRow","firstDataRow","firstDataCol","rowPageCount","colPageCount" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> First Header Row.</para>
    /// <para>Represents the following attribute in the schema: firstHeaderRow </para>
    /// </summary>
    [SchemaAttr(0, "firstHeaderRow")]
    public UInt32Value FirstHeaderRow
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> PivotTable Data First Row.</para>
    /// <para>Represents the following attribute in the schema: firstDataRow </para>
    /// </summary>
    [SchemaAttr(0, "firstDataRow")]
    public UInt32Value FirstDataRow
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> First Data Column.</para>
    /// <para>Represents the following attribute in the schema: firstDataCol </para>
    /// </summary>
    [SchemaAttr(0, "firstDataCol")]
    public UInt32Value FirstDataColumn
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Rows Per Page Count.</para>
    /// <para>Represents the following attribute in the schema: rowPageCount </para>
    /// </summary>
    [SchemaAttr(0, "rowPageCount")]
    public UInt32Value RowPageCount
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Columns Per Page.</para>
    /// <para>Represents the following attribute in the schema: colPageCount </para>
    /// </summary>
    [SchemaAttr(0, "colPageCount")]
    public UInt32Value ColumnsPerPage
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Location class.
    /// </summary>
    public Location():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    
if( 0 == namespaceId && "firstHeaderRow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "firstDataRow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "firstDataCol" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "rowPageCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "colPageCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Location>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotField &lt;x:pivotField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFields : OpenXmlCompositeElement
{
    private const string tagName = "pivotFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11472;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Field Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotFields class.
    /// </summary>
    public PivotFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotField" == name)
    return new PivotField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RowFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rowFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Field &lt;x:field></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Field))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowFields : OpenXmlCompositeElement
{
    private const string tagName = "rowFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11473;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Repeated Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RowFields class.
    /// </summary>
    public RowFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RowFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RowFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RowFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RowFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "field" == name)
    return new Field();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RowItems Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rowItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RowItem &lt;x:i></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RowItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowItems : OpenXmlCompositeElement
{
    private const string tagName = "rowItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11474;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Items in a Row Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RowItems class.
    /// </summary>
    public RowItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RowItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RowItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RowItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RowItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "i" == name)
    return new RowItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowItems>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ColumnFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Field &lt;x:field></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Field))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnFields : OpenXmlCompositeElement
{
    private const string tagName = "colFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11475;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Repeated Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnFields class.
    /// </summary>
    public ColumnFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColumnFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColumnFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "field" == name)
    return new Field();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ColumnItems Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colItems.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RowItem &lt;x:i></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RowItem))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnItems : OpenXmlCompositeElement
{
    private const string tagName = "colItems";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11476;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Column Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnItems class.
    /// </summary>
    public ColumnItems():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColumnItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnItems(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnItems class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnItems(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnItems class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColumnItems(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "i" == name)
    return new RowItem();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnItems>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PageFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pageFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PageField &lt;x:pageField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PageField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PageFields : OpenXmlCompositeElement
{
    private const string tagName = "pageFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11477;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Page Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PageFields class.
    /// </summary>
    public PageFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PageFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PageFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PageFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PageFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PageFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pageField" == name)
    return new PageField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PageFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataFields Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataFields.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataField &lt;x:dataField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataField))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataFields : OpenXmlCompositeElement
{
    private const string tagName = "dataFields";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11478;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Data Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataFields class.
    /// </summary>
    public DataFields():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFields(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFields class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFields(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFields class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataFields(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dataField" == name)
    return new DataField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataFields>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Formats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:formats.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Format &lt;x:format></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Format))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Formats : OpenXmlCompositeElement
{
    private const string tagName = "formats";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11479;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Formats Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Formats class.
    /// </summary>
    public Formats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Formats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Formats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Formats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Formats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Formats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Formats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "format" == name)
    return new Format();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Formats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ConditionalFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:conditionalFormats.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ConditionalFormat &lt;x:conditionalFormat></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ConditionalFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ConditionalFormats : OpenXmlCompositeElement
{
    private const string tagName = "conditionalFormats";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11480;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Conditional Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ConditionalFormats class.
    /// </summary>
    public ConditionalFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ConditionalFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ConditionalFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ConditionalFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ConditionalFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "conditionalFormat" == name)
    return new ConditionalFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ConditionalFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ChartFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:chartFormats.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ChartFormat &lt;x:chartFormat></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ChartFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ChartFormats : OpenXmlCompositeElement
{
    private const string tagName = "chartFormats";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11481;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ChartFormats class.
    /// </summary>
    public ChartFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ChartFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ChartFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ChartFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ChartFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "chartFormat" == name)
    return new ChartFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ChartFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotHierarchies Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotHierarchies.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotHierarchy &lt;x:pivotHierarchy></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotHierarchy))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotHierarchies : OpenXmlCompositeElement
{
    private const string tagName = "pivotHierarchies";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11482;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> OLAP Hierarchy Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotHierarchies class.
    /// </summary>
    public PivotHierarchies():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotHierarchies class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchies(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchies class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotHierarchies(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotHierarchies class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotHierarchies(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotHierarchy" == name)
    return new PivotHierarchy();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotHierarchies>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotTableStyle Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotTableStyleInfo.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotTableStyle : OpenXmlLeafElement
{
    private const string tagName = "pivotTableStyleInfo";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11483;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "name","showRowHeaders","showColHeaders","showRowStripes","showColStripes","showLastColumn" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Style Name.</para>
    /// <para>Represents the following attribute in the schema: name </para>
    /// </summary>
    [SchemaAttr(0, "name")]
    public StringValue Name
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Show Row Header Formatting.</para>
    /// <para>Represents the following attribute in the schema: showRowHeaders </para>
    /// </summary>
    [SchemaAttr(0, "showRowHeaders")]
    public BooleanValue ShowRowHeaders
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Table Style Column Header Formatting.</para>
    /// <para>Represents the following attribute in the schema: showColHeaders </para>
    /// </summary>
    [SchemaAttr(0, "showColHeaders")]
    public BooleanValue ShowColumnHeaders
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Row Stripes.</para>
    /// <para>Represents the following attribute in the schema: showRowStripes </para>
    /// </summary>
    [SchemaAttr(0, "showRowStripes")]
    public BooleanValue ShowRowStripes
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Show Column Stripes.</para>
    /// <para>Represents the following attribute in the schema: showColStripes </para>
    /// </summary>
    [SchemaAttr(0, "showColStripes")]
    public BooleanValue ShowColumnStripes
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Show Last Column.</para>
    /// <para>Represents the following attribute in the schema: showLastColumn </para>
    /// </summary>
    [SchemaAttr(0, "showLastColumn")]
    public BooleanValue ShowLastColumn
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotTableStyle class.
    /// </summary>
    public PivotTableStyle():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "name" == name)
    return new StringValue();
    
if( 0 == namespaceId && "showRowHeaders" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showColHeaders" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showRowStripes" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showColStripes" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showLastColumn" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotTableStyle>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotFilters Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:filters.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotFilter &lt;x:filter></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotFilter))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFilters : OpenXmlCompositeElement
{
    private const string tagName = "filters";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11484;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Pivot Filter Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotFilters class.
    /// </summary>
    public PivotFilters():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFilters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilters(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilters class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilters(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilters class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFilters(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "filter" == name)
    return new PivotFilter();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFilters>(deep);
    }

   
}
/// <summary>
/// <para>Defines the RowHierarchiesUsage Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:rowHierarchiesUsage.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>RowHierarchyUsage &lt;x:rowHierarchyUsage></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(RowHierarchyUsage))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class RowHierarchiesUsage : OpenXmlCompositeElement
{
    private const string tagName = "rowHierarchiesUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11485;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the RowHierarchiesUsage class.
    /// </summary>
    public RowHierarchiesUsage():base(){}
    
            /// <summary>
    ///Initializes a new instance of the RowHierarchiesUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowHierarchiesUsage(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the RowHierarchiesUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public RowHierarchiesUsage(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the RowHierarchiesUsage class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public RowHierarchiesUsage(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "rowHierarchyUsage" == name)
    return new RowHierarchyUsage();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<RowHierarchiesUsage>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ColumnHierarchiesUsage Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colHierarchiesUsage.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ColumnHierarchyUsage &lt;x:colHierarchyUsage></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ColumnHierarchyUsage))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ColumnHierarchiesUsage : OpenXmlCompositeElement
{
    private const string tagName = "colHierarchiesUsage";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11486;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Items Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the ColumnHierarchiesUsage class.
    /// </summary>
    public ColumnHierarchiesUsage():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ColumnHierarchiesUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnHierarchiesUsage(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnHierarchiesUsage class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ColumnHierarchiesUsage(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ColumnHierarchiesUsage class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ColumnHierarchiesUsage(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "colHierarchyUsage" == name)
    return new ColumnHierarchyUsage();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ColumnHierarchiesUsage>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotTableDefinitionExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotTableDefinitionExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotTableDefinitionExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotTableDefinitionExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11487;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtensionList class.
    /// </summary>
    public PivotTableDefinitionExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotTableDefinitionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinitionExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinitionExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotTableDefinitionExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new PivotTableDefinitionExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotTableDefinitionExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotTableDefinitionExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition &lt;x14:pivotTableDefinition></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotTableData &lt;x15:pivotTableData></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings &lt;x15:pivotTableUISettings></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableData),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotTableDefinitionExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11488;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtension class.
    /// </summary>
    public PivotTableDefinitionExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotTableDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinitionExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotTableDefinitionExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotTableDefinitionExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotTableDefinitionExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "pivotTableDefinition" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.PivotTableDefinition();
    
if( 71 == namespaceId && "pivotTableData" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotTableData();
    
if( 71 == namespaceId && "pivotTableUISettings" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotTableUISettings();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotTableDefinitionExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataFieldExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataFieldExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataFieldExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataFieldExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11489;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DataFieldExtensionList class.
    /// </summary>
    public DataFieldExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFieldExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFieldExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFieldExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFieldExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataFieldExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new DataFieldExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataFieldExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataFieldExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.DataField &lt;x14:dataField></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.DataField &lt;x15:dataField></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.DataField),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.DataField),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataFieldExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11490;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataFieldExtension class.
    /// </summary>
    public DataFieldExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFieldExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFieldExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataFieldExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataFieldExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataFieldExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "dataField" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.DataField();
    
if( 71 == namespaceId && "dataField" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.DataField();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataFieldExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotFilterExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotFilterExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotFilterExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotFilterExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11491;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotFilterExtensionList class.
    /// </summary>
    public PivotFilterExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotFilterExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilterExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilterExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotFilterExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotFilterExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotFilterExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new PivotFilterExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotFilterExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the QueryTableRefresh Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:queryTableRefresh.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>QueryTableFields &lt;x:queryTableFields></description></item>
///<item><description>QueryTableDeletedFields &lt;x:queryTableDeletedFields></description></item>
///<item><description>SortState &lt;x:sortState></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(QueryTableFields))]
    [ChildElementInfo(typeof(QueryTableDeletedFields))]
    [ChildElementInfo(typeof(SortState))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableRefresh : OpenXmlCompositeElement
{
    private const string tagName = "queryTableRefresh";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11492;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "preserveSortFilterLayout","fieldIdWrapped","headersInLastRefresh","minimumVersion","nextId","unboundColumnsLeft","unboundColumnsRight" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Preserve Sort and Filter Layout.</para>
    /// <para>Represents the following attribute in the schema: preserveSortFilterLayout </para>
    /// </summary>
    [SchemaAttr(0, "preserveSortFilterLayout")]
    public BooleanValue PreserveSortFilterLayout
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Next Field Id Wrapped.</para>
    /// <para>Represents the following attribute in the schema: fieldIdWrapped </para>
    /// </summary>
    [SchemaAttr(0, "fieldIdWrapped")]
    public BooleanValue FieldIdWrapped
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Headers In Last Refresh.</para>
    /// <para>Represents the following attribute in the schema: headersInLastRefresh </para>
    /// </summary>
    [SchemaAttr(0, "headersInLastRefresh")]
    public BooleanValue HeadersInLastRefresh
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Minimum Refresh Version.</para>
    /// <para>Represents the following attribute in the schema: minimumVersion </para>
    /// </summary>
    [SchemaAttr(0, "minimumVersion")]
    public ByteValue MinimumVersion
    {
        get { return (ByteValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Next field id.</para>
    /// <para>Represents the following attribute in the schema: nextId </para>
    /// </summary>
    [SchemaAttr(0, "nextId")]
    public UInt32Value NextId
    {
        get { return (UInt32Value)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Columns Left.</para>
    /// <para>Represents the following attribute in the schema: unboundColumnsLeft </para>
    /// </summary>
    [SchemaAttr(0, "unboundColumnsLeft")]
    public UInt32Value UnboundColumnsLeft
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Columns Right.</para>
    /// <para>Represents the following attribute in the schema: unboundColumnsRight </para>
    /// </summary>
    [SchemaAttr(0, "unboundColumnsRight")]
    public UInt32Value UnboundColumnsRight
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the QueryTableRefresh class.
    /// </summary>
    public QueryTableRefresh():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableRefresh class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableRefresh(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableRefresh class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableRefresh(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableRefresh class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableRefresh(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "queryTableFields" == name)
    return new QueryTableFields();
    
if( 22 == namespaceId && "queryTableDeletedFields" == name)
    return new QueryTableDeletedFields();
    
if( 22 == namespaceId && "sortState" == name)
    return new SortState();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

        private static readonly string[] eleTagNames = { "queryTableFields","queryTableDeletedFields","sortState","extLst" };
    private static readonly byte[] eleNamespaceIds = { 22,22,22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Query table fields.</para>
    /// <para> Represents the following element tag in the schema: x:queryTableFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public QueryTableFields QueryTableFields
    {
        get 
        {
            return GetElement<QueryTableFields>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> Deleted Fields.</para>
    /// <para> Represents the following element tag in the schema: x:queryTableDeletedFields </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public QueryTableDeletedFields QueryTableDeletedFields
    {
        get 
        {
            return GetElement<QueryTableDeletedFields>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }
    /// <summary>
    /// <para> Sort State.</para>
    /// <para> Represents the following element tag in the schema: x:sortState </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public SortState SortState
    {
        get 
        {
            return GetElement<SortState>(2);
        }
        set
        {
            SetElement(2, value);
        }
    }
    /// <summary>
    /// <para> Future Feature Data Storage Area.</para>
    /// <para> Represents the following element tag in the schema: x:extLst </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public ExtensionList ExtensionList
    {
        get 
        {
            return GetElement<ExtensionList>(3);
        }
        set
        {
            SetElement(3, value);
        }
    }


    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "preserveSortFilterLayout" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "fieldIdWrapped" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "headersInLastRefresh" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "minimumVersion" == name)
    return new ByteValue();
    
if( 0 == namespaceId && "nextId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "unboundColumnsLeft" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "unboundColumnsRight" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableRefresh>(deep);
    }

   
}
/// <summary>
/// <para>Defines the QueryTableExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>QueryTableExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(QueryTableExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class QueryTableExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11493;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the QueryTableExtensionList class.
    /// </summary>
    public QueryTableExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the QueryTableExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public QueryTableExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the QueryTableExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public QueryTableExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new QueryTableExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<QueryTableExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the SheetCalculationProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheetCalcPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class SheetCalculationProperties : OpenXmlLeafElement
{
    private const string tagName = "sheetCalcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11494;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "fullCalcOnLoad" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Full Calculation On Load.</para>
    /// <para>Represents the following attribute in the schema: fullCalcOnLoad </para>
    /// </summary>
    [SchemaAttr(0, "fullCalcOnLoad")]
    public BooleanValue FullCalculationOnLoad
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the SheetCalculationProperties class.
    /// </summary>
    public SheetCalculationProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "fullCalcOnLoad" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<SheetCalculationProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ProtectedRanges Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:protectedRanges.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ProtectedRange &lt;x:protectedRange></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ProtectedRange))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ProtectedRanges : OpenXmlCompositeElement
{
    private const string tagName = "protectedRanges";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11495;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ProtectedRanges class.
    /// </summary>
    public ProtectedRanges():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ProtectedRanges class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ProtectedRanges(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ProtectedRanges class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ProtectedRanges(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ProtectedRanges class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ProtectedRanges(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "protectedRange" == name)
    return new ProtectedRange();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ProtectedRanges>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Scenarios Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:scenarios.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Scenario &lt;x:scenario></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Scenario))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Scenarios : OpenXmlCompositeElement
{
    private const string tagName = "scenarios";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11496;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "current","show","sqref" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Current Scenario.</para>
    /// <para>Represents the following attribute in the schema: current </para>
    /// </summary>
    [SchemaAttr(0, "current")]
    public UInt32Value Current
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Last Shown Scenario.</para>
    /// <para>Represents the following attribute in the schema: show </para>
    /// </summary>
    [SchemaAttr(0, "show")]
    public UInt32Value Show
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Sequence of References.</para>
    /// <para>Represents the following attribute in the schema: sqref </para>
    /// </summary>
    [SchemaAttr(0, "sqref")]
    public ListValue<StringValue> SequenceOfReferences
    {
        get { return (ListValue<StringValue>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Scenarios class.
    /// </summary>
    public Scenarios():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Scenarios class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scenarios(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Scenarios class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Scenarios(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Scenarios class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Scenarios(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "scenario" == name)
    return new Scenario();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "current" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "show" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "sqref" == name)
    return new ListValue<StringValue>();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Scenarios>(deep);
    }

   
}
/// <summary>
/// <para>Defines the MergeCells Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:mergeCells.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>MergeCell &lt;x:mergeCell></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(MergeCell))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class MergeCells : OpenXmlCompositeElement
{
    private const string tagName = "mergeCells";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11497;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the MergeCells class.
    /// </summary>
    public MergeCells():base(){}
    
            /// <summary>
    ///Initializes a new instance of the MergeCells class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MergeCells(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the MergeCells class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public MergeCells(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the MergeCells class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public MergeCells(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "mergeCell" == name)
    return new MergeCell();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<MergeCells>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DataValidations Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dataValidations.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DataValidation &lt;x:dataValidation></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DataValidation))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DataValidations : OpenXmlCompositeElement
{
    private const string tagName = "dataValidations";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11498;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "disablePrompts","xWindow","yWindow","count" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Disable Prompts.</para>
    /// <para>Represents the following attribute in the schema: disablePrompts </para>
    /// </summary>
    [SchemaAttr(0, "disablePrompts")]
    public BooleanValue DisablePrompts
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Corner (X Coodrinate).</para>
    /// <para>Represents the following attribute in the schema: xWindow </para>
    /// </summary>
    [SchemaAttr(0, "xWindow")]
    public UInt32Value XWindow
    {
        get { return (UInt32Value)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Top Left Corner (Y Coordinate).</para>
    /// <para>Represents the following attribute in the schema: yWindow </para>
    /// </summary>
    [SchemaAttr(0, "yWindow")]
    public UInt32Value YWindow
    {
        get { return (UInt32Value)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Data Validation Item Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DataValidations class.
    /// </summary>
    public DataValidations():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DataValidations class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataValidations(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DataValidations class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DataValidations(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DataValidations class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DataValidations(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dataValidation" == name)
    return new DataValidation();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "disablePrompts" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "xWindow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "yWindow" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DataValidations>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Hyperlinks Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:hyperlinks.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Hyperlink &lt;x:hyperlink></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Hyperlink))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Hyperlinks : OpenXmlCompositeElement
{
    private const string tagName = "hyperlinks";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11499;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Hyperlinks class.
    /// </summary>
    public Hyperlinks():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Hyperlinks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlinks(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlinks class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Hyperlinks(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Hyperlinks class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Hyperlinks(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "hyperlink" == name)
    return new Hyperlink();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Hyperlinks>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CellWatches Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellWatches.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellWatch &lt;x:cellWatch></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellWatch))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellWatches : OpenXmlCompositeElement
{
    private const string tagName = "cellWatches";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11500;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CellWatches class.
    /// </summary>
    public CellWatches():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellWatches class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellWatches(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellWatches class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellWatches(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellWatches class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellWatches(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cellWatch" == name)
    return new CellWatch();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellWatches>(deep);
    }

   
}
/// <summary>
/// <para>Defines the IgnoredErrors Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ignoredErrors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>IgnoredError &lt;x:ignoredError></description></item>
///<item><description>ExtensionList &lt;x:extLst></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(IgnoredError))]
    [ChildElementInfo(typeof(ExtensionList))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class IgnoredErrors : OpenXmlCompositeElement
{
    private const string tagName = "ignoredErrors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11501;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the IgnoredErrors class.
    /// </summary>
    public IgnoredErrors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the IgnoredErrors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IgnoredErrors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the IgnoredErrors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public IgnoredErrors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the IgnoredErrors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public IgnoredErrors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ignoredError" == name)
    return new IgnoredError();
    
if( 22 == namespaceId && "extLst" == name)
    return new ExtensionList();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<IgnoredErrors>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableParts Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableParts.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TablePart &lt;x:tablePart></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TablePart))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableParts : OpenXmlCompositeElement
{
    private const string tagName = "tableParts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11502;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableParts class.
    /// </summary>
    public TableParts():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableParts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableParts(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableParts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableParts(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableParts class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableParts(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tablePart" == name)
    return new TablePart();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableParts>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorksheetExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WorksheetExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WorksheetExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorksheetExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11503;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the WorksheetExtensionList class.
    /// </summary>
    public WorksheetExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WorksheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorksheetExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WorksheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorksheetExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WorksheetExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WorksheetExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new WorksheetExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorksheetExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorksheetExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings &lt;x14:conditionalFormattings></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.DataValidations &lt;x14:dataValidations></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups &lt;x14:sparklineGroups></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SlicerList &lt;x14:slicerList></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges &lt;x14:protectedRanges></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors &lt;x14:ignoredErrors></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.WebExtensions &lt;x15:webExtensions></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences &lt;x15:timelineRefs></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.DataValidations),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerList),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.WebExtensions),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorksheetExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11504;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorksheetExtension class.
    /// </summary>
    public WorksheetExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WorksheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorksheetExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WorksheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorksheetExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WorksheetExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WorksheetExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "conditionalFormattings" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.ConditionalFormattings();
    
if( 53 == namespaceId && "dataValidations" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.DataValidations();
    
if( 53 == namespaceId && "sparklineGroups" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SparklineGroups();
    
if( 53 == namespaceId && "slicerList" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SlicerList();
    
if( 53 == namespaceId && "protectedRanges" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.ProtectedRanges();
    
if( 53 == namespaceId && "ignoredErrors" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.IgnoredErrors();
    
if( 71 == namespaceId && "webExtensions" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.WebExtensions();
    
if( 71 == namespaceId && "timelineRefs" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TimelineReferences();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorksheetExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the NumberingFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:numFmts.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>NumberingFormat &lt;x:numFmt></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(NumberingFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class NumberingFormats : OpenXmlCompositeElement
{
    private const string tagName = "numFmts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11507;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Number Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the NumberingFormats class.
    /// </summary>
    public NumberingFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the NumberingFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public NumberingFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the NumberingFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public NumberingFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "numFmt" == name)
    return new NumberingFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<NumberingFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Fonts Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fonts.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Font &lt;x:font></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Font))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fonts : OpenXmlCompositeElement
{
    private const string tagName = "fonts";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11508;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count","knownFonts" };
    private static byte[] attributeNamespaceIds = { 0,55 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Font Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> knownFonts.</para>
    /// <para>Represents the following attribute in the schema: x14ac:knownFonts </para>
    /// </summary>
///<remark> xmlns:x14ac=http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac
///</remark>
    [SchemaAttr(55, "knownFonts")]
    public BooleanValue KnownFonts
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Fonts class.
    /// </summary>
    public Fonts():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fonts(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fonts class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fonts(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "font" == name)
    return new Font();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 55 == namespaceId && "knownFonts" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fonts>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Fills Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fills.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Fill &lt;x:fill></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Fill))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Fills : OpenXmlCompositeElement
{
    private const string tagName = "fills";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11509;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Fill Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Fills class.
    /// </summary>
    public Fills():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Fills class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fills(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Fills class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Fills(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Fills class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Fills(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "fill" == name)
    return new Fill();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Fills>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Borders Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:borders.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Border &lt;x:border></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Border))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Borders : OpenXmlCompositeElement
{
    private const string tagName = "borders";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11510;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Border Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the Borders class.
    /// </summary>
    public Borders():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Borders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Borders(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Borders class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Borders(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Borders class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Borders(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "border" == name)
    return new Border();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Borders>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CellStyleFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellStyleXfs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormat &lt;x:xf></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellStyleFormats : OpenXmlCompositeElement
{
    private const string tagName = "cellStyleXfs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11511;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Style Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellStyleFormats class.
    /// </summary>
    public CellStyleFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellStyleFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyleFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyleFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyleFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyleFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellStyleFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "xf" == name)
    return new CellFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellStyleFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CellFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellXfs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellFormat &lt;x:xf></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellFormats : OpenXmlCompositeElement
{
    private const string tagName = "cellXfs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11512;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellFormats class.
    /// </summary>
    public CellFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "xf" == name)
    return new CellFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CellStyles Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:cellStyles.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CellStyle &lt;x:cellStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CellStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CellStyles : OpenXmlCompositeElement
{
    private const string tagName = "cellStyles";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11513;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Style Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CellStyles class.
    /// </summary>
    public CellStyles():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CellStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyles(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CellStyles(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CellStyles class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CellStyles(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "cellStyle" == name)
    return new CellStyle();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CellStyles>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DifferentialFormats Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:dxfs.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DifferentialFormat &lt;x:dxf></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DifferentialFormat))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DifferentialFormats : OpenXmlCompositeElement
{
    private const string tagName = "dxfs";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11514;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Format Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the DifferentialFormats class.
    /// </summary>
    public DifferentialFormats():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DifferentialFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DifferentialFormats(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormats class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DifferentialFormats(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DifferentialFormats class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DifferentialFormats(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "dxf" == name)
    return new DifferentialFormat();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DifferentialFormats>(deep);
    }

   
}
/// <summary>
/// <para>Defines the TableStyles Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:tableStyles.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>TableStyle &lt;x:tableStyle></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(TableStyle))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class TableStyles : OpenXmlCompositeElement
{
    private const string tagName = "tableStyles";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11515;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count","defaultTableStyle","defaultPivotStyle" };
    private static byte[] attributeNamespaceIds = { 0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Table Style Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Default Table Style.</para>
    /// <para>Represents the following attribute in the schema: defaultTableStyle </para>
    /// </summary>
    [SchemaAttr(0, "defaultTableStyle")]
    public StringValue DefaultTableStyle
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Default Pivot Style.</para>
    /// <para>Represents the following attribute in the schema: defaultPivotStyle </para>
    /// </summary>
    [SchemaAttr(0, "defaultPivotStyle")]
    public StringValue DefaultPivotStyle
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the TableStyles class.
    /// </summary>
    public TableStyles():base(){}
    
            /// <summary>
    ///Initializes a new instance of the TableStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyles(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyles class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public TableStyles(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the TableStyles class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public TableStyles(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "tableStyle" == name)
    return new TableStyle();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "defaultTableStyle" == name)
    return new StringValue();
    
if( 0 == namespaceId && "defaultPivotStyle" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<TableStyles>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Colors Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:colors.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>IndexedColors &lt;x:indexedColors></description></item>
///<item><description>MruColors &lt;x:mruColors></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(IndexedColors))]
    [ChildElementInfo(typeof(MruColors))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Colors : OpenXmlCompositeElement
{
    private const string tagName = "colors";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11516;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Colors class.
    /// </summary>
    public Colors():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Colors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Colors(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Colors class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Colors(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Colors class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Colors(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "indexedColors" == name)
    return new IndexedColors();
    
if( 22 == namespaceId && "mruColors" == name)
    return new MruColors();
    

    return null;
}

        private static readonly string[] eleTagNames = { "indexedColors","mruColors" };
    private static readonly byte[] eleNamespaceIds = { 22,22 };
    
    internal override string[] ElementTagNames {
        get{
            return eleTagNames;
            }
    }
    
    internal override byte[] ElementNamespaceIds {
        get{
            return eleNamespaceIds;
            }
    }
    internal override OpenXmlCompositeType OpenXmlCompositeType
    {
        get {return OpenXmlCompositeType.OneSequence;}
    }
    
        /// <summary>
    /// <para> Color Indexes.</para>
    /// <para> Represents the following element tag in the schema: x:indexedColors </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public IndexedColors IndexedColors
    {
        get 
        {
            return GetElement<IndexedColors>(0);
        }
        set
        {
            SetElement(0, value);
        }
    }
    /// <summary>
    /// <para> MRU Colors.</para>
    /// <para> Represents the following element tag in the schema: x:mruColors </para>
    /// </summary>
    /// <remark>
    /// xmlns:x = http://schemas.openxmlformats.org/spreadsheetml/2006/main
    /// </remark>
    public MruColors MruColors
    {
        get 
        {
            return GetElement<MruColors>(1);
        }
        set
        {
            SetElement(1, value);
        }
    }


    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Colors>(deep);
    }

   
}
/// <summary>
/// <para>Defines the StylesheetExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>StylesheetExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(StylesheetExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StylesheetExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11517;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the StylesheetExtensionList class.
    /// </summary>
    public StylesheetExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StylesheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StylesheetExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StylesheetExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StylesheetExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StylesheetExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StylesheetExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new StylesheetExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StylesheetExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the StylesheetExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats &lt;x14:dxfs></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles &lt;x14:slicerStyles></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats &lt;x15:dxfs></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles &lt;x15:timelineStyles></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class StylesheetExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11518;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the StylesheetExtension class.
    /// </summary>
    public StylesheetExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the StylesheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StylesheetExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the StylesheetExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public StylesheetExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the StylesheetExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public StylesheetExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "dxfs" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.DifferentialFormats();
    
if( 53 == namespaceId && "slicerStyles" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SlicerStyles();
    
if( 71 == namespaceId && "dxfs" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.DifferentialFormats();
    
if( 71 == namespaceId && "timelineStyles" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TimelineStyles();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<StylesheetExtension>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FileVersion Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fileVersion.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FileVersion : OpenXmlLeafElement
{
    private const string tagName = "fileVersion";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11519;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "appName","lastEdited","lowestEdited","rupBuild","codeName" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Application Name.</para>
    /// <para>Represents the following attribute in the schema: appName </para>
    /// </summary>
    [SchemaAttr(0, "appName")]
    public StringValue ApplicationName
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Last Edited Version.</para>
    /// <para>Represents the following attribute in the schema: lastEdited </para>
    /// </summary>
    [SchemaAttr(0, "lastEdited")]
    public StringValue LastEdited
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Lowest Edited Version.</para>
    /// <para>Represents the following attribute in the schema: lowestEdited </para>
    /// </summary>
    [SchemaAttr(0, "lowestEdited")]
    public StringValue LowestEdited
    {
        get { return (StringValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Build Version.</para>
    /// <para>Represents the following attribute in the schema: rupBuild </para>
    /// </summary>
    [SchemaAttr(0, "rupBuild")]
    public StringValue BuildVersion
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Code Name.</para>
    /// <para>Represents the following attribute in the schema: codeName </para>
    /// </summary>
    [SchemaAttr(0, "codeName")]
    public StringValue CodeName
    {
        get { return (StringValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FileVersion class.
    /// </summary>
    public FileVersion():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "appName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "lastEdited" == name)
    return new StringValue();
    
if( 0 == namespaceId && "lowestEdited" == name)
    return new StringValue();
    
if( 0 == namespaceId && "rupBuild" == name)
    return new StringValue();
    
if( 0 == namespaceId && "codeName" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FileVersion>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FileSharing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fileSharing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FileSharing : OpenXmlLeafElement
{
    private const string tagName = "fileSharing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11520;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "readOnlyRecommended","userName","reservationPassword","algorithmName","hashValue","saltValue","spinCount" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Read Only Recommended.</para>
    /// <para>Represents the following attribute in the schema: readOnlyRecommended </para>
    /// </summary>
    [SchemaAttr(0, "readOnlyRecommended")]
    public BooleanValue ReadOnlyRecommended
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> User Name.</para>
    /// <para>Represents the following attribute in the schema: userName </para>
    /// </summary>
    [SchemaAttr(0, "userName")]
    public StringValue UserName
    {
        get { return (StringValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Write Reservation Password.</para>
    /// <para>Represents the following attribute in the schema: reservationPassword </para>
    /// </summary>
    [SchemaAttr(0, "reservationPassword")]
    public HexBinaryValue ReservationPassword
    {
        get { return (HexBinaryValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Password hash algorithm.</para>
    /// <para>Represents the following attribute in the schema: algorithmName </para>
    /// </summary>
    [SchemaAttr(0, "algorithmName")]
    public StringValue AlgorithmName
    {
        get { return (StringValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Password hash.</para>
    /// <para>Represents the following attribute in the schema: hashValue </para>
    /// </summary>
    [SchemaAttr(0, "hashValue")]
    public Base64BinaryValue HashValue
    {
        get { return (Base64BinaryValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Salt for password hash.</para>
    /// <para>Represents the following attribute in the schema: saltValue </para>
    /// </summary>
    [SchemaAttr(0, "saltValue")]
    public Base64BinaryValue SaltValue
    {
        get { return (Base64BinaryValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Spin count for password hash.</para>
    /// <para>Represents the following attribute in the schema: spinCount </para>
    /// </summary>
    [SchemaAttr(0, "spinCount")]
    public UInt32Value SpinCount
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FileSharing class.
    /// </summary>
    public FileSharing():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "readOnlyRecommended" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "userName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "reservationPassword" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "algorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "saltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "spinCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FileSharing>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorkbookProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:workbookPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorkbookProperties : OpenXmlLeafElement
{
    private const string tagName = "workbookPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11521;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "date1904","dateCompatibility","showObjects","showBorderUnselectedTables","filterPrivacy","promptedSolutions","showInkAnnotation","backupFile","saveExternalLinkValues","updateLinks","codeName","hidePivotFieldList","showPivotChartFilter","allowRefreshQuery","publishItems","checkCompatibility","autoCompressPictures","refreshAllConnections","defaultThemeVersion" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Date 1904.</para>
    /// <para>Represents the following attribute in the schema: date1904 </para>
    /// </summary>
    [SchemaAttr(0, "date1904")]
    public BooleanValue Date1904
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> dateCompatibility.</para>
    /// <para>Represents the following attribute in the schema: dateCompatibility </para>
    /// </summary>
    [SchemaAttr(0, "dateCompatibility")]
    public BooleanValue DateCompatibility
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Show Objects.</para>
    /// <para>Represents the following attribute in the schema: showObjects </para>
    /// </summary>
    [SchemaAttr(0, "showObjects")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues> ShowObjects
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Show Border Unselected Table.</para>
    /// <para>Represents the following attribute in the schema: showBorderUnselectedTables </para>
    /// </summary>
    [SchemaAttr(0, "showBorderUnselectedTables")]
    public BooleanValue ShowBorderUnselectedTables
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Filter Privacy.</para>
    /// <para>Represents the following attribute in the schema: filterPrivacy </para>
    /// </summary>
    [SchemaAttr(0, "filterPrivacy")]
    public BooleanValue FilterPrivacy
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Prompted Solutions.</para>
    /// <para>Represents the following attribute in the schema: promptedSolutions </para>
    /// </summary>
    [SchemaAttr(0, "promptedSolutions")]
    public BooleanValue PromptedSolutions
    {
        get { return (BooleanValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Show Ink Annotations.</para>
    /// <para>Represents the following attribute in the schema: showInkAnnotation </para>
    /// </summary>
    [SchemaAttr(0, "showInkAnnotation")]
    public BooleanValue ShowInkAnnotation
    {
        get { return (BooleanValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Create Backup File.</para>
    /// <para>Represents the following attribute in the schema: backupFile </para>
    /// </summary>
    [SchemaAttr(0, "backupFile")]
    public BooleanValue BackupFile
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Save External Link Values.</para>
    /// <para>Represents the following attribute in the schema: saveExternalLinkValues </para>
    /// </summary>
    [SchemaAttr(0, "saveExternalLinkValues")]
    public BooleanValue SaveExternalLinkValues
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Update Links Behavior.</para>
    /// <para>Represents the following attribute in the schema: updateLinks </para>
    /// </summary>
    [SchemaAttr(0, "updateLinks")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.UpdateLinksBehaviorValues> UpdateLinks
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.UpdateLinksBehaviorValues>)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Code Name.</para>
    /// <para>Represents the following attribute in the schema: codeName </para>
    /// </summary>
    [SchemaAttr(0, "codeName")]
    public StringValue CodeName
    {
        get { return (StringValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Hide Pivot Field List.</para>
    /// <para>Represents the following attribute in the schema: hidePivotFieldList </para>
    /// </summary>
    [SchemaAttr(0, "hidePivotFieldList")]
    public BooleanValue HidePivotFieldList
    {
        get { return (BooleanValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Show Pivot Chart Filter.</para>
    /// <para>Represents the following attribute in the schema: showPivotChartFilter </para>
    /// </summary>
    [SchemaAttr(0, "showPivotChartFilter")]
    public BooleanValue ShowPivotChartFilter
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    
    /// <summary>
    /// <para> Allow Refresh Query.</para>
    /// <para>Represents the following attribute in the schema: allowRefreshQuery </para>
    /// </summary>
    [SchemaAttr(0, "allowRefreshQuery")]
    public BooleanValue AllowRefreshQuery
    {
        get { return (BooleanValue)Attributes[13]; }
        set { Attributes[13] = value; }
    }
    
    /// <summary>
    /// <para> Publish Items.</para>
    /// <para>Represents the following attribute in the schema: publishItems </para>
    /// </summary>
    [SchemaAttr(0, "publishItems")]
    public BooleanValue PublishItems
    {
        get { return (BooleanValue)Attributes[14]; }
        set { Attributes[14] = value; }
    }
    
    /// <summary>
    /// <para> Check Compatibility On Save.</para>
    /// <para>Represents the following attribute in the schema: checkCompatibility </para>
    /// </summary>
    [SchemaAttr(0, "checkCompatibility")]
    public BooleanValue CheckCompatibility
    {
        get { return (BooleanValue)Attributes[15]; }
        set { Attributes[15] = value; }
    }
    
    /// <summary>
    /// <para> Auto Compress Pictures.</para>
    /// <para>Represents the following attribute in the schema: autoCompressPictures </para>
    /// </summary>
    [SchemaAttr(0, "autoCompressPictures")]
    public BooleanValue AutoCompressPictures
    {
        get { return (BooleanValue)Attributes[16]; }
        set { Attributes[16] = value; }
    }
    
    /// <summary>
    /// <para> Refresh all Connections on Open.</para>
    /// <para>Represents the following attribute in the schema: refreshAllConnections </para>
    /// </summary>
    [SchemaAttr(0, "refreshAllConnections")]
    public BooleanValue RefreshAllConnections
    {
        get { return (BooleanValue)Attributes[17]; }
        set { Attributes[17] = value; }
    }
    
    /// <summary>
    /// <para> Default Theme Version.</para>
    /// <para>Represents the following attribute in the schema: defaultThemeVersion </para>
    /// </summary>
    [SchemaAttr(0, "defaultThemeVersion")]
    public UInt32Value DefaultThemeVersion
    {
        get { return (UInt32Value)Attributes[18]; }
        set { Attributes[18] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorkbookProperties class.
    /// </summary>
    public WorkbookProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "date1904" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dateCompatibility" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showObjects" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ObjectDisplayValues>();
    
if( 0 == namespaceId && "showBorderUnselectedTables" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "filterPrivacy" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "promptedSolutions" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showInkAnnotation" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "backupFile" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "saveExternalLinkValues" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "updateLinks" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.UpdateLinksBehaviorValues>();
    
if( 0 == namespaceId && "codeName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "hidePivotFieldList" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "showPivotChartFilter" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "allowRefreshQuery" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "publishItems" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "checkCompatibility" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "autoCompressPictures" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refreshAllConnections" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "defaultThemeVersion" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorkbookProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorkbookProtection Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:workbookProtection.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorkbookProtection : OpenXmlLeafElement
{
    private const string tagName = "workbookProtection";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11522;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "workbookPassword","revisionsPassword","lockStructure","lockWindows","lockRevision","revisionsAlgorithmName","revisionsHashValue","revisionsSaltValue","revisionsSpinCount","workbookAlgorithmName","workbookHashValue","workbookSaltValue","workbookSpinCount" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Workbook Password.</para>
    /// <para>Represents the following attribute in the schema: workbookPassword </para>
    /// </summary>
    [SchemaAttr(0, "workbookPassword")]
    public HexBinaryValue WorkbookPassword
    {
        get { return (HexBinaryValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Revisions Password.</para>
    /// <para>Represents the following attribute in the schema: revisionsPassword </para>
    /// </summary>
    [SchemaAttr(0, "revisionsPassword")]
    public HexBinaryValue RevisionsPassword
    {
        get { return (HexBinaryValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Lock Structure.</para>
    /// <para>Represents the following attribute in the schema: lockStructure </para>
    /// </summary>
    [SchemaAttr(0, "lockStructure")]
    public BooleanValue LockStructure
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Lock Windows.</para>
    /// <para>Represents the following attribute in the schema: lockWindows </para>
    /// </summary>
    [SchemaAttr(0, "lockWindows")]
    public BooleanValue LockWindows
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Lock Revisions.</para>
    /// <para>Represents the following attribute in the schema: lockRevision </para>
    /// </summary>
    [SchemaAttr(0, "lockRevision")]
    public BooleanValue LockRevision
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Name.</para>
    /// <para>Represents the following attribute in the schema: revisionsAlgorithmName </para>
    /// </summary>
    [SchemaAttr(0, "revisionsAlgorithmName")]
    public StringValue RevisionsAlgorithmName
    {
        get { return (StringValue)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash Value.</para>
    /// <para>Represents the following attribute in the schema: revisionsHashValue </para>
    /// </summary>
    [SchemaAttr(0, "revisionsHashValue")]
    public Base64BinaryValue RevisionsHashValue
    {
        get { return (Base64BinaryValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Salt Value for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: revisionsSaltValue </para>
    /// </summary>
    [SchemaAttr(0, "revisionsSaltValue")]
    public Base64BinaryValue RevisionsSaltValue
    {
        get { return (Base64BinaryValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: revisionsSpinCount </para>
    /// </summary>
    [SchemaAttr(0, "revisionsSpinCount")]
    public UInt32Value RevisionsSpinCount
    {
        get { return (UInt32Value)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Cryptographic Algorithm Name.</para>
    /// <para>Represents the following attribute in the schema: workbookAlgorithmName </para>
    /// </summary>
    [SchemaAttr(0, "workbookAlgorithmName")]
    public StringValue WorkbookAlgorithmName
    {
        get { return (StringValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Password Hash Value.</para>
    /// <para>Represents the following attribute in the schema: workbookHashValue </para>
    /// </summary>
    [SchemaAttr(0, "workbookHashValue")]
    public Base64BinaryValue WorkbookHashValue
    {
        get { return (Base64BinaryValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Salt Value for Password Verifier.</para>
    /// <para>Represents the following attribute in the schema: workbookSaltValue </para>
    /// </summary>
    [SchemaAttr(0, "workbookSaltValue")]
    public Base64BinaryValue WorkbookSaltValue
    {
        get { return (Base64BinaryValue)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Iterations to Run Hashing Algorithm.</para>
    /// <para>Represents the following attribute in the schema: workbookSpinCount </para>
    /// </summary>
    [SchemaAttr(0, "workbookSpinCount")]
    public UInt32Value WorkbookSpinCount
    {
        get { return (UInt32Value)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorkbookProtection class.
    /// </summary>
    public WorkbookProtection():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "workbookPassword" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "revisionsPassword" == name)
    return new HexBinaryValue();
    
if( 0 == namespaceId && "lockStructure" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "lockWindows" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "lockRevision" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "revisionsAlgorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "revisionsHashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "revisionsSaltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "revisionsSpinCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "workbookAlgorithmName" == name)
    return new StringValue();
    
if( 0 == namespaceId && "workbookHashValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "workbookSaltValue" == name)
    return new Base64BinaryValue();
    
if( 0 == namespaceId && "workbookSpinCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorkbookProtection>(deep);
    }

   
}
/// <summary>
/// <para>Defines the BookViews Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:bookViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WorkbookView &lt;x:workbookView></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WorkbookView))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class BookViews : OpenXmlCompositeElement
{
    private const string tagName = "bookViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11523;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the BookViews class.
    /// </summary>
    public BookViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the BookViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BookViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the BookViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public BookViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the BookViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public BookViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "workbookView" == name)
    return new WorkbookView();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<BookViews>(deep);
    }

   
}
/// <summary>
/// <para>Defines the Sheets Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:sheets.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>Sheet &lt;x:sheet></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(Sheet))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class Sheets : OpenXmlCompositeElement
{
    private const string tagName = "sheets";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11524;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the Sheets class.
    /// </summary>
    public Sheets():base(){}
    
            /// <summary>
    ///Initializes a new instance of the Sheets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Sheets(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the Sheets class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public Sheets(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the Sheets class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public Sheets(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "sheet" == name)
    return new Sheet();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<Sheets>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FunctionGroups Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:functionGroups.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>FunctionGroup &lt;x:functionGroup></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(FunctionGroup))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FunctionGroups : OpenXmlCompositeElement
{
    private const string tagName = "functionGroups";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11525;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "builtInGroupCount" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Built-in Function Group Count.</para>
    /// <para>Represents the following attribute in the schema: builtInGroupCount </para>
    /// </summary>
    [SchemaAttr(0, "builtInGroupCount")]
    public UInt32Value BuiltInGroupCount
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FunctionGroups class.
    /// </summary>
    public FunctionGroups():base(){}
    
            /// <summary>
    ///Initializes a new instance of the FunctionGroups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FunctionGroups(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the FunctionGroups class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public FunctionGroups(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the FunctionGroups class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public FunctionGroups(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "functionGroup" == name)
    return new FunctionGroup();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "builtInGroupCount" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FunctionGroups>(deep);
    }

   
}
/// <summary>
/// <para>Defines the ExternalReferences Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:externalReferences.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>ExternalReference &lt;x:externalReference></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(ExternalReference))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class ExternalReferences : OpenXmlCompositeElement
{
    private const string tagName = "externalReferences";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11526;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the ExternalReferences class.
    /// </summary>
    public ExternalReferences():base(){}
    
            /// <summary>
    ///Initializes a new instance of the ExternalReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalReferences(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalReferences class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public ExternalReferences(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the ExternalReferences class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public ExternalReferences(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "externalReference" == name)
    return new ExternalReference();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<ExternalReferences>(deep);
    }

   
}
/// <summary>
/// <para>Defines the DefinedNames Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:definedNames.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DefinedName &lt;x:definedName></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DefinedName))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class DefinedNames : OpenXmlCompositeElement
{
    private const string tagName = "definedNames";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11527;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the DefinedNames class.
    /// </summary>
    public DefinedNames():base(){}
    
            /// <summary>
    ///Initializes a new instance of the DefinedNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefinedNames(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the DefinedNames class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public DefinedNames(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the DefinedNames class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public DefinedNames(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "definedName" == name)
    return new DefinedName();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<DefinedNames>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CalculationProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:calcPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CalculationProperties : OpenXmlLeafElement
{
    private const string tagName = "calcPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11528;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "calcId","calcMode","fullCalcOnLoad","refMode","iterate","iterateCount","iterateDelta","fullPrecision","calcCompleted","calcOnSave","concurrentCalc","concurrentManualCount","forceFullCalc" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Calculation Id.</para>
    /// <para>Represents the following attribute in the schema: calcId </para>
    /// </summary>
    [SchemaAttr(0, "calcId")]
    public UInt32Value CalculationId
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Calculation Mode.</para>
    /// <para>Represents the following attribute in the schema: calcMode </para>
    /// </summary>
    [SchemaAttr(0, "calcMode")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalculateModeValues> CalculationMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalculateModeValues>)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Full Calculation On Load.</para>
    /// <para>Represents the following attribute in the schema: fullCalcOnLoad </para>
    /// </summary>
    [SchemaAttr(0, "fullCalcOnLoad")]
    public BooleanValue FullCalculationOnLoad
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Reference Mode.</para>
    /// <para>Represents the following attribute in the schema: refMode </para>
    /// </summary>
    [SchemaAttr(0, "refMode")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.ReferenceModeValues> ReferenceMode
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.ReferenceModeValues>)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> Calculation Iteration.</para>
    /// <para>Represents the following attribute in the schema: iterate </para>
    /// </summary>
    [SchemaAttr(0, "iterate")]
    public BooleanValue Iterate
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> Iteration Count.</para>
    /// <para>Represents the following attribute in the schema: iterateCount </para>
    /// </summary>
    [SchemaAttr(0, "iterateCount")]
    public UInt32Value IterateCount
    {
        get { return (UInt32Value)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> Iterative Calculation Delta.</para>
    /// <para>Represents the following attribute in the schema: iterateDelta </para>
    /// </summary>
    [SchemaAttr(0, "iterateDelta")]
    public DoubleValue IterateDelta
    {
        get { return (DoubleValue)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> Full Precision Calculation.</para>
    /// <para>Represents the following attribute in the schema: fullPrecision </para>
    /// </summary>
    [SchemaAttr(0, "fullPrecision")]
    public BooleanValue FullPrecision
    {
        get { return (BooleanValue)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> Calc Completed.</para>
    /// <para>Represents the following attribute in the schema: calcCompleted </para>
    /// </summary>
    [SchemaAttr(0, "calcCompleted")]
    public BooleanValue CalculationCompleted
    {
        get { return (BooleanValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    
    /// <summary>
    /// <para> Calculate On Save.</para>
    /// <para>Represents the following attribute in the schema: calcOnSave </para>
    /// </summary>
    [SchemaAttr(0, "calcOnSave")]
    public BooleanValue CalculationOnSave
    {
        get { return (BooleanValue)Attributes[9]; }
        set { Attributes[9] = value; }
    }
    
    /// <summary>
    /// <para> Concurrent Calculations.</para>
    /// <para>Represents the following attribute in the schema: concurrentCalc </para>
    /// </summary>
    [SchemaAttr(0, "concurrentCalc")]
    public BooleanValue ConcurrentCalculation
    {
        get { return (BooleanValue)Attributes[10]; }
        set { Attributes[10] = value; }
    }
    
    /// <summary>
    /// <para> Concurrent Thread Manual Count.</para>
    /// <para>Represents the following attribute in the schema: concurrentManualCount </para>
    /// </summary>
    [SchemaAttr(0, "concurrentManualCount")]
    public UInt32Value ConcurrentManualCount
    {
        get { return (UInt32Value)Attributes[11]; }
        set { Attributes[11] = value; }
    }
    
    /// <summary>
    /// <para> Force Full Calculation.</para>
    /// <para>Represents the following attribute in the schema: forceFullCalc </para>
    /// </summary>
    [SchemaAttr(0, "forceFullCalc")]
    public BooleanValue ForceFullCalculation
    {
        get { return (BooleanValue)Attributes[12]; }
        set { Attributes[12] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the CalculationProperties class.
    /// </summary>
    public CalculationProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "calcId" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "calcMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.CalculateModeValues>();
    
if( 0 == namespaceId && "fullCalcOnLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "refMode" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.ReferenceModeValues>();
    
if( 0 == namespaceId && "iterate" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "iterateCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "iterateDelta" == name)
    return new DoubleValue();
    
if( 0 == namespaceId && "fullPrecision" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "calcCompleted" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "calcOnSave" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "concurrentCalc" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "concurrentManualCount" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "forceFullCalc" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CalculationProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the OleSize Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:oleSize.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class OleSize : OpenXmlLeafElement
{
    private const string tagName = "oleSize";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11529;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "ref" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Reference.</para>
    /// <para>Represents the following attribute in the schema: ref </para>
    /// </summary>
    [SchemaAttr(0, "ref")]
    public StringValue Reference
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the OleSize class.
    /// </summary>
    public OleSize():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "ref" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<OleSize>(deep);
    }

   
}
/// <summary>
/// <para>Defines the CustomWorkbookViews Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:customWorkbookViews.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>CustomWorkbookView &lt;x:customWorkbookView></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(CustomWorkbookView))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class CustomWorkbookViews : OpenXmlCompositeElement
{
    private const string tagName = "customWorkbookViews";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11530;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the CustomWorkbookViews class.
    /// </summary>
    public CustomWorkbookViews():base(){}
    
            /// <summary>
    ///Initializes a new instance of the CustomWorkbookViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomWorkbookViews(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomWorkbookViews class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public CustomWorkbookViews(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the CustomWorkbookViews class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public CustomWorkbookViews(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "customWorkbookView" == name)
    return new CustomWorkbookView();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<CustomWorkbookViews>(deep);
    }

   
}
/// <summary>
/// <para>Defines the PivotCaches Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:pivotCaches.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>PivotCache &lt;x:pivotCache></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(PivotCache))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class PivotCaches : OpenXmlCompositeElement
{
    private const string tagName = "pivotCaches";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11531;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the PivotCaches class.
    /// </summary>
    public PivotCaches():base(){}
    
            /// <summary>
    ///Initializes a new instance of the PivotCaches class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCaches(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCaches class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public PivotCaches(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the PivotCaches class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public PivotCaches(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "pivotCache" == name)
    return new PivotCache();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<PivotCaches>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WebPublishing Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPublishing.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPublishing : OpenXmlLeafElement
{
    private const string tagName = "webPublishing";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11532;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "css","thicket","longFileNames","vml","allowPng","targetScreenSize","dpi","codePage","characterSet" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0,0,0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> css.</para>
    /// <para>Represents the following attribute in the schema: css </para>
    /// </summary>
    [SchemaAttr(0, "css")]
    public BooleanValue UseCss
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> thicket.</para>
    /// <para>Represents the following attribute in the schema: thicket </para>
    /// </summary>
    [SchemaAttr(0, "thicket")]
    public BooleanValue Thicket
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> longFileNames.</para>
    /// <para>Represents the following attribute in the schema: longFileNames </para>
    /// </summary>
    [SchemaAttr(0, "longFileNames")]
    public BooleanValue LongFileNames
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> vml.</para>
    /// <para>Represents the following attribute in the schema: vml </para>
    /// </summary>
    [SchemaAttr(0, "vml")]
    public BooleanValue UseVml
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    
    /// <summary>
    /// <para> allowPng.</para>
    /// <para>Represents the following attribute in the schema: allowPng </para>
    /// </summary>
    [SchemaAttr(0, "allowPng")]
    public BooleanValue AllowPng
    {
        get { return (BooleanValue)Attributes[4]; }
        set { Attributes[4] = value; }
    }
    
    /// <summary>
    /// <para> targetScreenSize.</para>
    /// <para>Represents the following attribute in the schema: targetScreenSize </para>
    /// </summary>
    [SchemaAttr(0, "targetScreenSize")]
    public EnumValue<DocumentFormat.OpenXml.Spreadsheet.TargetScreenSizeValues> TargetScreenSize
    {
        get { return (EnumValue<DocumentFormat.OpenXml.Spreadsheet.TargetScreenSizeValues>)Attributes[5]; }
        set { Attributes[5] = value; }
    }
    
    /// <summary>
    /// <para> dpi.</para>
    /// <para>Represents the following attribute in the schema: dpi </para>
    /// </summary>
    [SchemaAttr(0, "dpi")]
    public UInt32Value Dpi
    {
        get { return (UInt32Value)Attributes[6]; }
        set { Attributes[6] = value; }
    }
    
    /// <summary>
    /// <para> codePage.</para>
    /// <para>Represents the following attribute in the schema: codePage </para>
    /// </summary>
    [SchemaAttr(0, "codePage")]
    public UInt32Value CodePage
    {
        get { return (UInt32Value)Attributes[7]; }
        set { Attributes[7] = value; }
    }
    
    /// <summary>
    /// <para> characterSet.</para>
    /// <para>Represents the following attribute in the schema: characterSet </para>
    /// </summary>
    [SchemaAttr(0, "characterSet")]
    public StringValue CharacterSet
    {
        get { return (StringValue)Attributes[8]; }
        set { Attributes[8] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPublishing class.
    /// </summary>
    public WebPublishing():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "css" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "thicket" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "longFileNames" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "vml" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "allowPng" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "targetScreenSize" == name)
    return new EnumValue<DocumentFormat.OpenXml.Spreadsheet.TargetScreenSizeValues>();
    
if( 0 == namespaceId && "dpi" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "codePage" == name)
    return new UInt32Value();
    
if( 0 == namespaceId && "characterSet" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPublishing>(deep);
    }

   
}
/// <summary>
/// <para>Defines the FileRecoveryProperties Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:fileRecoveryPr.</para>
/// </summary>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class FileRecoveryProperties : OpenXmlLeafElement
{
    private const string tagName = "fileRecoveryPr";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11533;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "autoRecover","crashSave","dataExtractLoad","repairLoad" };
    private static byte[] attributeNamespaceIds = { 0,0,0,0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Auto Recover.</para>
    /// <para>Represents the following attribute in the schema: autoRecover </para>
    /// </summary>
    [SchemaAttr(0, "autoRecover")]
    public BooleanValue AutoRecover
    {
        get { return (BooleanValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    
    /// <summary>
    /// <para> Crash Save.</para>
    /// <para>Represents the following attribute in the schema: crashSave </para>
    /// </summary>
    [SchemaAttr(0, "crashSave")]
    public BooleanValue CrashSave
    {
        get { return (BooleanValue)Attributes[1]; }
        set { Attributes[1] = value; }
    }
    
    /// <summary>
    /// <para> Data Extract Load.</para>
    /// <para>Represents the following attribute in the schema: dataExtractLoad </para>
    /// </summary>
    [SchemaAttr(0, "dataExtractLoad")]
    public BooleanValue DataExtractLoad
    {
        get { return (BooleanValue)Attributes[2]; }
        set { Attributes[2] = value; }
    }
    
    /// <summary>
    /// <para> Repair Load.</para>
    /// <para>Represents the following attribute in the schema: repairLoad </para>
    /// </summary>
    [SchemaAttr(0, "repairLoad")]
    public BooleanValue RepairLoad
    {
        get { return (BooleanValue)Attributes[3]; }
        set { Attributes[3] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the FileRecoveryProperties class.
    /// </summary>
    public FileRecoveryProperties():base(){}
    
      
     
    
    
    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "autoRecover" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "crashSave" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "dataExtractLoad" == name)
    return new BooleanValue();
    
if( 0 == namespaceId && "repairLoad" == name)
    return new BooleanValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<FileRecoveryProperties>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WebPublishObjects Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:webPublishObjects.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WebPublishObject &lt;x:webPublishObject></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WebPublishObject))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WebPublishObjects : OpenXmlCompositeElement
{
    private const string tagName = "webPublishObjects";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11534;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "count" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> Count.</para>
    /// <para>Represents the following attribute in the schema: count </para>
    /// </summary>
    [SchemaAttr(0, "count")]
    public UInt32Value Count
    {
        get { return (UInt32Value)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WebPublishObjects class.
    /// </summary>
    public WebPublishObjects():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WebPublishObjects class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebPublishObjects(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WebPublishObjects class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WebPublishObjects(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WebPublishObjects class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WebPublishObjects(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "webPublishObject" == name)
    return new WebPublishObject();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "count" == name)
    return new UInt32Value();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WebPublishObjects>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorkbookExtensionList Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:extLst.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>WorkbookExtension &lt;x:ext></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(WorkbookExtension))]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorkbookExtensionList : OpenXmlCompositeElement
{
    private const string tagName = "extLst";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11535;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    
    
    
    /// <summary>
    /// Initializes a new instance of the WorkbookExtensionList class.
    /// </summary>
    public WorkbookExtensionList():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WorkbookExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookExtensionList(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookExtensionList class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookExtensionList(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookExtensionList class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WorkbookExtensionList(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 22 == namespaceId && "ext" == name)
    return new WorkbookExtension();
    

    return null;
}

    
    
        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorkbookExtensionList>(deep);
    }

   
}
/// <summary>
/// <para>Defines the WorkbookExtension Class.</para>
/// <para> When the object is serialized out as xml, its qualified name is x:ext.</para>
/// </summary>
/// <remarks>
/// The following table lists the possible child types:
/// <list type="bullet">
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.DefinedNames &lt;x14:definedNames></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.PivotCaches &lt;x14:pivotCaches></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches &lt;x14:slicerCaches></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches &lt;x15:slicerCaches></description></item>
///<item><description>DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties &lt;x14:workbookPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotCaches &lt;x15:pivotCaches></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences &lt;x15:pivotTableReferences></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches &lt;x15:timelineCachePivotCaches></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences &lt;x15:timelineCacheRefs></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties &lt;x15:workbookPr></description></item>
///<item><description>DocumentFormat.OpenXml.Office2013.Excel.DataModel &lt;x15:dataModel></description></item>
/// </list>
/// </remarks>
[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1710:IdentifiersShouldHaveCorrectSuffix")]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.DefinedNames),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.PivotCaches),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties),(FileFormatVersions)14)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotCaches),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties),(FileFormatVersions)12)]
    [ChildElementInfo(typeof(DocumentFormat.OpenXml.Office2013.Excel.DataModel),(FileFormatVersions)12)]
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public partial class WorkbookExtension : OpenXmlCompositeElement
{
    private const string tagName = "ext";
    /// <summary>
    /// Gets the local name of the element.
    /// </summary>
    public override string LocalName
    {
        get { return tagName; }
    }
    
    private const byte tagNsId = 22;
    internal override byte NamespaceId
    {
        get { return tagNsId; }
    }
    
    internal const int ElementTypeIdConst = 11536;
    
    /// <summary>
    /// Gets the type ID of the element.
    /// </summary>
    internal override int ElementTypeId
    {
		get { return ElementTypeIdConst; }
    }
    
   
    /// <summary>
    /// Whether this element is available in a specific version of Office Application.
    /// </summary>
    /// <param name="version">The Office file format version.</param>
    /// <returns>Returns true if the element is defined in the specified version.</returns>
    internal override bool IsInVersion(FileFormatVersions version)
    {
		if((15 & (int)version) > 0)
		{
			return true;
		}
		return false;
    }
    

    private static string[] attributeTagNames = { "uri" };
    private static byte[] attributeNamespaceIds = { 0 };
    
    internal override string[] AttributeTagNames {
        get{
            return attributeTagNames;
            }
    }
    
    internal override byte[] AttributeNamespaceIds {
        get{
            return attributeNamespaceIds;
            }
    }
    

    
        /// <summary>
    /// <para> URI.</para>
    /// <para>Represents the following attribute in the schema: uri </para>
    /// </summary>
    [SchemaAttr(0, "uri")]
    public StringValue Uri
    {
        get { return (StringValue)Attributes[0]; }
        set { Attributes[0] = value; }
    }
    

    /// <summary>
    /// Initializes a new instance of the WorkbookExtension class.
    /// </summary>
    public WorkbookExtension():base(){}
    
            /// <summary>
    ///Initializes a new instance of the WorkbookExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookExtension(System.Collections.Generic.IEnumerable<OpenXmlElement> childElements)
        : base(childElements)
    { 
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookExtension class with the specified child elements.
    /// </summary>
    /// <param name="childElements">Specifies the child elements.</param>
    public WorkbookExtension(params OpenXmlElement[] childElements) : base(childElements)
    {
    }
    
    /// <summary>
    /// Initializes a new instance of the WorkbookExtension class from outer XML.
    /// </summary>
    /// <param name="outerXml">Specifies the outer XML of the element.</param>
    public WorkbookExtension(string outerXml)
        : base(outerXml)
    {
    }
  
     
    
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
internal override OpenXmlElement ElementFactory(byte namespaceId, string name)
{
    if( 53 == namespaceId && "definedNames" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.DefinedNames();
    
if( 53 == namespaceId && "pivotCaches" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.PivotCaches();
    
if( 53 == namespaceId && "slicerCaches" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.SlicerCaches();
    
if( 71 == namespaceId && "slicerCaches" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.SlicerCaches();
    
if( 53 == namespaceId && "workbookPr" == name)
    return new DocumentFormat.OpenXml.Office2010.Excel.WorkbookProperties();
    
if( 71 == namespaceId && "pivotCaches" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotCaches();
    
if( 71 == namespaceId && "pivotTableReferences" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.PivotTableReferences();
    
if( 71 == namespaceId && "timelineCachePivotCaches" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TimelineCachePivotCaches();
    
if( 71 == namespaceId && "timelineCacheRefs" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.TimelineCacheReferences();
    
if( 71 == namespaceId && "workbookPr" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.WorkbookProperties();
    
if( 71 == namespaceId && "dataModel" == name)
    return new DocumentFormat.OpenXml.Office2013.Excel.DataModel();
    

    return null;
}

    
    internal override OpenXmlSimpleType AttributeFactory(byte namespaceId, string name)
{
    if( 0 == namespaceId && "uri" == name)
    return new StringValue();
    

    
    return base.AttributeFactory(namespaceId, name);
}

        /// <summary>
    /// Creates a duplicate of this node.  
    /// </summary>
    /// <param name="deep">True to recursively clone the subtree under the specified node; false to clone only the node itself. </param>
    /// <returns>Returns the cloned node. </returns>
    public override OpenXmlElement CloneNode(bool deep)
    {
        return CloneImp<WorkbookExtension>(deep);
    }

   
}
/// <summary>
/// Filter Operator 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FilterOperatorValues
{  
	///<summary>
///Equal.
///<para>When the item is serialized out as xml, its value is "equal".</para>
///</summary>
[EnumString("equal")]
Equal,
///<summary>
///Less Than.
///<para>When the item is serialized out as xml, its value is "lessThan".</para>
///</summary>
[EnumString("lessThan")]
LessThan,
///<summary>
///Less Than Or Equal.
///<para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
///</summary>
[EnumString("lessThanOrEqual")]
LessThanOrEqual,
///<summary>
///Not Equal.
///<para>When the item is serialized out as xml, its value is "notEqual".</para>
///</summary>
[EnumString("notEqual")]
NotEqual,
///<summary>
///Greater Than Or Equal.
///<para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
///</summary>
[EnumString("greaterThanOrEqual")]
GreaterThanOrEqual,
///<summary>
///Greater Than.
///<para>When the item is serialized out as xml, its value is "greaterThan".</para>
///</summary>
[EnumString("greaterThan")]
GreaterThan,
 
}
/// <summary>
/// Dynamic Filter 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DynamicFilterValues
{  
	///<summary>
///Null.
///<para>When the item is serialized out as xml, its value is "null".</para>
///</summary>
[EnumString("null")]
Null,
///<summary>
///Above Average.
///<para>When the item is serialized out as xml, its value is "aboveAverage".</para>
///</summary>
[EnumString("aboveAverage")]
AboveAverage,
///<summary>
///Below Average.
///<para>When the item is serialized out as xml, its value is "belowAverage".</para>
///</summary>
[EnumString("belowAverage")]
BelowAverage,
///<summary>
///Tomorrow.
///<para>When the item is serialized out as xml, its value is "tomorrow".</para>
///</summary>
[EnumString("tomorrow")]
Tomorrow,
///<summary>
///Today.
///<para>When the item is serialized out as xml, its value is "today".</para>
///</summary>
[EnumString("today")]
Today,
///<summary>
///Yesterday.
///<para>When the item is serialized out as xml, its value is "yesterday".</para>
///</summary>
[EnumString("yesterday")]
Yesterday,
///<summary>
///Next Week.
///<para>When the item is serialized out as xml, its value is "nextWeek".</para>
///</summary>
[EnumString("nextWeek")]
NextWeek,
///<summary>
///This Week.
///<para>When the item is serialized out as xml, its value is "thisWeek".</para>
///</summary>
[EnumString("thisWeek")]
ThisWeek,
///<summary>
///Last Week.
///<para>When the item is serialized out as xml, its value is "lastWeek".</para>
///</summary>
[EnumString("lastWeek")]
LastWeek,
///<summary>
///Next Month.
///<para>When the item is serialized out as xml, its value is "nextMonth".</para>
///</summary>
[EnumString("nextMonth")]
NextMonth,
///<summary>
///This Month.
///<para>When the item is serialized out as xml, its value is "thisMonth".</para>
///</summary>
[EnumString("thisMonth")]
ThisMonth,
///<summary>
///Last Month.
///<para>When the item is serialized out as xml, its value is "lastMonth".</para>
///</summary>
[EnumString("lastMonth")]
LastMonth,
///<summary>
///Next Quarter.
///<para>When the item is serialized out as xml, its value is "nextQuarter".</para>
///</summary>
[EnumString("nextQuarter")]
NextQuarter,
///<summary>
///This Quarter.
///<para>When the item is serialized out as xml, its value is "thisQuarter".</para>
///</summary>
[EnumString("thisQuarter")]
ThisQuarter,
///<summary>
///Last Quarter.
///<para>When the item is serialized out as xml, its value is "lastQuarter".</para>
///</summary>
[EnumString("lastQuarter")]
LastQuarter,
///<summary>
///Next Year.
///<para>When the item is serialized out as xml, its value is "nextYear".</para>
///</summary>
[EnumString("nextYear")]
NextYear,
///<summary>
///This Year.
///<para>When the item is serialized out as xml, its value is "thisYear".</para>
///</summary>
[EnumString("thisYear")]
ThisYear,
///<summary>
///Last Year.
///<para>When the item is serialized out as xml, its value is "lastYear".</para>
///</summary>
[EnumString("lastYear")]
LastYear,
///<summary>
///Year To Date.
///<para>When the item is serialized out as xml, its value is "yearToDate".</para>
///</summary>
[EnumString("yearToDate")]
YearToDate,
///<summary>
///1st Quarter.
///<para>When the item is serialized out as xml, its value is "Q1".</para>
///</summary>
[EnumString("Q1")]
Quarter1,
///<summary>
///2nd Quarter.
///<para>When the item is serialized out as xml, its value is "Q2".</para>
///</summary>
[EnumString("Q2")]
Quarter2,
///<summary>
///3rd Quarter.
///<para>When the item is serialized out as xml, its value is "Q3".</para>
///</summary>
[EnumString("Q3")]
Quarter3,
///<summary>
///4th Quarter.
///<para>When the item is serialized out as xml, its value is "Q4".</para>
///</summary>
[EnumString("Q4")]
Quarter4,
///<summary>
///1st Month.
///<para>When the item is serialized out as xml, its value is "M1".</para>
///</summary>
[EnumString("M1")]
January,
///<summary>
///2nd Month.
///<para>When the item is serialized out as xml, its value is "M2".</para>
///</summary>
[EnumString("M2")]
February,
///<summary>
///3rd Month.
///<para>When the item is serialized out as xml, its value is "M3".</para>
///</summary>
[EnumString("M3")]
March,
///<summary>
///4th Month.
///<para>When the item is serialized out as xml, its value is "M4".</para>
///</summary>
[EnumString("M4")]
April,
///<summary>
///5th Month.
///<para>When the item is serialized out as xml, its value is "M5".</para>
///</summary>
[EnumString("M5")]
May,
///<summary>
///6th Month.
///<para>When the item is serialized out as xml, its value is "M6".</para>
///</summary>
[EnumString("M6")]
June,
///<summary>
///7th Month.
///<para>When the item is serialized out as xml, its value is "M7".</para>
///</summary>
[EnumString("M7")]
July,
///<summary>
///8th Month.
///<para>When the item is serialized out as xml, its value is "M8".</para>
///</summary>
[EnumString("M8")]
August,
///<summary>
///9th Month.
///<para>When the item is serialized out as xml, its value is "M9".</para>
///</summary>
[EnumString("M9")]
September,
///<summary>
///10th Month.
///<para>When the item is serialized out as xml, its value is "M10".</para>
///</summary>
[EnumString("M10")]
October,
///<summary>
///11th Month.
///<para>When the item is serialized out as xml, its value is "M11".</para>
///</summary>
[EnumString("M11")]
November,
///<summary>
///12th Month.
///<para>When the item is serialized out as xml, its value is "M12".</para>
///</summary>
[EnumString("M12")]
December,
 
}
/// <summary>
/// Icon Set Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum IconSetValues
{  
	///<summary>
///3 Arrows.
///<para>When the item is serialized out as xml, its value is "3Arrows".</para>
///</summary>
[EnumString("3Arrows")]
ThreeArrows,
///<summary>
///3 Arrows  (Gray).
///<para>When the item is serialized out as xml, its value is "3ArrowsGray".</para>
///</summary>
[EnumString("3ArrowsGray")]
ThreeArrowsGray,
///<summary>
///3 Flags.
///<para>When the item is serialized out as xml, its value is "3Flags".</para>
///</summary>
[EnumString("3Flags")]
ThreeFlags,
///<summary>
///3 Traffic Lights.
///<para>When the item is serialized out as xml, its value is "3TrafficLights1".</para>
///</summary>
[EnumString("3TrafficLights1")]
ThreeTrafficLights1,
///<summary>
///3 Traffic Lights Black.
///<para>When the item is serialized out as xml, its value is "3TrafficLights2".</para>
///</summary>
[EnumString("3TrafficLights2")]
ThreeTrafficLights2,
///<summary>
///3 Signs.
///<para>When the item is serialized out as xml, its value is "3Signs".</para>
///</summary>
[EnumString("3Signs")]
ThreeSigns,
///<summary>
///3 Symbols Circled.
///<para>When the item is serialized out as xml, its value is "3Symbols".</para>
///</summary>
[EnumString("3Symbols")]
ThreeSymbols,
///<summary>
///3 Symbols.
///<para>When the item is serialized out as xml, its value is "3Symbols2".</para>
///</summary>
[EnumString("3Symbols2")]
ThreeSymbols2,
///<summary>
///4 Arrows.
///<para>When the item is serialized out as xml, its value is "4Arrows".</para>
///</summary>
[EnumString("4Arrows")]
FourArrows,
///<summary>
///4 Arrows (Gray).
///<para>When the item is serialized out as xml, its value is "4ArrowsGray".</para>
///</summary>
[EnumString("4ArrowsGray")]
FourArrowsGray,
///<summary>
///4 Red To Black.
///<para>When the item is serialized out as xml, its value is "4RedToBlack".</para>
///</summary>
[EnumString("4RedToBlack")]
FourRedToBlack,
///<summary>
///4 Ratings.
///<para>When the item is serialized out as xml, its value is "4Rating".</para>
///</summary>
[EnumString("4Rating")]
FourRating,
///<summary>
///4 Traffic Lights.
///<para>When the item is serialized out as xml, its value is "4TrafficLights".</para>
///</summary>
[EnumString("4TrafficLights")]
FourTrafficLights,
///<summary>
///5 Arrows.
///<para>When the item is serialized out as xml, its value is "5Arrows".</para>
///</summary>
[EnumString("5Arrows")]
FiveArrows,
///<summary>
///5 Arrows (Gray).
///<para>When the item is serialized out as xml, its value is "5ArrowsGray".</para>
///</summary>
[EnumString("5ArrowsGray")]
FiveArrowsGray,
///<summary>
///5 Ratings Icon Set.
///<para>When the item is serialized out as xml, its value is "5Rating".</para>
///</summary>
[EnumString("5Rating")]
FiveRating,
///<summary>
///5 Quarters.
///<para>When the item is serialized out as xml, its value is "5Quarters".</para>
///</summary>
[EnumString("5Quarters")]
FiveQuarters,
 
}
/// <summary>
/// Sort By 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SortByValues
{  
	///<summary>
///Value.
///<para>When the item is serialized out as xml, its value is "value".</para>
///</summary>
[EnumString("value")]
Value,
///<summary>
///Sort by Cell Color.
///<para>When the item is serialized out as xml, its value is "cellColor".</para>
///</summary>
[EnumString("cellColor")]
CellColor,
///<summary>
///Sort by Font Color.
///<para>When the item is serialized out as xml, its value is "fontColor".</para>
///</summary>
[EnumString("fontColor")]
FontColor,
///<summary>
///Sort by Icon.
///<para>When the item is serialized out as xml, its value is "icon".</para>
///</summary>
[EnumString("icon")]
Icon,
 
}
/// <summary>
/// Sort Method 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SortMethodValues
{  
	///<summary>
///Sort by Stroke.
///<para>When the item is serialized out as xml, its value is "stroke".</para>
///</summary>
[EnumString("stroke")]
Stroke,
///<summary>
///PinYin Sort.
///<para>When the item is serialized out as xml, its value is "pinYin".</para>
///</summary>
[EnumString("pinYin")]
PinYin,
///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Calendar Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CalendarValues
{  
	///<summary>
///No Calendar Type.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Gregorian.
///<para>When the item is serialized out as xml, its value is "gregorian".</para>
///</summary>
[EnumString("gregorian")]
Gregorian,
///<summary>
///Gregorian (U.S.) Calendar.
///<para>When the item is serialized out as xml, its value is "gregorianUs".</para>
///</summary>
[EnumString("gregorianUs")]
GregorianUs,
///<summary>
///Japanese Emperor Era Calendar.
///<para>When the item is serialized out as xml, its value is "japan".</para>
///</summary>
[EnumString("japan")]
Japan,
///<summary>
///Taiwan Era Calendar.
///<para>When the item is serialized out as xml, its value is "taiwan".</para>
///</summary>
[EnumString("taiwan")]
Taiwan,
///<summary>
///Korean Tangun Era Calendar.
///<para>When the item is serialized out as xml, its value is "korea".</para>
///</summary>
[EnumString("korea")]
Korea,
///<summary>
///Hijri (Arabic Lunar) Calendar.
///<para>When the item is serialized out as xml, its value is "hijri".</para>
///</summary>
[EnumString("hijri")]
Hijri,
///<summary>
///Thai Calendar.
///<para>When the item is serialized out as xml, its value is "thai".</para>
///</summary>
[EnumString("thai")]
Thai,
///<summary>
///Hebrew (Lunar) Calendar.
///<para>When the item is serialized out as xml, its value is "hebrew".</para>
///</summary>
[EnumString("hebrew")]
Hebrew,
///<summary>
///Gregorian Middle East French Calendar.
///<para>When the item is serialized out as xml, its value is "gregorianMeFrench".</para>
///</summary>
[EnumString("gregorianMeFrench")]
GregorianMiddleEastFrench,
///<summary>
///Gregorian Arabic Calendar.
///<para>When the item is serialized out as xml, its value is "gregorianArabic".</para>
///</summary>
[EnumString("gregorianArabic")]
GregorianArabic,
///<summary>
///Gregorian Transliterated English Calendar.
///<para>When the item is serialized out as xml, its value is "gregorianXlitEnglish".</para>
///</summary>
[EnumString("gregorianXlitEnglish")]
GregorianTransliteratedEnglish,
///<summary>
///Gregorian Transliterated French Calendar.
///<para>When the item is serialized out as xml, its value is "gregorianXlitFrench".</para>
///</summary>
[EnumString("gregorianXlitFrench")]
GregorianTransliteratedFrench,
 
}
/// <summary>
/// Date Time Grouping 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DateTimeGroupingValues
{  
	///<summary>
///Group by Year.
///<para>When the item is serialized out as xml, its value is "year".</para>
///</summary>
[EnumString("year")]
Year,
///<summary>
///Month.
///<para>When the item is serialized out as xml, its value is "month".</para>
///</summary>
[EnumString("month")]
Month,
///<summary>
///Day.
///<para>When the item is serialized out as xml, its value is "day".</para>
///</summary>
[EnumString("day")]
Day,
///<summary>
///Group by Hour.
///<para>When the item is serialized out as xml, its value is "hour".</para>
///</summary>
[EnumString("hour")]
Hour,
///<summary>
///Group by Minute.
///<para>When the item is serialized out as xml, its value is "minute".</para>
///</summary>
[EnumString("minute")]
Minute,
///<summary>
///Second.
///<para>When the item is serialized out as xml, its value is "second".</para>
///</summary>
[EnumString("second")]
Second,
 
}
/// <summary>
/// HTML Formatting Handling 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HtmlFormattingValues
{  
	///<summary>
///No Formatting.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Honor Rich Text.
///<para>When the item is serialized out as xml, its value is "rtf".</para>
///</summary>
[EnumString("rtf")]
HonorRichText,
///<summary>
///All.
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
 
}
/// <summary>
/// Parameter Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ParameterValues
{  
	///<summary>
///Prompt on Refresh.
///<para>When the item is serialized out as xml, its value is "prompt".</para>
///</summary>
[EnumString("prompt")]
Prompt,
///<summary>
///Value.
///<para>When the item is serialized out as xml, its value is "value".</para>
///</summary>
[EnumString("value")]
Value,
///<summary>
///Parameter From Cell.
///<para>When the item is serialized out as xml, its value is "cell".</para>
///</summary>
[EnumString("cell")]
Cell,
 
}
/// <summary>
/// File Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FileTypeValues
{  
	///<summary>
///Macintosh.
///<para>When the item is serialized out as xml, its value is "mac".</para>
///</summary>
[EnumString("mac")]
Mac,
///<summary>
///Windows (ANSI).
///<para>When the item is serialized out as xml, its value is "win".</para>
///</summary>
[EnumString("win")]
Win,
///<summary>
///DOS.
///<para>When the item is serialized out as xml, its value is "dos".</para>
///</summary>
[EnumString("dos")]
Dos,
 
}
/// <summary>
/// Qualifier 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum QualifierValues
{  
	///<summary>
///Double Quote.
///<para>When the item is serialized out as xml, its value is "doubleQuote".</para>
///</summary>
[EnumString("doubleQuote")]
DoubleQuote,
///<summary>
///Single Quote.
///<para>When the item is serialized out as xml, its value is "singleQuote".</para>
///</summary>
[EnumString("singleQuote")]
SingleQuote,
///<summary>
///No Text Qualifier.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Text Field Datatype 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ExternalConnectionValues
{  
	///<summary>
///General.
///<para>When the item is serialized out as xml, its value is "general".</para>
///</summary>
[EnumString("general")]
General,
///<summary>
///Text.
///<para>When the item is serialized out as xml, its value is "text".</para>
///</summary>
[EnumString("text")]
Text,
///<summary>
///Month Day Year.
///<para>When the item is serialized out as xml, its value is "MDY".</para>
///</summary>
[EnumString("MDY")]
MonthDayYear,
///<summary>
///Day Month Year.
///<para>When the item is serialized out as xml, its value is "DMY".</para>
///</summary>
[EnumString("DMY")]
DayMonthYear,
///<summary>
///Year Month Day.
///<para>When the item is serialized out as xml, its value is "YMD".</para>
///</summary>
[EnumString("YMD")]
YearMonthDay,
///<summary>
///Month Day Year.
///<para>When the item is serialized out as xml, its value is "MYD".</para>
///</summary>
[EnumString("MYD")]
MonthYearDay,
///<summary>
///Day Year Month.
///<para>When the item is serialized out as xml, its value is "DYM".</para>
///</summary>
[EnumString("DYM")]
DayYearMonth,
///<summary>
///Year Day Month.
///<para>When the item is serialized out as xml, its value is "YDM".</para>
///</summary>
[EnumString("YDM")]
YearDayMonth,
///<summary>
///Skip Field.
///<para>When the item is serialized out as xml, its value is "skip".</para>
///</summary>
[EnumString("skip")]
Skip,
///<summary>
///East Asian Year Month Day.
///<para>When the item is serialized out as xml, its value is "EMD".</para>
///</summary>
[EnumString("EMD")]
EMD,
 
}
/// <summary>
/// Credentials Method 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CredentialsMethodValues
{  
	///<summary>
///Integrated Authentication.
///<para>When the item is serialized out as xml, its value is "integrated".</para>
///</summary>
[EnumString("integrated")]
Integrated,
///<summary>
///No Credentials.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Stored Credentials.
///<para>When the item is serialized out as xml, its value is "stored".</para>
///</summary>
[EnumString("stored")]
Stored,
 
}
/// <summary>
/// PivotCache Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SourceValues
{  
	///<summary>
///Worksheet.
///<para>When the item is serialized out as xml, its value is "worksheet".</para>
///</summary>
[EnumString("worksheet")]
Worksheet,
///<summary>
///External.
///<para>When the item is serialized out as xml, its value is "external".</para>
///</summary>
[EnumString("external")]
External,
///<summary>
///Consolidation Ranges.
///<para>When the item is serialized out as xml, its value is "consolidation".</para>
///</summary>
[EnumString("consolidation")]
Consolidation,
///<summary>
///Scenario Summary Report.
///<para>When the item is serialized out as xml, its value is "scenario".</para>
///</summary>
[EnumString("scenario")]
Scenario,
 
}
/// <summary>
/// Values Group By 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum GroupByValues
{  
	///<summary>
///Group By Numeric Ranges.
///<para>When the item is serialized out as xml, its value is "range".</para>
///</summary>
[EnumString("range")]
Range,
///<summary>
///Seconds.
///<para>When the item is serialized out as xml, its value is "seconds".</para>
///</summary>
[EnumString("seconds")]
Seconds,
///<summary>
///Minutes.
///<para>When the item is serialized out as xml, its value is "minutes".</para>
///</summary>
[EnumString("minutes")]
Minutes,
///<summary>
///Hours.
///<para>When the item is serialized out as xml, its value is "hours".</para>
///</summary>
[EnumString("hours")]
Hours,
///<summary>
///Days.
///<para>When the item is serialized out as xml, its value is "days".</para>
///</summary>
[EnumString("days")]
Days,
///<summary>
///Months.
///<para>When the item is serialized out as xml, its value is "months".</para>
///</summary>
[EnumString("months")]
Months,
///<summary>
///Quarters.
///<para>When the item is serialized out as xml, its value is "quarters".</para>
///</summary>
[EnumString("quarters")]
Quarters,
///<summary>
///Years.
///<para>When the item is serialized out as xml, its value is "years".</para>
///</summary>
[EnumString("years")]
Years,
 
}
/// <summary>
/// Set Sort Order 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SortValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Ascending.
///<para>When the item is serialized out as xml, its value is "ascending".</para>
///</summary>
[EnumString("ascending")]
Ascending,
///<summary>
///Descending.
///<para>When the item is serialized out as xml, its value is "descending".</para>
///</summary>
[EnumString("descending")]
Descending,
///<summary>
///Ascending Alpha.
///<para>When the item is serialized out as xml, its value is "ascendingAlpha".</para>
///</summary>
[EnumString("ascendingAlpha")]
AscendingAlpha,
///<summary>
///Alphabetic Order Descending.
///<para>When the item is serialized out as xml, its value is "descendingAlpha".</para>
///</summary>
[EnumString("descendingAlpha")]
DescendingAlpha,
///<summary>
///Ascending Natural.
///<para>When the item is serialized out as xml, its value is "ascendingNatural".</para>
///</summary>
[EnumString("ascendingNatural")]
AscendingNatural,
///<summary>
///Natural Order Descending.
///<para>When the item is serialized out as xml, its value is "descendingNatural".</para>
///</summary>
[EnumString("descendingNatural")]
DescendingNatural,
 
}
/// <summary>
/// Conditional Formatting Scope 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ScopeValues
{  
	///<summary>
///Selection.
///<para>When the item is serialized out as xml, its value is "selection".</para>
///</summary>
[EnumString("selection")]
Selection,
///<summary>
///Data Fields.
///<para>When the item is serialized out as xml, its value is "data".</para>
///</summary>
[EnumString("data")]
Data,
///<summary>
///Field Intersections.
///<para>When the item is serialized out as xml, its value is "field".</para>
///</summary>
[EnumString("field")]
Field,
 
}
/// <summary>
/// Top N Evaluation Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RuleValues
{  
	///<summary>
///Top N None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///All.
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
///<summary>
///Row Top N.
///<para>When the item is serialized out as xml, its value is "row".</para>
///</summary>
[EnumString("row")]
Row,
///<summary>
///Column Top N.
///<para>When the item is serialized out as xml, its value is "column".</para>
///</summary>
[EnumString("column")]
Column,
 
}
/// <summary>
/// Show Data As 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ShowDataAsValues
{  
	///<summary>
///Normal Data Type.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Difference.
///<para>When the item is serialized out as xml, its value is "difference".</para>
///</summary>
[EnumString("difference")]
Difference,
///<summary>
///Percentage Of.
///<para>When the item is serialized out as xml, its value is "percent".</para>
///</summary>
[EnumString("percent")]
Percent,
///<summary>
///Percentage Difference.
///<para>When the item is serialized out as xml, its value is "percentDiff".</para>
///</summary>
[EnumString("percentDiff")]
PercentageDifference,
///<summary>
///Running Total.
///<para>When the item is serialized out as xml, its value is "runTotal".</para>
///</summary>
[EnumString("runTotal")]
RunTotal,
///<summary>
///Percentage of Row.
///<para>When the item is serialized out as xml, its value is "percentOfRow".</para>
///</summary>
[EnumString("percentOfRow")]
PercentOfRaw,
///<summary>
///Percent of Column.
///<para>When the item is serialized out as xml, its value is "percentOfCol".</para>
///</summary>
[EnumString("percentOfCol")]
PercentOfColumn,
///<summary>
///Percentage of Total.
///<para>When the item is serialized out as xml, its value is "percentOfTotal".</para>
///</summary>
[EnumString("percentOfTotal")]
PercentOfTotal,
///<summary>
///Index.
///<para>When the item is serialized out as xml, its value is "index".</para>
///</summary>
[EnumString("index")]
Index,
 
}
/// <summary>
/// PivotItem Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ItemValues
{  
	///<summary>
///Data.
///<para>When the item is serialized out as xml, its value is "data".</para>
///</summary>
[EnumString("data")]
Data,
///<summary>
///Default.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///Sum.
///<para>When the item is serialized out as xml, its value is "sum".</para>
///</summary>
[EnumString("sum")]
Sum,
///<summary>
///CountA.
///<para>When the item is serialized out as xml, its value is "countA".</para>
///</summary>
[EnumString("countA")]
CountA,
///<summary>
///Average.
///<para>When the item is serialized out as xml, its value is "avg".</para>
///</summary>
[EnumString("avg")]
Average,
///<summary>
///Max.
///<para>When the item is serialized out as xml, its value is "max".</para>
///</summary>
[EnumString("max")]
Maximum,
///<summary>
///Min.
///<para>When the item is serialized out as xml, its value is "min".</para>
///</summary>
[EnumString("min")]
Minimum,
///<summary>
///Product.
///<para>When the item is serialized out as xml, its value is "product".</para>
///</summary>
[EnumString("product")]
Product,
///<summary>
///Count.
///<para>When the item is serialized out as xml, its value is "count".</para>
///</summary>
[EnumString("count")]
Count,
///<summary>
///stdDev.
///<para>When the item is serialized out as xml, its value is "stdDev".</para>
///</summary>
[EnumString("stdDev")]
StandardDeviation,
///<summary>
///StdDevP.
///<para>When the item is serialized out as xml, its value is "stdDevP".</para>
///</summary>
[EnumString("stdDevP")]
StandardDeviationP,
///<summary>
///Var.
///<para>When the item is serialized out as xml, its value is "var".</para>
///</summary>
[EnumString("var")]
Variance,
///<summary>
///VarP.
///<para>When the item is serialized out as xml, its value is "varP".</para>
///</summary>
[EnumString("varP")]
VarianceP,
///<summary>
///Grand Total Item.
///<para>When the item is serialized out as xml, its value is "grand".</para>
///</summary>
[EnumString("grand")]
Grand,
///<summary>
///Blank Pivot Item.
///<para>When the item is serialized out as xml, its value is "blank".</para>
///</summary>
[EnumString("blank")]
Blank,
 
}
/// <summary>
/// Field Sort Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FieldSortValues
{  
	///<summary>
///Manual Sort.
///<para>When the item is serialized out as xml, its value is "manual".</para>
///</summary>
[EnumString("manual")]
Manual,
///<summary>
///Ascending.
///<para>When the item is serialized out as xml, its value is "ascending".</para>
///</summary>
[EnumString("ascending")]
Ascending,
///<summary>
///Descending.
///<para>When the item is serialized out as xml, its value is "descending".</para>
///</summary>
[EnumString("descending")]
Descending,
 
}
/// <summary>
/// Pivot Filter Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PivotFilterValues
{  
	///<summary>
///Unknown.
///<para>When the item is serialized out as xml, its value is "unknown".</para>
///</summary>
[EnumString("unknown")]
Unknown,
///<summary>
///Count.
///<para>When the item is serialized out as xml, its value is "count".</para>
///</summary>
[EnumString("count")]
Count,
///<summary>
///Percent.
///<para>When the item is serialized out as xml, its value is "percent".</para>
///</summary>
[EnumString("percent")]
Percent,
///<summary>
///Sum.
///<para>When the item is serialized out as xml, its value is "sum".</para>
///</summary>
[EnumString("sum")]
Sum,
///<summary>
///Caption Equals.
///<para>When the item is serialized out as xml, its value is "captionEqual".</para>
///</summary>
[EnumString("captionEqual")]
CaptionEqual,
///<summary>
///Caption Not Equal.
///<para>When the item is serialized out as xml, its value is "captionNotEqual".</para>
///</summary>
[EnumString("captionNotEqual")]
CaptionNotEqual,
///<summary>
///Caption Begins With.
///<para>When the item is serialized out as xml, its value is "captionBeginsWith".</para>
///</summary>
[EnumString("captionBeginsWith")]
CaptionBeginsWith,
///<summary>
///Caption Does Not Begin With.
///<para>When the item is serialized out as xml, its value is "captionNotBeginsWith".</para>
///</summary>
[EnumString("captionNotBeginsWith")]
CaptionNotBeginsWith,
///<summary>
///Caption Ends With.
///<para>When the item is serialized out as xml, its value is "captionEndsWith".</para>
///</summary>
[EnumString("captionEndsWith")]
CaptionEndsWith,
///<summary>
///Caption Does Not End With.
///<para>When the item is serialized out as xml, its value is "captionNotEndsWith".</para>
///</summary>
[EnumString("captionNotEndsWith")]
CaptionNotEndsWith,
///<summary>
///Caption Contains.
///<para>When the item is serialized out as xml, its value is "captionContains".</para>
///</summary>
[EnumString("captionContains")]
CaptionContains,
///<summary>
///Caption Does Not Contain.
///<para>When the item is serialized out as xml, its value is "captionNotContains".</para>
///</summary>
[EnumString("captionNotContains")]
CaptionNotContains,
///<summary>
///Caption Is Greater Than.
///<para>When the item is serialized out as xml, its value is "captionGreaterThan".</para>
///</summary>
[EnumString("captionGreaterThan")]
CaptionGreaterThan,
///<summary>
///Caption Is Greater Than Or Equal To.
///<para>When the item is serialized out as xml, its value is "captionGreaterThanOrEqual".</para>
///</summary>
[EnumString("captionGreaterThanOrEqual")]
CaptionGreaterThanOrEqual,
///<summary>
///Caption Is Less Than.
///<para>When the item is serialized out as xml, its value is "captionLessThan".</para>
///</summary>
[EnumString("captionLessThan")]
CaptionLessThan,
///<summary>
///Caption Is Less Than Or Equal To.
///<para>When the item is serialized out as xml, its value is "captionLessThanOrEqual".</para>
///</summary>
[EnumString("captionLessThanOrEqual")]
CaptionLessThanOrEqual,
///<summary>
///Caption Is Between.
///<para>When the item is serialized out as xml, its value is "captionBetween".</para>
///</summary>
[EnumString("captionBetween")]
CaptionBetween,
///<summary>
///Caption Is Not Between.
///<para>When the item is serialized out as xml, its value is "captionNotBetween".</para>
///</summary>
[EnumString("captionNotBetween")]
CaptionNotBetween,
///<summary>
///Value Equal.
///<para>When the item is serialized out as xml, its value is "valueEqual".</para>
///</summary>
[EnumString("valueEqual")]
ValueEqual,
///<summary>
///Value Not Equal.
///<para>When the item is serialized out as xml, its value is "valueNotEqual".</para>
///</summary>
[EnumString("valueNotEqual")]
ValueNotEqual,
///<summary>
///Value Greater Than.
///<para>When the item is serialized out as xml, its value is "valueGreaterThan".</para>
///</summary>
[EnumString("valueGreaterThan")]
ValueGreaterThan,
///<summary>
///Value Greater Than Or Equal To.
///<para>When the item is serialized out as xml, its value is "valueGreaterThanOrEqual".</para>
///</summary>
[EnumString("valueGreaterThanOrEqual")]
ValueGreaterThanOrEqual,
///<summary>
///Value Less Than.
///<para>When the item is serialized out as xml, its value is "valueLessThan".</para>
///</summary>
[EnumString("valueLessThan")]
ValueLessThan,
///<summary>
///Value Less Than Or Equal To.
///<para>When the item is serialized out as xml, its value is "valueLessThanOrEqual".</para>
///</summary>
[EnumString("valueLessThanOrEqual")]
ValueLessThanOrEqual,
///<summary>
///Value Between.
///<para>When the item is serialized out as xml, its value is "valueBetween".</para>
///</summary>
[EnumString("valueBetween")]
ValueBetween,
///<summary>
///Value Not Between.
///<para>When the item is serialized out as xml, its value is "valueNotBetween".</para>
///</summary>
[EnumString("valueNotBetween")]
ValueNotBetween,
///<summary>
///Date Equals.
///<para>When the item is serialized out as xml, its value is "dateEqual".</para>
///</summary>
[EnumString("dateEqual")]
DateEqual,
///<summary>
///Date Does Not Equal.
///<para>When the item is serialized out as xml, its value is "dateNotEqual".</para>
///</summary>
[EnumString("dateNotEqual")]
DateNotEqual,
///<summary>
///Date Older Than.
///<para>When the item is serialized out as xml, its value is "dateOlderThan".</para>
///</summary>
[EnumString("dateOlderThan")]
DateOlderThan,
///<summary>
///Date Older Than Or Equal.
///<para>When the item is serialized out as xml, its value is "dateOlderThanOrEqual".</para>
///</summary>
[EnumString("dateOlderThanOrEqual")]
DateOlderThanOrEqual,
///<summary>
///Date Newer Than.
///<para>When the item is serialized out as xml, its value is "dateNewerThan".</para>
///</summary>
[EnumString("dateNewerThan")]
DateNewerThan,
///<summary>
///Date Newer Than or Equal To.
///<para>When the item is serialized out as xml, its value is "dateNewerThanOrEqual".</para>
///</summary>
[EnumString("dateNewerThanOrEqual")]
DateNewerThanOrEqual,
///<summary>
///Date Between.
///<para>When the item is serialized out as xml, its value is "dateBetween".</para>
///</summary>
[EnumString("dateBetween")]
DateBetween,
///<summary>
///Date Not Between.
///<para>When the item is serialized out as xml, its value is "dateNotBetween".</para>
///</summary>
[EnumString("dateNotBetween")]
DateNotBetween,
///<summary>
///Tomorrow.
///<para>When the item is serialized out as xml, its value is "tomorrow".</para>
///</summary>
[EnumString("tomorrow")]
Tomorrow,
///<summary>
///Today.
///<para>When the item is serialized out as xml, its value is "today".</para>
///</summary>
[EnumString("today")]
Today,
///<summary>
///Yesterday.
///<para>When the item is serialized out as xml, its value is "yesterday".</para>
///</summary>
[EnumString("yesterday")]
Yesterday,
///<summary>
///Next Week.
///<para>When the item is serialized out as xml, its value is "nextWeek".</para>
///</summary>
[EnumString("nextWeek")]
NextWeek,
///<summary>
///This Week.
///<para>When the item is serialized out as xml, its value is "thisWeek".</para>
///</summary>
[EnumString("thisWeek")]
ThisWeek,
///<summary>
///Last Week.
///<para>When the item is serialized out as xml, its value is "lastWeek".</para>
///</summary>
[EnumString("lastWeek")]
LastWeek,
///<summary>
///Next Month.
///<para>When the item is serialized out as xml, its value is "nextMonth".</para>
///</summary>
[EnumString("nextMonth")]
NextMonth,
///<summary>
///This Month.
///<para>When the item is serialized out as xml, its value is "thisMonth".</para>
///</summary>
[EnumString("thisMonth")]
ThisMonth,
///<summary>
///Last Month.
///<para>When the item is serialized out as xml, its value is "lastMonth".</para>
///</summary>
[EnumString("lastMonth")]
LastMonth,
///<summary>
///Next Quarter.
///<para>When the item is serialized out as xml, its value is "nextQuarter".</para>
///</summary>
[EnumString("nextQuarter")]
NextQuarter,
///<summary>
///This Quarter.
///<para>When the item is serialized out as xml, its value is "thisQuarter".</para>
///</summary>
[EnumString("thisQuarter")]
ThisQuarter,
///<summary>
///Last Quarter.
///<para>When the item is serialized out as xml, its value is "lastQuarter".</para>
///</summary>
[EnumString("lastQuarter")]
LastQuarter,
///<summary>
///Next Year.
///<para>When the item is serialized out as xml, its value is "nextYear".</para>
///</summary>
[EnumString("nextYear")]
NextYear,
///<summary>
///This Year.
///<para>When the item is serialized out as xml, its value is "thisYear".</para>
///</summary>
[EnumString("thisYear")]
ThisYear,
///<summary>
///Last Year.
///<para>When the item is serialized out as xml, its value is "lastYear".</para>
///</summary>
[EnumString("lastYear")]
LastYear,
///<summary>
///Year-To-Date.
///<para>When the item is serialized out as xml, its value is "yearToDate".</para>
///</summary>
[EnumString("yearToDate")]
YearToDate,
///<summary>
///First Quarter.
///<para>When the item is serialized out as xml, its value is "Q1".</para>
///</summary>
[EnumString("Q1")]
Quarter1,
///<summary>
///Second Quarter.
///<para>When the item is serialized out as xml, its value is "Q2".</para>
///</summary>
[EnumString("Q2")]
Quarter2,
///<summary>
///Third Quarter.
///<para>When the item is serialized out as xml, its value is "Q3".</para>
///</summary>
[EnumString("Q3")]
Quarter3,
///<summary>
///Fourth Quarter.
///<para>When the item is serialized out as xml, its value is "Q4".</para>
///</summary>
[EnumString("Q4")]
Quarter4,
///<summary>
///January.
///<para>When the item is serialized out as xml, its value is "M1".</para>
///</summary>
[EnumString("M1")]
January,
///<summary>
///Dates in February.
///<para>When the item is serialized out as xml, its value is "M2".</para>
///</summary>
[EnumString("M2")]
February,
///<summary>
///Dates in March.
///<para>When the item is serialized out as xml, its value is "M3".</para>
///</summary>
[EnumString("M3")]
March,
///<summary>
///Dates in April.
///<para>When the item is serialized out as xml, its value is "M4".</para>
///</summary>
[EnumString("M4")]
April,
///<summary>
///Dates in May.
///<para>When the item is serialized out as xml, its value is "M5".</para>
///</summary>
[EnumString("M5")]
May,
///<summary>
///Dates in June.
///<para>When the item is serialized out as xml, its value is "M6".</para>
///</summary>
[EnumString("M6")]
June,
///<summary>
///Dates in July.
///<para>When the item is serialized out as xml, its value is "M7".</para>
///</summary>
[EnumString("M7")]
July,
///<summary>
///Dates in August.
///<para>When the item is serialized out as xml, its value is "M8".</para>
///</summary>
[EnumString("M8")]
August,
///<summary>
///Dates in September.
///<para>When the item is serialized out as xml, its value is "M9".</para>
///</summary>
[EnumString("M9")]
September,
///<summary>
///Dates in October.
///<para>When the item is serialized out as xml, its value is "M10".</para>
///</summary>
[EnumString("M10")]
October,
///<summary>
///Dates in November.
///<para>When the item is serialized out as xml, its value is "M11".</para>
///</summary>
[EnumString("M11")]
November,
///<summary>
///Dates in December.
///<para>When the item is serialized out as xml, its value is "M12".</para>
///</summary>
[EnumString("M12")]
December,
 
}
/// <summary>
/// PivotTable Format Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FormatActionValues
{  
	///<summary>
///Blank.
///<para>When the item is serialized out as xml, its value is "blank".</para>
///</summary>
[EnumString("blank")]
Blank,
///<summary>
///Formatting.
///<para>When the item is serialized out as xml, its value is "formatting".</para>
///</summary>
[EnumString("formatting")]
Formatting,
 
}
/// <summary>
/// PivotTable Axis 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PivotTableAxisValues
{  
	///<summary>
///Row Axis.
///<para>When the item is serialized out as xml, its value is "axisRow".</para>
///</summary>
[EnumString("axisRow")]
AxisRow,
///<summary>
///Column Axis.
///<para>When the item is serialized out as xml, its value is "axisCol".</para>
///</summary>
[EnumString("axisCol")]
AxisColumn,
///<summary>
///Include Count Filter.
///<para>When the item is serialized out as xml, its value is "axisPage".</para>
///</summary>
[EnumString("axisPage")]
AxisPage,
///<summary>
///Values Axis.
///<para>When the item is serialized out as xml, its value is "axisValues".</para>
///</summary>
[EnumString("axisValues")]
AxisValues,
 
}
/// <summary>
/// Grow Shrink Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum GrowShrinkValues
{  
	///<summary>
///Insert and Delete On Refresh.
///<para>When the item is serialized out as xml, its value is "insertDelete".</para>
///</summary>
[EnumString("insertDelete")]
InsertDelete,
///<summary>
///Insert and Clear On Refresh.
///<para>When the item is serialized out as xml, its value is "insertClear".</para>
///</summary>
[EnumString("insertClear")]
InsertClear,
///<summary>
///Overwrite and Clear On Refresh.
///<para>When the item is serialized out as xml, its value is "overwriteClear".</para>
///</summary>
[EnumString("overwriteClear")]
OverwriteClear,
 
}
/// <summary>
/// Phonetic Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PhoneticValues
{  
	///<summary>
///Half-Width Katakana.
///<para>When the item is serialized out as xml, its value is "halfwidthKatakana".</para>
///</summary>
[EnumString("halfwidthKatakana")]
HalfWidthKatakana,
///<summary>
///Full-Width Katakana.
///<para>When the item is serialized out as xml, its value is "fullwidthKatakana".</para>
///</summary>
[EnumString("fullwidthKatakana")]
FullWidthKatakana,
///<summary>
///Hiragana.
///<para>When the item is serialized out as xml, its value is "Hiragana".</para>
///</summary>
[EnumString("Hiragana")]
Hiragana,
///<summary>
///No Conversion.
///<para>When the item is serialized out as xml, its value is "noConversion".</para>
///</summary>
[EnumString("noConversion")]
NoConversion,
 
}
/// <summary>
/// Phonetic Alignment Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PhoneticAlignmentValues
{  
	///<summary>
///No Control.
///<para>When the item is serialized out as xml, its value is "noControl".</para>
///</summary>
[EnumString("noControl")]
NoControl,
///<summary>
///Left Alignment.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Center Alignment.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Distributed.
///<para>When the item is serialized out as xml, its value is "distributed".</para>
///</summary>
[EnumString("distributed")]
Distributed,
 
}
/// <summary>
/// Row Column Action Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RowColumnActionValues
{  
	///<summary>
///Insert Row.
///<para>When the item is serialized out as xml, its value is "insertRow".</para>
///</summary>
[EnumString("insertRow")]
InsertRow,
///<summary>
///Delete Row.
///<para>When the item is serialized out as xml, its value is "deleteRow".</para>
///</summary>
[EnumString("deleteRow")]
DeleteRow,
///<summary>
///Column Insert.
///<para>When the item is serialized out as xml, its value is "insertCol".</para>
///</summary>
[EnumString("insertCol")]
ColumnInsert,
///<summary>
///Delete Column.
///<para>When the item is serialized out as xml, its value is "deleteCol".</para>
///</summary>
[EnumString("deleteCol")]
DeleteColumn,
 
}
/// <summary>
/// Revision Action Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum RevisionActionValues
{  
	///<summary>
///Add.
///<para>When the item is serialized out as xml, its value is "add".</para>
///</summary>
[EnumString("add")]
Add,
///<summary>
///Delete.
///<para>When the item is serialized out as xml, its value is "delete".</para>
///</summary>
[EnumString("delete")]
Delete,
 
}
/// <summary>
/// Formula Expression Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FormulaExpressionValues
{  
	///<summary>
///Reference.
///<para>When the item is serialized out as xml, its value is "ref".</para>
///</summary>
[EnumString("ref")]
Reference,
///<summary>
///Reference Is Error.
///<para>When the item is serialized out as xml, its value is "refError".</para>
///</summary>
[EnumString("refError")]
ReferenceError,
///<summary>
///Area.
///<para>When the item is serialized out as xml, its value is "area".</para>
///</summary>
[EnumString("area")]
Area,
///<summary>
///Area Error.
///<para>When the item is serialized out as xml, its value is "areaError".</para>
///</summary>
[EnumString("areaError")]
AreaError,
///<summary>
///Computed Area.
///<para>When the item is serialized out as xml, its value is "computedArea".</para>
///</summary>
[EnumString("computedArea")]
ComputedArea,
 
}
/// <summary>
/// Formula Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CellFormulaValues
{  
	///<summary>
///Normal.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Array Entered.
///<para>When the item is serialized out as xml, its value is "array".</para>
///</summary>
[EnumString("array")]
Array,
///<summary>
///Table Formula.
///<para>When the item is serialized out as xml, its value is "dataTable".</para>
///</summary>
[EnumString("dataTable")]
DataTable,
///<summary>
///Shared Formula.
///<para>When the item is serialized out as xml, its value is "shared".</para>
///</summary>
[EnumString("shared")]
Shared,
 
}
/// <summary>
/// Pane Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PaneValues
{  
	///<summary>
///Bottom Right Pane.
///<para>When the item is serialized out as xml, its value is "bottomRight".</para>
///</summary>
[EnumString("bottomRight")]
BottomRight,
///<summary>
///Top Right Pane.
///<para>When the item is serialized out as xml, its value is "topRight".</para>
///</summary>
[EnumString("topRight")]
TopRight,
///<summary>
///Bottom Left Pane.
///<para>When the item is serialized out as xml, its value is "bottomLeft".</para>
///</summary>
[EnumString("bottomLeft")]
BottomLeft,
///<summary>
///Top Left Pane.
///<para>When the item is serialized out as xml, its value is "topLeft".</para>
///</summary>
[EnumString("topLeft")]
TopLeft,
 
}
/// <summary>
/// Sheet View Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SheetViewValues
{  
	///<summary>
///Normal View.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Page Break Preview.
///<para>When the item is serialized out as xml, its value is "pageBreakPreview".</para>
///</summary>
[EnumString("pageBreakPreview")]
PageBreakPreview,
///<summary>
///Page Layout View.
///<para>When the item is serialized out as xml, its value is "pageLayout".</para>
///</summary>
[EnumString("pageLayout")]
PageLayout,
 
}
/// <summary>
/// Data Consolidation Functions 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataConsolidateFunctionValues
{  
	///<summary>
///Average.
///<para>When the item is serialized out as xml, its value is "average".</para>
///</summary>
[EnumString("average")]
Average,
///<summary>
///Count.
///<para>When the item is serialized out as xml, its value is "count".</para>
///</summary>
[EnumString("count")]
Count,
///<summary>
///CountNums.
///<para>When the item is serialized out as xml, its value is "countNums".</para>
///</summary>
[EnumString("countNums")]
CountNumbers,
///<summary>
///Maximum.
///<para>When the item is serialized out as xml, its value is "max".</para>
///</summary>
[EnumString("max")]
Maximum,
///<summary>
///Minimum.
///<para>When the item is serialized out as xml, its value is "min".</para>
///</summary>
[EnumString("min")]
Minimum,
///<summary>
///Product.
///<para>When the item is serialized out as xml, its value is "product".</para>
///</summary>
[EnumString("product")]
Product,
///<summary>
///StdDev.
///<para>When the item is serialized out as xml, its value is "stdDev".</para>
///</summary>
[EnumString("stdDev")]
StandardDeviation,
///<summary>
///StdDevP.
///<para>When the item is serialized out as xml, its value is "stdDevp".</para>
///</summary>
[EnumString("stdDevp")]
StandardDeviationP,
///<summary>
///Sum.
///<para>When the item is serialized out as xml, its value is "sum".</para>
///</summary>
[EnumString("sum")]
Sum,
///<summary>
///Variance.
///<para>When the item is serialized out as xml, its value is "var".</para>
///</summary>
[EnumString("var")]
Variance,
///<summary>
///VarP.
///<para>When the item is serialized out as xml, its value is "varp".</para>
///</summary>
[EnumString("varp")]
VarianceP,
 
}
/// <summary>
/// Data Validation Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataValidationValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Whole Number.
///<para>When the item is serialized out as xml, its value is "whole".</para>
///</summary>
[EnumString("whole")]
Whole,
///<summary>
///Decimal.
///<para>When the item is serialized out as xml, its value is "decimal".</para>
///</summary>
[EnumString("decimal")]
Decimal,
///<summary>
///List.
///<para>When the item is serialized out as xml, its value is "list".</para>
///</summary>
[EnumString("list")]
List,
///<summary>
///Date.
///<para>When the item is serialized out as xml, its value is "date".</para>
///</summary>
[EnumString("date")]
Date,
///<summary>
///Time.
///<para>When the item is serialized out as xml, its value is "time".</para>
///</summary>
[EnumString("time")]
Time,
///<summary>
///Text Length.
///<para>When the item is serialized out as xml, its value is "textLength".</para>
///</summary>
[EnumString("textLength")]
TextLength,
///<summary>
///Custom.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// Data Validation Operator 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataValidationOperatorValues
{  
	///<summary>
///Between.
///<para>When the item is serialized out as xml, its value is "between".</para>
///</summary>
[EnumString("between")]
Between,
///<summary>
///Not Between.
///<para>When the item is serialized out as xml, its value is "notBetween".</para>
///</summary>
[EnumString("notBetween")]
NotBetween,
///<summary>
///Equal.
///<para>When the item is serialized out as xml, its value is "equal".</para>
///</summary>
[EnumString("equal")]
Equal,
///<summary>
///Not Equal.
///<para>When the item is serialized out as xml, its value is "notEqual".</para>
///</summary>
[EnumString("notEqual")]
NotEqual,
///<summary>
///Less Than.
///<para>When the item is serialized out as xml, its value is "lessThan".</para>
///</summary>
[EnumString("lessThan")]
LessThan,
///<summary>
///Less Than Or Equal.
///<para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
///</summary>
[EnumString("lessThanOrEqual")]
LessThanOrEqual,
///<summary>
///Greater Than.
///<para>When the item is serialized out as xml, its value is "greaterThan".</para>
///</summary>
[EnumString("greaterThan")]
GreaterThan,
///<summary>
///Greater Than Or Equal.
///<para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
///</summary>
[EnumString("greaterThanOrEqual")]
GreaterThanOrEqual,
 
}
/// <summary>
/// Data Validation Error Styles 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataValidationErrorStyleValues
{  
	///<summary>
///Stop Icon.
///<para>When the item is serialized out as xml, its value is "stop".</para>
///</summary>
[EnumString("stop")]
Stop,
///<summary>
///Warning Icon.
///<para>When the item is serialized out as xml, its value is "warning".</para>
///</summary>
[EnumString("warning")]
Warning,
///<summary>
///Information Icon.
///<para>When the item is serialized out as xml, its value is "information".</para>
///</summary>
[EnumString("information")]
Information,
 
}
/// <summary>
/// Data Validation IME Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataValidationImeModeValues
{  
	///<summary>
///IME Mode Not Controlled.
///<para>When the item is serialized out as xml, its value is "noControl".</para>
///</summary>
[EnumString("noControl")]
NoControl,
///<summary>
///IME Off.
///<para>When the item is serialized out as xml, its value is "off".</para>
///</summary>
[EnumString("off")]
Off,
///<summary>
///IME On.
///<para>When the item is serialized out as xml, its value is "on".</para>
///</summary>
[EnumString("on")]
On,
///<summary>
///Disabled IME Mode.
///<para>When the item is serialized out as xml, its value is "disabled".</para>
///</summary>
[EnumString("disabled")]
Disabled,
///<summary>
///Hiragana IME Mode.
///<para>When the item is serialized out as xml, its value is "hiragana".</para>
///</summary>
[EnumString("hiragana")]
Hiragana,
///<summary>
///Full Katakana IME Mode.
///<para>When the item is serialized out as xml, its value is "fullKatakana".</para>
///</summary>
[EnumString("fullKatakana")]
FullKatakana,
///<summary>
///Half-Width Katakana.
///<para>When the item is serialized out as xml, its value is "halfKatakana".</para>
///</summary>
[EnumString("halfKatakana")]
HalfKatakana,
///<summary>
///Full-Width Alpha-Numeric IME Mode.
///<para>When the item is serialized out as xml, its value is "fullAlpha".</para>
///</summary>
[EnumString("fullAlpha")]
FullAlpha,
///<summary>
///Half Alpha IME.
///<para>When the item is serialized out as xml, its value is "halfAlpha".</para>
///</summary>
[EnumString("halfAlpha")]
HalfAlpha,
///<summary>
///Full Width Hangul.
///<para>When the item is serialized out as xml, its value is "fullHangul".</para>
///</summary>
[EnumString("fullHangul")]
FullHangul,
///<summary>
///Half-Width Hangul IME Mode.
///<para>When the item is serialized out as xml, its value is "halfHangul".</para>
///</summary>
[EnumString("halfHangul")]
HalfHangul,
 
}
/// <summary>
/// Conditional Format Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ConditionalFormatValues
{  
	///<summary>
///Expression.
///<para>When the item is serialized out as xml, its value is "expression".</para>
///</summary>
[EnumString("expression")]
Expression,
///<summary>
///Cell Is.
///<para>When the item is serialized out as xml, its value is "cellIs".</para>
///</summary>
[EnumString("cellIs")]
CellIs,
///<summary>
///Color Scale.
///<para>When the item is serialized out as xml, its value is "colorScale".</para>
///</summary>
[EnumString("colorScale")]
ColorScale,
///<summary>
///Data Bar.
///<para>When the item is serialized out as xml, its value is "dataBar".</para>
///</summary>
[EnumString("dataBar")]
DataBar,
///<summary>
///Icon Set.
///<para>When the item is serialized out as xml, its value is "iconSet".</para>
///</summary>
[EnumString("iconSet")]
IconSet,
///<summary>
///Top 10.
///<para>When the item is serialized out as xml, its value is "top10".</para>
///</summary>
[EnumString("top10")]
Top10,
///<summary>
///Unique Values.
///<para>When the item is serialized out as xml, its value is "uniqueValues".</para>
///</summary>
[EnumString("uniqueValues")]
UniqueValues,
///<summary>
///Duplicate Values.
///<para>When the item is serialized out as xml, its value is "duplicateValues".</para>
///</summary>
[EnumString("duplicateValues")]
DuplicateValues,
///<summary>
///Contains Text.
///<para>When the item is serialized out as xml, its value is "containsText".</para>
///</summary>
[EnumString("containsText")]
ContainsText,
///<summary>
///Does Not Contain Text.
///<para>When the item is serialized out as xml, its value is "notContainsText".</para>
///</summary>
[EnumString("notContainsText")]
NotContainsText,
///<summary>
///Begins With.
///<para>When the item is serialized out as xml, its value is "beginsWith".</para>
///</summary>
[EnumString("beginsWith")]
BeginsWith,
///<summary>
///Ends With.
///<para>When the item is serialized out as xml, its value is "endsWith".</para>
///</summary>
[EnumString("endsWith")]
EndsWith,
///<summary>
///Contains Blanks.
///<para>When the item is serialized out as xml, its value is "containsBlanks".</para>
///</summary>
[EnumString("containsBlanks")]
ContainsBlanks,
///<summary>
///Contains No Blanks.
///<para>When the item is serialized out as xml, its value is "notContainsBlanks".</para>
///</summary>
[EnumString("notContainsBlanks")]
NotContainsBlanks,
///<summary>
///Contains Errors.
///<para>When the item is serialized out as xml, its value is "containsErrors".</para>
///</summary>
[EnumString("containsErrors")]
ContainsErrors,
///<summary>
///Contains No Errors.
///<para>When the item is serialized out as xml, its value is "notContainsErrors".</para>
///</summary>
[EnumString("notContainsErrors")]
NotContainsErrors,
///<summary>
///Time Period.
///<para>When the item is serialized out as xml, its value is "timePeriod".</para>
///</summary>
[EnumString("timePeriod")]
TimePeriod,
///<summary>
///Above or Below Average.
///<para>When the item is serialized out as xml, its value is "aboveAverage".</para>
///</summary>
[EnumString("aboveAverage")]
AboveAverage,
 
}
/// <summary>
/// Time Period Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TimePeriodValues
{  
	///<summary>
///Today.
///<para>When the item is serialized out as xml, its value is "today".</para>
///</summary>
[EnumString("today")]
Today,
///<summary>
///Yesterday.
///<para>When the item is serialized out as xml, its value is "yesterday".</para>
///</summary>
[EnumString("yesterday")]
Yesterday,
///<summary>
///Tomorrow.
///<para>When the item is serialized out as xml, its value is "tomorrow".</para>
///</summary>
[EnumString("tomorrow")]
Tomorrow,
///<summary>
///Last 7 Days.
///<para>When the item is serialized out as xml, its value is "last7Days".</para>
///</summary>
[EnumString("last7Days")]
Last7Days,
///<summary>
///This Month.
///<para>When the item is serialized out as xml, its value is "thisMonth".</para>
///</summary>
[EnumString("thisMonth")]
ThisMonth,
///<summary>
///Last Month.
///<para>When the item is serialized out as xml, its value is "lastMonth".</para>
///</summary>
[EnumString("lastMonth")]
LastMonth,
///<summary>
///Next Month.
///<para>When the item is serialized out as xml, its value is "nextMonth".</para>
///</summary>
[EnumString("nextMonth")]
NextMonth,
///<summary>
///This Week.
///<para>When the item is serialized out as xml, its value is "thisWeek".</para>
///</summary>
[EnumString("thisWeek")]
ThisWeek,
///<summary>
///Last Week.
///<para>When the item is serialized out as xml, its value is "lastWeek".</para>
///</summary>
[EnumString("lastWeek")]
LastWeek,
///<summary>
///Next Week.
///<para>When the item is serialized out as xml, its value is "nextWeek".</para>
///</summary>
[EnumString("nextWeek")]
NextWeek,
 
}
/// <summary>
/// Conditional Format Operators 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ConditionalFormattingOperatorValues
{  
	///<summary>
///Less Than.
///<para>When the item is serialized out as xml, its value is "lessThan".</para>
///</summary>
[EnumString("lessThan")]
LessThan,
///<summary>
///Less Than Or Equal.
///<para>When the item is serialized out as xml, its value is "lessThanOrEqual".</para>
///</summary>
[EnumString("lessThanOrEqual")]
LessThanOrEqual,
///<summary>
///Equal.
///<para>When the item is serialized out as xml, its value is "equal".</para>
///</summary>
[EnumString("equal")]
Equal,
///<summary>
///Not Equal.
///<para>When the item is serialized out as xml, its value is "notEqual".</para>
///</summary>
[EnumString("notEqual")]
NotEqual,
///<summary>
///Greater Than Or Equal.
///<para>When the item is serialized out as xml, its value is "greaterThanOrEqual".</para>
///</summary>
[EnumString("greaterThanOrEqual")]
GreaterThanOrEqual,
///<summary>
///Greater Than.
///<para>When the item is serialized out as xml, its value is "greaterThan".</para>
///</summary>
[EnumString("greaterThan")]
GreaterThan,
///<summary>
///Between.
///<para>When the item is serialized out as xml, its value is "between".</para>
///</summary>
[EnumString("between")]
Between,
///<summary>
///Not Between.
///<para>When the item is serialized out as xml, its value is "notBetween".</para>
///</summary>
[EnumString("notBetween")]
NotBetween,
///<summary>
///Contains.
///<para>When the item is serialized out as xml, its value is "containsText".</para>
///</summary>
[EnumString("containsText")]
ContainsText,
///<summary>
///Does Not Contain.
///<para>When the item is serialized out as xml, its value is "notContains".</para>
///</summary>
[EnumString("notContains")]
NotContains,
///<summary>
///Begins With.
///<para>When the item is serialized out as xml, its value is "beginsWith".</para>
///</summary>
[EnumString("beginsWith")]
BeginsWith,
///<summary>
///Ends With.
///<para>When the item is serialized out as xml, its value is "endsWith".</para>
///</summary>
[EnumString("endsWith")]
EndsWith,
 
}
/// <summary>
/// Conditional Format Value Object Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ConditionalFormatValueObjectValues
{  
	///<summary>
///Number.
///<para>When the item is serialized out as xml, its value is "num".</para>
///</summary>
[EnumString("num")]
Number,
///<summary>
///Percent.
///<para>When the item is serialized out as xml, its value is "percent".</para>
///</summary>
[EnumString("percent")]
Percent,
///<summary>
///Maximum.
///<para>When the item is serialized out as xml, its value is "max".</para>
///</summary>
[EnumString("max")]
Max,
///<summary>
///Minimum.
///<para>When the item is serialized out as xml, its value is "min".</para>
///</summary>
[EnumString("min")]
Min,
///<summary>
///Formula.
///<para>When the item is serialized out as xml, its value is "formula".</para>
///</summary>
[EnumString("formula")]
Formula,
///<summary>
///Percentile.
///<para>When the item is serialized out as xml, its value is "percentile".</para>
///</summary>
[EnumString("percentile")]
Percentile,
 
}
/// <summary>
/// Page Order 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PageOrderValues
{  
	///<summary>
///Down Then Over.
///<para>When the item is serialized out as xml, its value is "downThenOver".</para>
///</summary>
[EnumString("downThenOver")]
DownThenOver,
///<summary>
///Over Then Down.
///<para>When the item is serialized out as xml, its value is "overThenDown".</para>
///</summary>
[EnumString("overThenDown")]
OverThenDown,
 
}
/// <summary>
/// Orientation 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum OrientationValues
{  
	///<summary>
///Default.
///<para>When the item is serialized out as xml, its value is "default".</para>
///</summary>
[EnumString("default")]
Default,
///<summary>
///Portrait.
///<para>When the item is serialized out as xml, its value is "portrait".</para>
///</summary>
[EnumString("portrait")]
Portrait,
///<summary>
///Landscape.
///<para>When the item is serialized out as xml, its value is "landscape".</para>
///</summary>
[EnumString("landscape")]
Landscape,
 
}
/// <summary>
/// Cell Comments 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CellCommentsValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Print Comments As Displayed.
///<para>When the item is serialized out as xml, its value is "asDisplayed".</para>
///</summary>
[EnumString("asDisplayed")]
AsDisplayed,
///<summary>
///Print At End.
///<para>When the item is serialized out as xml, its value is "atEnd".</para>
///</summary>
[EnumString("atEnd")]
AtEnd,
 
}
/// <summary>
/// Print Errors 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PrintErrorValues
{  
	///<summary>
///Display Cell Errors.
///<para>When the item is serialized out as xml, its value is "displayed".</para>
///</summary>
[EnumString("displayed")]
Displayed,
///<summary>
///Show Cell Errors As Blank.
///<para>When the item is serialized out as xml, its value is "blank".</para>
///</summary>
[EnumString("blank")]
Blank,
///<summary>
///Dash Cell Errors.
///<para>When the item is serialized out as xml, its value is "dash".</para>
///</summary>
[EnumString("dash")]
Dash,
///<summary>
///NA.
///<para>When the item is serialized out as xml, its value is "NA".</para>
///</summary>
[EnumString("NA")]
NA,
 
}
/// <summary>
/// Data View Aspect Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DataViewAspectValues
{  
	///<summary>
///Object Display Content.
///<para>When the item is serialized out as xml, its value is "DVASPECT_CONTENT".</para>
///</summary>
[EnumString("DVASPECT_CONTENT")]
DataViewAspectContent,
///<summary>
///Object Display Icon.
///<para>When the item is serialized out as xml, its value is "DVASPECT_ICON".</para>
///</summary>
[EnumString("DVASPECT_ICON")]
DataViewAspectIcon,
 
}
/// <summary>
/// OLE Update Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum OleUpdateValues
{  
	///<summary>
///Always Update OLE.
///<para>When the item is serialized out as xml, its value is "OLEUPDATE_ALWAYS".</para>
///</summary>
[EnumString("OLEUPDATE_ALWAYS")]
OleUpdateAlways,
///<summary>
///Update OLE On Call.
///<para>When the item is serialized out as xml, its value is "OLEUPDATE_ONCALL".</para>
///</summary>
[EnumString("OLEUPDATE_ONCALL")]
OleUpdateOnCall,
 
}
/// <summary>
/// Web Source Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum WebSourceValues
{  
	///<summary>
///All Sheet Content.
///<para>When the item is serialized out as xml, its value is "sheet".</para>
///</summary>
[EnumString("sheet")]
Sheet,
///<summary>
///Print Area.
///<para>When the item is serialized out as xml, its value is "printArea".</para>
///</summary>
[EnumString("printArea")]
PrintArea,
///<summary>
///AutoFilter.
///<para>When the item is serialized out as xml, its value is "autoFilter".</para>
///</summary>
[EnumString("autoFilter")]
AutoFilter,
///<summary>
///Range.
///<para>When the item is serialized out as xml, its value is "range".</para>
///</summary>
[EnumString("range")]
Range,
///<summary>
///Chart.
///<para>When the item is serialized out as xml, its value is "chart".</para>
///</summary>
[EnumString("chart")]
Chart,
///<summary>
///PivotTable.
///<para>When the item is serialized out as xml, its value is "pivotTable".</para>
///</summary>
[EnumString("pivotTable")]
PivotTable,
///<summary>
///QueryTable.
///<para>When the item is serialized out as xml, its value is "query".</para>
///</summary>
[EnumString("query")]
Query,
///<summary>
///Label.
///<para>When the item is serialized out as xml, its value is "label".</para>
///</summary>
[EnumString("label")]
Label,
 
}
/// <summary>
/// Pane State 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PaneStateValues
{  
	///<summary>
///Split.
///<para>When the item is serialized out as xml, its value is "split".</para>
///</summary>
[EnumString("split")]
Split,
///<summary>
///Frozen.
///<para>When the item is serialized out as xml, its value is "frozen".</para>
///</summary>
[EnumString("frozen")]
Frozen,
///<summary>
///Frozen Split.
///<para>When the item is serialized out as xml, its value is "frozenSplit".</para>
///</summary>
[EnumString("frozenSplit")]
FrozenSplit,
 
}
/// <summary>
/// MDX Function Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MdxFunctionValues
{  
	///<summary>
///Cube Member.
///<para>When the item is serialized out as xml, its value is "m".</para>
///</summary>
[EnumString("m")]
CubeMember,
///<summary>
///Cube Value.
///<para>When the item is serialized out as xml, its value is "v".</para>
///</summary>
[EnumString("v")]
CubeValue,
///<summary>
///Cube Set.
///<para>When the item is serialized out as xml, its value is "s".</para>
///</summary>
[EnumString("s")]
CubeSet,
///<summary>
///Cube Set Count.
///<para>When the item is serialized out as xml, its value is "c".</para>
///</summary>
[EnumString("c")]
CubeSetCount,
///<summary>
///Cube Ranked Member.
///<para>When the item is serialized out as xml, its value is "r".</para>
///</summary>
[EnumString("r")]
CubeRankedMember,
///<summary>
///Cube Member Property.
///<para>When the item is serialized out as xml, its value is "p".</para>
///</summary>
[EnumString("p")]
CubeMemberProperty,
///<summary>
///Cube KPI Member.
///<para>When the item is serialized out as xml, its value is "k".</para>
///</summary>
[EnumString("k")]
CubeKPIMember,
 
}
/// <summary>
/// MDX Set Order 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MdxSetOrderValues
{  
	///<summary>
///Unsorted.
///<para>When the item is serialized out as xml, its value is "u".</para>
///</summary>
[EnumString("u")]
Unsorted,
///<summary>
///Ascending.
///<para>When the item is serialized out as xml, its value is "a".</para>
///</summary>
[EnumString("a")]
Ascending,
///<summary>
///Descending.
///<para>When the item is serialized out as xml, its value is "d".</para>
///</summary>
[EnumString("d")]
Descending,
///<summary>
///Alpha Ascending Sort Order.
///<para>When the item is serialized out as xml, its value is "aa".</para>
///</summary>
[EnumString("aa")]
AlphaAscendingSortOrder,
///<summary>
///Alpha Descending Sort Order.
///<para>When the item is serialized out as xml, its value is "ad".</para>
///</summary>
[EnumString("ad")]
AlphaDescendingSortOrder,
///<summary>
///Natural Ascending.
///<para>When the item is serialized out as xml, its value is "na".</para>
///</summary>
[EnumString("na")]
NaturalAscending,
///<summary>
///Natural Descending.
///<para>When the item is serialized out as xml, its value is "nd".</para>
///</summary>
[EnumString("nd")]
NaturalDescending,
 
}
/// <summary>
/// MDX KPI Property 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum MdxKPIPropertyValues
{  
	///<summary>
///Value.
///<para>When the item is serialized out as xml, its value is "v".</para>
///</summary>
[EnumString("v")]
Value,
///<summary>
///Goal.
///<para>When the item is serialized out as xml, its value is "g".</para>
///</summary>
[EnumString("g")]
Goal,
///<summary>
///Status.
///<para>When the item is serialized out as xml, its value is "s".</para>
///</summary>
[EnumString("s")]
Status,
///<summary>
///Trend.
///<para>When the item is serialized out as xml, its value is "t".</para>
///</summary>
[EnumString("t")]
Trend,
///<summary>
///Weight.
///<para>When the item is serialized out as xml, its value is "w".</para>
///</summary>
[EnumString("w")]
Weight,
///<summary>
///Current Time Member.
///<para>When the item is serialized out as xml, its value is "m".</para>
///</summary>
[EnumString("m")]
Time,
 
}
/// <summary>
/// Border Line Styles 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum BorderStyleValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Thin Border.
///<para>When the item is serialized out as xml, its value is "thin".</para>
///</summary>
[EnumString("thin")]
Thin,
///<summary>
///Medium Border.
///<para>When the item is serialized out as xml, its value is "medium".</para>
///</summary>
[EnumString("medium")]
Medium,
///<summary>
///Dashed.
///<para>When the item is serialized out as xml, its value is "dashed".</para>
///</summary>
[EnumString("dashed")]
Dashed,
///<summary>
///Dotted.
///<para>When the item is serialized out as xml, its value is "dotted".</para>
///</summary>
[EnumString("dotted")]
Dotted,
///<summary>
///Thick Line Border.
///<para>When the item is serialized out as xml, its value is "thick".</para>
///</summary>
[EnumString("thick")]
Thick,
///<summary>
///Double Line.
///<para>When the item is serialized out as xml, its value is "double".</para>
///</summary>
[EnumString("double")]
Double,
///<summary>
///Hairline Border.
///<para>When the item is serialized out as xml, its value is "hair".</para>
///</summary>
[EnumString("hair")]
Hair,
///<summary>
///Medium Dashed.
///<para>When the item is serialized out as xml, its value is "mediumDashed".</para>
///</summary>
[EnumString("mediumDashed")]
MediumDashed,
///<summary>
///Dash Dot.
///<para>When the item is serialized out as xml, its value is "dashDot".</para>
///</summary>
[EnumString("dashDot")]
DashDot,
///<summary>
///Medium Dash Dot.
///<para>When the item is serialized out as xml, its value is "mediumDashDot".</para>
///</summary>
[EnumString("mediumDashDot")]
MediumDashDot,
///<summary>
///Dash Dot Dot.
///<para>When the item is serialized out as xml, its value is "dashDotDot".</para>
///</summary>
[EnumString("dashDotDot")]
DashDotDot,
///<summary>
///Medium Dash Dot Dot.
///<para>When the item is serialized out as xml, its value is "mediumDashDotDot".</para>
///</summary>
[EnumString("mediumDashDotDot")]
MediumDashDotDot,
///<summary>
///Slant Dash Dot.
///<para>When the item is serialized out as xml, its value is "slantDashDot".</para>
///</summary>
[EnumString("slantDashDot")]
SlantDashDot,
 
}
/// <summary>
/// Pattern Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PatternValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Solid.
///<para>When the item is serialized out as xml, its value is "solid".</para>
///</summary>
[EnumString("solid")]
Solid,
///<summary>
///Medium Gray.
///<para>When the item is serialized out as xml, its value is "mediumGray".</para>
///</summary>
[EnumString("mediumGray")]
MediumGray,
///<summary>
///Dary Gray.
///<para>When the item is serialized out as xml, its value is "darkGray".</para>
///</summary>
[EnumString("darkGray")]
DarkGray,
///<summary>
///Light Gray.
///<para>When the item is serialized out as xml, its value is "lightGray".</para>
///</summary>
[EnumString("lightGray")]
LightGray,
///<summary>
///Dark Horizontal.
///<para>When the item is serialized out as xml, its value is "darkHorizontal".</para>
///</summary>
[EnumString("darkHorizontal")]
DarkHorizontal,
///<summary>
///Dark Vertical.
///<para>When the item is serialized out as xml, its value is "darkVertical".</para>
///</summary>
[EnumString("darkVertical")]
DarkVertical,
///<summary>
///Dark Down.
///<para>When the item is serialized out as xml, its value is "darkDown".</para>
///</summary>
[EnumString("darkDown")]
DarkDown,
///<summary>
///Dark Up.
///<para>When the item is serialized out as xml, its value is "darkUp".</para>
///</summary>
[EnumString("darkUp")]
DarkUp,
///<summary>
///Dark Grid.
///<para>When the item is serialized out as xml, its value is "darkGrid".</para>
///</summary>
[EnumString("darkGrid")]
DarkGrid,
///<summary>
///Dark Trellis.
///<para>When the item is serialized out as xml, its value is "darkTrellis".</para>
///</summary>
[EnumString("darkTrellis")]
DarkTrellis,
///<summary>
///Light Horizontal.
///<para>When the item is serialized out as xml, its value is "lightHorizontal".</para>
///</summary>
[EnumString("lightHorizontal")]
LightHorizontal,
///<summary>
///Light Vertical.
///<para>When the item is serialized out as xml, its value is "lightVertical".</para>
///</summary>
[EnumString("lightVertical")]
LightVertical,
///<summary>
///Light Down.
///<para>When the item is serialized out as xml, its value is "lightDown".</para>
///</summary>
[EnumString("lightDown")]
LightDown,
///<summary>
///Light Up.
///<para>When the item is serialized out as xml, its value is "lightUp".</para>
///</summary>
[EnumString("lightUp")]
LightUp,
///<summary>
///Light Grid.
///<para>When the item is serialized out as xml, its value is "lightGrid".</para>
///</summary>
[EnumString("lightGrid")]
LightGrid,
///<summary>
///Light Trellis.
///<para>When the item is serialized out as xml, its value is "lightTrellis".</para>
///</summary>
[EnumString("lightTrellis")]
LightTrellis,
///<summary>
///Gray 0.125.
///<para>When the item is serialized out as xml, its value is "gray125".</para>
///</summary>
[EnumString("gray125")]
Gray125,
///<summary>
///Gray 0.0625.
///<para>When the item is serialized out as xml, its value is "gray0625".</para>
///</summary>
[EnumString("gray0625")]
Gray0625,
 
}
/// <summary>
/// Gradient Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum GradientValues
{  
	///<summary>
///Linear Gradient.
///<para>When the item is serialized out as xml, its value is "linear".</para>
///</summary>
[EnumString("linear")]
Linear,
///<summary>
///Path.
///<para>When the item is serialized out as xml, its value is "path".</para>
///</summary>
[EnumString("path")]
Path,
 
}
/// <summary>
/// Horizontal Alignment Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum HorizontalAlignmentValues
{  
	///<summary>
///General Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "general".</para>
///</summary>
[EnumString("general")]
General,
///<summary>
///Left Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///Centered Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Right Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///Fill.
///<para>When the item is serialized out as xml, its value is "fill".</para>
///</summary>
[EnumString("fill")]
Fill,
///<summary>
///Justify.
///<para>When the item is serialized out as xml, its value is "justify".</para>
///</summary>
[EnumString("justify")]
Justify,
///<summary>
///Center Continuous Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "centerContinuous".</para>
///</summary>
[EnumString("centerContinuous")]
CenterContinuous,
///<summary>
///Distributed Horizontal Alignment.
///<para>When the item is serialized out as xml, its value is "distributed".</para>
///</summary>
[EnumString("distributed")]
Distributed,
 
}
/// <summary>
/// Vertical Alignment Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalAlignmentValues
{  
	///<summary>
///Align Top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///Centered Vertical Alignment.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///Aligned To Bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
///<summary>
///Justified Vertically.
///<para>When the item is serialized out as xml, its value is "justify".</para>
///</summary>
[EnumString("justify")]
Justify,
///<summary>
///Distributed Vertical Alignment.
///<para>When the item is serialized out as xml, its value is "distributed".</para>
///</summary>
[EnumString("distributed")]
Distributed,
 
}
/// <summary>
/// Table Style Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableStyleValues
{  
	///<summary>
///Whole Table Style.
///<para>When the item is serialized out as xml, its value is "wholeTable".</para>
///</summary>
[EnumString("wholeTable")]
WholeTable,
///<summary>
///Header Row Style.
///<para>When the item is serialized out as xml, its value is "headerRow".</para>
///</summary>
[EnumString("headerRow")]
HeaderRow,
///<summary>
///Total Row Style.
///<para>When the item is serialized out as xml, its value is "totalRow".</para>
///</summary>
[EnumString("totalRow")]
TotalRow,
///<summary>
///First Column Style.
///<para>When the item is serialized out as xml, its value is "firstColumn".</para>
///</summary>
[EnumString("firstColumn")]
FirstColumn,
///<summary>
///Last Column Style.
///<para>When the item is serialized out as xml, its value is "lastColumn".</para>
///</summary>
[EnumString("lastColumn")]
LastColumn,
///<summary>
///First Row Stripe Style.
///<para>When the item is serialized out as xml, its value is "firstRowStripe".</para>
///</summary>
[EnumString("firstRowStripe")]
FirstRowStripe,
///<summary>
///Second Row Stripe Style.
///<para>When the item is serialized out as xml, its value is "secondRowStripe".</para>
///</summary>
[EnumString("secondRowStripe")]
SecondRowStripe,
///<summary>
///First Column Stripe Style.
///<para>When the item is serialized out as xml, its value is "firstColumnStripe".</para>
///</summary>
[EnumString("firstColumnStripe")]
FirstColumnStripe,
///<summary>
///Second Column Stipe Style.
///<para>When the item is serialized out as xml, its value is "secondColumnStripe".</para>
///</summary>
[EnumString("secondColumnStripe")]
SecondColumnStripe,
///<summary>
///First Header Row Style.
///<para>When the item is serialized out as xml, its value is "firstHeaderCell".</para>
///</summary>
[EnumString("firstHeaderCell")]
FirstHeaderCell,
///<summary>
///Last Header Style.
///<para>When the item is serialized out as xml, its value is "lastHeaderCell".</para>
///</summary>
[EnumString("lastHeaderCell")]
LastHeaderCell,
///<summary>
///First Total Row Style.
///<para>When the item is serialized out as xml, its value is "firstTotalCell".</para>
///</summary>
[EnumString("firstTotalCell")]
FirstTotalCell,
///<summary>
///Last Total Row Style.
///<para>When the item is serialized out as xml, its value is "lastTotalCell".</para>
///</summary>
[EnumString("lastTotalCell")]
LastTotalCell,
///<summary>
///First Subtotal Column Style.
///<para>When the item is serialized out as xml, its value is "firstSubtotalColumn".</para>
///</summary>
[EnumString("firstSubtotalColumn")]
FirstSubtotalColumn,
///<summary>
///Second Subtotal Column Style.
///<para>When the item is serialized out as xml, its value is "secondSubtotalColumn".</para>
///</summary>
[EnumString("secondSubtotalColumn")]
SecondSubtotalColumn,
///<summary>
///Third Subtotal Column Style.
///<para>When the item is serialized out as xml, its value is "thirdSubtotalColumn".</para>
///</summary>
[EnumString("thirdSubtotalColumn")]
ThirdSubtotalColumn,
///<summary>
///First Subtotal Row Style.
///<para>When the item is serialized out as xml, its value is "firstSubtotalRow".</para>
///</summary>
[EnumString("firstSubtotalRow")]
FirstSubtotalRow,
///<summary>
///Second Subtotal Row Style.
///<para>When the item is serialized out as xml, its value is "secondSubtotalRow".</para>
///</summary>
[EnumString("secondSubtotalRow")]
SecondSubtotalRow,
///<summary>
///Third Subtotal Row Style.
///<para>When the item is serialized out as xml, its value is "thirdSubtotalRow".</para>
///</summary>
[EnumString("thirdSubtotalRow")]
ThirdSubtotalRow,
///<summary>
///Blank Row Style.
///<para>When the item is serialized out as xml, its value is "blankRow".</para>
///</summary>
[EnumString("blankRow")]
BlankRow,
///<summary>
///First Column Subheading Style.
///<para>When the item is serialized out as xml, its value is "firstColumnSubheading".</para>
///</summary>
[EnumString("firstColumnSubheading")]
FirstColumnSubheading,
///<summary>
///Second Column Subheading Style.
///<para>When the item is serialized out as xml, its value is "secondColumnSubheading".</para>
///</summary>
[EnumString("secondColumnSubheading")]
SecondColumnSubheading,
///<summary>
///Third Column Subheading Style.
///<para>When the item is serialized out as xml, its value is "thirdColumnSubheading".</para>
///</summary>
[EnumString("thirdColumnSubheading")]
ThirdColumnSubheading,
///<summary>
///First Row Subheading Style.
///<para>When the item is serialized out as xml, its value is "firstRowSubheading".</para>
///</summary>
[EnumString("firstRowSubheading")]
FirstRowSubheading,
///<summary>
///Second Row Subheading Style.
///<para>When the item is serialized out as xml, its value is "secondRowSubheading".</para>
///</summary>
[EnumString("secondRowSubheading")]
SecondRowSubheading,
///<summary>
///Third Row Subheading Style.
///<para>When the item is serialized out as xml, its value is "thirdRowSubheading".</para>
///</summary>
[EnumString("thirdRowSubheading")]
ThirdRowSubheading,
///<summary>
///Page Field Labels Style.
///<para>When the item is serialized out as xml, its value is "pageFieldLabels".</para>
///</summary>
[EnumString("pageFieldLabels")]
PageFieldLabels,
///<summary>
///Page Field Values Style.
///<para>When the item is serialized out as xml, its value is "pageFieldValues".</para>
///</summary>
[EnumString("pageFieldValues")]
PageFieldValues,
 
}
/// <summary>
/// Vertical Alignment Run Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VerticalAlignmentRunValues
{  
	///<summary>
///Baseline.
///<para>When the item is serialized out as xml, its value is "baseline".</para>
///</summary>
[EnumString("baseline")]
Baseline,
///<summary>
///Superscript.
///<para>When the item is serialized out as xml, its value is "superscript".</para>
///</summary>
[EnumString("superscript")]
Superscript,
///<summary>
///Subscript.
///<para>When the item is serialized out as xml, its value is "subscript".</para>
///</summary>
[EnumString("subscript")]
Subscript,
 
}
/// <summary>
/// Font scheme Styles 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum FontSchemeValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Major Font.
///<para>When the item is serialized out as xml, its value is "major".</para>
///</summary>
[EnumString("major")]
Major,
///<summary>
///Minor Font.
///<para>When the item is serialized out as xml, its value is "minor".</para>
///</summary>
[EnumString("minor")]
Minor,
 
}
/// <summary>
/// Underline Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum UnderlineValues
{  
	///<summary>
///Single Underline.
///<para>When the item is serialized out as xml, its value is "single".</para>
///</summary>
[EnumString("single")]
Single,
///<summary>
///Double Underline.
///<para>When the item is serialized out as xml, its value is "double".</para>
///</summary>
[EnumString("double")]
Double,
///<summary>
///Accounting Single Underline.
///<para>When the item is serialized out as xml, its value is "singleAccounting".</para>
///</summary>
[EnumString("singleAccounting")]
SingleAccounting,
///<summary>
///Accounting Double Underline.
///<para>When the item is serialized out as xml, its value is "doubleAccounting".</para>
///</summary>
[EnumString("doubleAccounting")]
DoubleAccounting,
///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// DDE Value Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum DdeValues
{  
	///<summary>
///Nil.
///<para>When the item is serialized out as xml, its value is "nil".</para>
///</summary>
[EnumString("nil")]
Nil,
///<summary>
///Boolean.
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Boolean,
///<summary>
///Real Number.
///<para>When the item is serialized out as xml, its value is "n".</para>
///</summary>
[EnumString("n")]
RealNumber,
///<summary>
///Error.
///<para>When the item is serialized out as xml, its value is "e".</para>
///</summary>
[EnumString("e")]
Error,
///<summary>
///String.
///<para>When the item is serialized out as xml, its value is "str".</para>
///</summary>
[EnumString("str")]
String,
 
}
/// <summary>
/// Table Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TableValues
{  
	///<summary>
///Worksheet.
///<para>When the item is serialized out as xml, its value is "worksheet".</para>
///</summary>
[EnumString("worksheet")]
Worksheet,
///<summary>
///XML.
///<para>When the item is serialized out as xml, its value is "xml".</para>
///</summary>
[EnumString("xml")]
Xml,
///<summary>
///Query Table.
///<para>When the item is serialized out as xml, its value is "queryTable".</para>
///</summary>
[EnumString("queryTable")]
QueryTable,
 
}
/// <summary>
/// Totals Row Function Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TotalsRowFunctionValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Sum.
///<para>When the item is serialized out as xml, its value is "sum".</para>
///</summary>
[EnumString("sum")]
Sum,
///<summary>
///Minimum.
///<para>When the item is serialized out as xml, its value is "min".</para>
///</summary>
[EnumString("min")]
Minimum,
///<summary>
///Maximum.
///<para>When the item is serialized out as xml, its value is "max".</para>
///</summary>
[EnumString("max")]
Maximum,
///<summary>
///Average.
///<para>When the item is serialized out as xml, its value is "average".</para>
///</summary>
[EnumString("average")]
Average,
///<summary>
///Non Empty Cell Count.
///<para>When the item is serialized out as xml, its value is "count".</para>
///</summary>
[EnumString("count")]
Count,
///<summary>
///Count Numbers.
///<para>When the item is serialized out as xml, its value is "countNums".</para>
///</summary>
[EnumString("countNums")]
CountNumbers,
///<summary>
///StdDev.
///<para>When the item is serialized out as xml, its value is "stdDev".</para>
///</summary>
[EnumString("stdDev")]
StandardDeviation,
///<summary>
///Var.
///<para>When the item is serialized out as xml, its value is "var".</para>
///</summary>
[EnumString("var")]
Variance,
///<summary>
///Custom Formula.
///<para>When the item is serialized out as xml, its value is "custom".</para>
///</summary>
[EnumString("custom")]
Custom,
 
}
/// <summary>
/// XML Data Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum XmlDataValues
{  
	///<summary>
///String.
///<para>When the item is serialized out as xml, its value is "string".</para>
///</summary>
[EnumString("string")]
String,
///<summary>
///Normalized String.
///<para>When the item is serialized out as xml, its value is "normalizedString".</para>
///</summary>
[EnumString("normalizedString")]
NormalizedString,
///<summary>
///Token.
///<para>When the item is serialized out as xml, its value is "token".</para>
///</summary>
[EnumString("token")]
Token,
///<summary>
///Byte.
///<para>When the item is serialized out as xml, its value is "byte".</para>
///</summary>
[EnumString("byte")]
Byte,
///<summary>
///Unsigned Byte.
///<para>When the item is serialized out as xml, its value is "unsignedByte".</para>
///</summary>
[EnumString("unsignedByte")]
UnsignedByte,
///<summary>
///Base 64 Encoded Binary.
///<para>When the item is serialized out as xml, its value is "base64Binary".</para>
///</summary>
[EnumString("base64Binary")]
Base64Binary,
///<summary>
///Hex Binary.
///<para>When the item is serialized out as xml, its value is "hexBinary".</para>
///</summary>
[EnumString("hexBinary")]
HexBinary,
///<summary>
///Integer.
///<para>When the item is serialized out as xml, its value is "integer".</para>
///</summary>
[EnumString("integer")]
Integer,
///<summary>
///Positive Integer.
///<para>When the item is serialized out as xml, its value is "positiveInteger".</para>
///</summary>
[EnumString("positiveInteger")]
PositiveInteger,
///<summary>
///Negative Integer.
///<para>When the item is serialized out as xml, its value is "negativeInteger".</para>
///</summary>
[EnumString("negativeInteger")]
NegativeInteger,
///<summary>
///Non Positive Integer.
///<para>When the item is serialized out as xml, its value is "nonPositiveInteger".</para>
///</summary>
[EnumString("nonPositiveInteger")]
NonPositiveInteger,
///<summary>
///Non Negative Integer.
///<para>When the item is serialized out as xml, its value is "nonNegativeInteger".</para>
///</summary>
[EnumString("nonNegativeInteger")]
NonNegativeInteger,
///<summary>
///Integer.
///<para>When the item is serialized out as xml, its value is "int".</para>
///</summary>
[EnumString("int")]
Int,
///<summary>
///Unsigned Integer.
///<para>When the item is serialized out as xml, its value is "unsignedInt".</para>
///</summary>
[EnumString("unsignedInt")]
UnsignedInteger,
///<summary>
///Long.
///<para>When the item is serialized out as xml, its value is "long".</para>
///</summary>
[EnumString("long")]
Long,
///<summary>
///Unsigned Long.
///<para>When the item is serialized out as xml, its value is "unsignedLong".</para>
///</summary>
[EnumString("unsignedLong")]
UnsignedLong,
///<summary>
///Short.
///<para>When the item is serialized out as xml, its value is "short".</para>
///</summary>
[EnumString("short")]
Short,
///<summary>
///Unsigned Short.
///<para>When the item is serialized out as xml, its value is "unsignedShort".</para>
///</summary>
[EnumString("unsignedShort")]
UnsignedShort,
///<summary>
///Decimal.
///<para>When the item is serialized out as xml, its value is "decimal".</para>
///</summary>
[EnumString("decimal")]
Decimal,
///<summary>
///Float.
///<para>When the item is serialized out as xml, its value is "float".</para>
///</summary>
[EnumString("float")]
Float,
///<summary>
///Double.
///<para>When the item is serialized out as xml, its value is "double".</para>
///</summary>
[EnumString("double")]
Double,
///<summary>
///Boolean.
///<para>When the item is serialized out as xml, its value is "boolean".</para>
///</summary>
[EnumString("boolean")]
Boolean,
///<summary>
///Time.
///<para>When the item is serialized out as xml, its value is "time".</para>
///</summary>
[EnumString("time")]
Time,
///<summary>
///Date Time.
///<para>When the item is serialized out as xml, its value is "dateTime".</para>
///</summary>
[EnumString("dateTime")]
DateTime,
///<summary>
///Duration.
///<para>When the item is serialized out as xml, its value is "duration".</para>
///</summary>
[EnumString("duration")]
Duration,
///<summary>
///Date.
///<para>When the item is serialized out as xml, its value is "date".</para>
///</summary>
[EnumString("date")]
Date,
///<summary>
///gMonth.
///<para>When the item is serialized out as xml, its value is "gMonth".</para>
///</summary>
[EnumString("gMonth")]
Gmonth,
///<summary>
///gYear.
///<para>When the item is serialized out as xml, its value is "gYear".</para>
///</summary>
[EnumString("gYear")]
Gyear,
///<summary>
///gYearMonth.
///<para>When the item is serialized out as xml, its value is "gYearMonth".</para>
///</summary>
[EnumString("gYearMonth")]
GYearMonth,
///<summary>
///gDay.
///<para>When the item is serialized out as xml, its value is "gDay".</para>
///</summary>
[EnumString("gDay")]
Gday,
///<summary>
///gMonthDays.
///<para>When the item is serialized out as xml, its value is "gMonthDay".</para>
///</summary>
[EnumString("gMonthDay")]
GMonthDay,
///<summary>
///Name.
///<para>When the item is serialized out as xml, its value is "Name".</para>
///</summary>
[EnumString("Name")]
Name,
///<summary>
///Qname.
///<para>When the item is serialized out as xml, its value is "QName".</para>
///</summary>
[EnumString("QName")]
Qname,
///<summary>
///NCName.
///<para>When the item is serialized out as xml, its value is "NCName".</para>
///</summary>
[EnumString("NCName")]
NCName,
///<summary>
///Any URI.
///<para>When the item is serialized out as xml, its value is "anyURI".</para>
///</summary>
[EnumString("anyURI")]
AnyURI,
///<summary>
///Language.
///<para>When the item is serialized out as xml, its value is "language".</para>
///</summary>
[EnumString("language")]
Language,
///<summary>
///ID.
///<para>When the item is serialized out as xml, its value is "ID".</para>
///</summary>
[EnumString("ID")]
Id,
///<summary>
///IDREF.
///<para>When the item is serialized out as xml, its value is "IDREF".</para>
///</summary>
[EnumString("IDREF")]
IdRef,
///<summary>
///IDREFS.
///<para>When the item is serialized out as xml, its value is "IDREFS".</para>
///</summary>
[EnumString("IDREFS")]
IdRefs,
///<summary>
///ENTITY.
///<para>When the item is serialized out as xml, its value is "ENTITY".</para>
///</summary>
[EnumString("ENTITY")]
Entity,
///<summary>
///ENTITIES.
///<para>When the item is serialized out as xml, its value is "ENTITIES".</para>
///</summary>
[EnumString("ENTITIES")]
Entities,
///<summary>
///Notation.
///<para>When the item is serialized out as xml, its value is "NOTATION".</para>
///</summary>
[EnumString("NOTATION")]
Notation,
///<summary>
///NMTOKEN.
///<para>When the item is serialized out as xml, its value is "NMTOKEN".</para>
///</summary>
[EnumString("NMTOKEN")]
NMToken,
///<summary>
///NMTOKENS.
///<para>When the item is serialized out as xml, its value is "NMTOKENS".</para>
///</summary>
[EnumString("NMTOKENS")]
NMTokens,
///<summary>
///Any Type.
///<para>When the item is serialized out as xml, its value is "anyType".</para>
///</summary>
[EnumString("anyType")]
AnyType,
 
}
/// <summary>
/// Volatile Dependency Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VolatileDependencyValues
{  
	///<summary>
///Real Time Data.
///<para>When the item is serialized out as xml, its value is "realTimeData".</para>
///</summary>
[EnumString("realTimeData")]
RealTimeData,
///<summary>
///OLAP Formulas.
///<para>When the item is serialized out as xml, its value is "olapFunctions".</para>
///</summary>
[EnumString("olapFunctions")]
OlapFunctions,
 
}
/// <summary>
/// Volatile Dependency Value Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VolatileValues
{  
	///<summary>
///Boolean.
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Boolean,
///<summary>
///Real Number.
///<para>When the item is serialized out as xml, its value is "n".</para>
///</summary>
[EnumString("n")]
RealNumber,
///<summary>
///Error.
///<para>When the item is serialized out as xml, its value is "e".</para>
///</summary>
[EnumString("e")]
Error,
///<summary>
///String.
///<para>When the item is serialized out as xml, its value is "s".</para>
///</summary>
[EnumString("s")]
String,
 
}
/// <summary>
/// Visibility Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum VisibilityValues
{  
	///<summary>
///Visible.
///<para>When the item is serialized out as xml, its value is "visible".</para>
///</summary>
[EnumString("visible")]
Visible,
///<summary>
///Hidden.
///<para>When the item is serialized out as xml, its value is "hidden".</para>
///</summary>
[EnumString("hidden")]
Hidden,
///<summary>
///Very Hidden.
///<para>When the item is serialized out as xml, its value is "veryHidden".</para>
///</summary>
[EnumString("veryHidden")]
VeryHidden,
 
}
/// <summary>
/// Comment Display Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CommentsValues
{  
	///<summary>
///No Comments.
///<para>When the item is serialized out as xml, its value is "commNone".</para>
///</summary>
[EnumString("commNone")]
CommentNone,
///<summary>
///Show Comment Indicator.
///<para>When the item is serialized out as xml, its value is "commIndicator".</para>
///</summary>
[EnumString("commIndicator")]
CommentIndicator,
///<summary>
///Show Comment and Indicator.
///<para>When the item is serialized out as xml, its value is "commIndAndComment".</para>
///</summary>
[EnumString("commIndAndComment")]
CommentIndicatorAndComment,
 
}
/// <summary>
/// Object Display Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ObjectDisplayValues
{  
	///<summary>
///All.
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
///<summary>
///Show Placeholders.
///<para>When the item is serialized out as xml, its value is "placeholders".</para>
///</summary>
[EnumString("placeholders")]
Placeholders,
///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
 
}
/// <summary>
/// Sheet Visibility Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum SheetStateValues
{  
	///<summary>
///Visible.
///<para>When the item is serialized out as xml, its value is "visible".</para>
///</summary>
[EnumString("visible")]
Visible,
///<summary>
///Hidden.
///<para>When the item is serialized out as xml, its value is "hidden".</para>
///</summary>
[EnumString("hidden")]
Hidden,
///<summary>
///Very Hidden.
///<para>When the item is serialized out as xml, its value is "veryHidden".</para>
///</summary>
[EnumString("veryHidden")]
VeryHidden,
 
}
/// <summary>
/// Update Links Behavior Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum UpdateLinksBehaviorValues
{  
	///<summary>
///User Set.
///<para>When the item is serialized out as xml, its value is "userSet".</para>
///</summary>
[EnumString("userSet")]
UserSet,
///<summary>
///Never Update Links.
///<para>When the item is serialized out as xml, its value is "never".</para>
///</summary>
[EnumString("never")]
Never,
///<summary>
///Always Update Links.
///<para>When the item is serialized out as xml, its value is "always".</para>
///</summary>
[EnumString("always")]
Always,
 
}
/// <summary>
/// Calculation Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CalculateModeValues
{  
	///<summary>
///Manual Calculation Mode.
///<para>When the item is serialized out as xml, its value is "manual".</para>
///</summary>
[EnumString("manual")]
Manual,
///<summary>
///Automatic.
///<para>When the item is serialized out as xml, its value is "auto".</para>
///</summary>
[EnumString("auto")]
Auto,
///<summary>
///Automatic Calculation (No Tables).
///<para>When the item is serialized out as xml, its value is "autoNoTable".</para>
///</summary>
[EnumString("autoNoTable")]
AutoNoTable,
 
}
/// <summary>
/// Reference Mode 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ReferenceModeValues
{  
	///<summary>
///A1 Mode.
///<para>When the item is serialized out as xml, its value is "A1".</para>
///</summary>
[EnumString("A1")]
A1,
///<summary>
///R1C1 Reference Mode.
///<para>When the item is serialized out as xml, its value is "R1C1".</para>
///</summary>
[EnumString("R1C1")]
R1C1,
 
}
/// <summary>
/// Target Screen Size Types 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TargetScreenSizeValues
{  
	///<summary>
///544 x 376 Resolution.
///<para>When the item is serialized out as xml, its value is "544x376".</para>
///</summary>
[EnumString("544x376")]
Sz544x376,
///<summary>
///640 x 480 Resolution.
///<para>When the item is serialized out as xml, its value is "640x480".</para>
///</summary>
[EnumString("640x480")]
Sz640x480,
///<summary>
///720 x 512 Resolution.
///<para>When the item is serialized out as xml, its value is "720x512".</para>
///</summary>
[EnumString("720x512")]
Sz720x512,
///<summary>
///800 x 600 Resolution.
///<para>When the item is serialized out as xml, its value is "800x600".</para>
///</summary>
[EnumString("800x600")]
Sz800x600,
///<summary>
///1024 x 768 Resolution.
///<para>When the item is serialized out as xml, its value is "1024x768".</para>
///</summary>
[EnumString("1024x768")]
Sz1024x768,
///<summary>
///1152 x 882 Resolution.
///<para>When the item is serialized out as xml, its value is "1152x882".</para>
///</summary>
[EnumString("1152x882")]
Sz1152x882,
///<summary>
///1152 x 900 Resolution.
///<para>When the item is serialized out as xml, its value is "1152x900".</para>
///</summary>
[EnumString("1152x900")]
Sz1152x900,
///<summary>
///1280 x 1024 Resolution.
///<para>When the item is serialized out as xml, its value is "1280x1024".</para>
///</summary>
[EnumString("1280x1024")]
Sz1280x1024,
///<summary>
///1600 x 1200 Resolution.
///<para>When the item is serialized out as xml, its value is "1600x1200".</para>
///</summary>
[EnumString("1600x1200")]
Sz1600x1200,
///<summary>
///1800 x 1440 Resolution.
///<para>When the item is serialized out as xml, its value is "1800x1440".</para>
///</summary>
[EnumString("1800x1440")]
Sz1800x1440,
///<summary>
///1920 x 1200 Resolution.
///<para>When the item is serialized out as xml, its value is "1920x1200".</para>
///</summary>
[EnumString("1920x1200")]
Sz1920x1200,
 
}
/// <summary>
/// Defines the TextHorizontalAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextHorizontalAlignmentValues
{  
	///<summary>
///left.
///<para>When the item is serialized out as xml, its value is "left".</para>
///</summary>
[EnumString("left")]
Left,
///<summary>
///center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///right.
///<para>When the item is serialized out as xml, its value is "right".</para>
///</summary>
[EnumString("right")]
Right,
///<summary>
///justify.
///<para>When the item is serialized out as xml, its value is "justify".</para>
///</summary>
[EnumString("justify")]
Justify,
///<summary>
///distributed.
///<para>When the item is serialized out as xml, its value is "distributed".</para>
///</summary>
[EnumString("distributed")]
Distributed,
 
}
/// <summary>
/// Defines the TextVerticalAlignmentValues enumeration. 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum TextVerticalAlignmentValues
{  
	///<summary>
///top.
///<para>When the item is serialized out as xml, its value is "top".</para>
///</summary>
[EnumString("top")]
Top,
///<summary>
///center.
///<para>When the item is serialized out as xml, its value is "center".</para>
///</summary>
[EnumString("center")]
Center,
///<summary>
///bottom.
///<para>When the item is serialized out as xml, its value is "bottom".</para>
///</summary>
[EnumString("bottom")]
Bottom,
///<summary>
///justify.
///<para>When the item is serialized out as xml, its value is "justify".</para>
///</summary>
[EnumString("justify")]
Justify,
///<summary>
///distributed.
///<para>When the item is serialized out as xml, its value is "distributed".</para>
///</summary>
[EnumString("distributed")]
Distributed,
 
}
/// <summary>
/// Cell Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum CellValues
{  
	///<summary>
///Boolean.
///<para>When the item is serialized out as xml, its value is "b".</para>
///</summary>
[EnumString("b")]
Boolean,
///<summary>
///Number.
///<para>When the item is serialized out as xml, its value is "n".</para>
///</summary>
[EnumString("n")]
Number,
///<summary>
///Error.
///<para>When the item is serialized out as xml, its value is "e".</para>
///</summary>
[EnumString("e")]
Error,
///<summary>
///Shared String.
///<para>When the item is serialized out as xml, its value is "s".</para>
///</summary>
[EnumString("s")]
SharedString,
///<summary>
///String.
///<para>When the item is serialized out as xml, its value is "str".</para>
///</summary>
[EnumString("str")]
String,
///<summary>
///Inline String.
///<para>When the item is serialized out as xml, its value is "inlineStr".</para>
///</summary>
[EnumString("inlineStr")]
InlineString,
///<summary>
///d.
///<para>When the item is serialized out as xml, its value is "d".</para>
///</summary>
[EnumString("d")]
Date,
 
}
/// <summary>
/// Rule Type 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum PivotAreaValues
{  
	///<summary>
///None.
///<para>When the item is serialized out as xml, its value is "none".</para>
///</summary>
[EnumString("none")]
None,
///<summary>
///Normal.
///<para>When the item is serialized out as xml, its value is "normal".</para>
///</summary>
[EnumString("normal")]
Normal,
///<summary>
///Data.
///<para>When the item is serialized out as xml, its value is "data".</para>
///</summary>
[EnumString("data")]
Data,
///<summary>
///All.
///<para>When the item is serialized out as xml, its value is "all".</para>
///</summary>
[EnumString("all")]
All,
///<summary>
///Origin.
///<para>When the item is serialized out as xml, its value is "origin".</para>
///</summary>
[EnumString("origin")]
Origin,
///<summary>
///Field Button.
///<para>When the item is serialized out as xml, its value is "button".</para>
///</summary>
[EnumString("button")]
Button,
///<summary>
///Top Right.
///<para>When the item is serialized out as xml, its value is "topRight".</para>
///</summary>
[EnumString("topRight")]
TopRight,
///<summary>
///topEnd.
///<para>When the item is serialized out as xml, its value is "topEnd".</para>
///</summary>
[EnumString("topEnd")]
TopEnd,
 
}
/// <summary>
/// Document Conformance Class Value 
/// </summary> 
[System.CodeDom.Compiler.GeneratedCode("DomGen", "2.0")]
public enum ConformanceClass
{  
	///<summary>
///Office Open XML Strict.
///<para>When the item is serialized out as xml, its value is "strict".</para>
///</summary>
[EnumString("strict")]
Enumstrict,
///<summary>
///Office Open XML Transitional.
///<para>When the item is serialized out as xml, its value is "transitional".</para>
///</summary>
[EnumString("transitional")]
Enumtransitional,
 
}
}
 
 
